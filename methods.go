/*
Package openconfig is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /go/src/github.com/openconfig/ygot/genutil/names.go
using the following YANG input files:
	- /work/public/release/models/network-instance/openconfig-network-instance.yang
	- /work/public/release/models/mpls/openconfig-mpls.yang
	- /work/public/release/models/optical-transport/openconfig-optical-amplifier.yang
	- /work/public/release/models/optical-transport/openconfig-terminal-device.yang
	- /work/public/release/models/optical-transport/openconfig-transport-line-protection.yang
	- /work/public/release/models/platform/openconfig-platform.yang
	- /work/public/release/models/policy/openconfig-routing-policy.yang
	- /work/public/release/models/lacp/openconfig-lacp.yang
	- /work/public/release/models/system/openconfig-system.yang
	- /work/public/release/models/lldp/openconfig-lldp.yang
	- /work/public/release/models/stp/openconfig-spanning-tree.yang
	- /work/public/release/models/interfaces/openconfig-interfaces.yang
	- /work/public/release/models/interfaces/openconfig-if-ip.yang
	- /work/public/release/models/interfaces/openconfig-if-aggregate.yang
	- /work/public/release/models/interfaces/openconfig-if-ethernet.yang
	- /work/public/release/models/interfaces/openconfig-if-ip-ext.yang
	- /work/public/release/models/local-routing/openconfig-local-routing.yang
	- /work/public/release/models/vlan/openconfig-vlan.yang
	- /work/public/release/models/vlan/openconfig-vlan-types.yang
Imported modules were sourced from:
	- /work/public/...
	- yang/...
*/
package openconfig

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

var (
	SchemaTree map[string]*yang.Entry
)

func init() {
	var err error
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// NewAclSet creates a new entry in the AclSet list of the
// Acl struct. The keys of the list are populated from the input
// arguments.
func (t *Acl) NewAclSet(Name string, Type E_OpenconfigAcl_ACL_TYPE) (*Acl_AclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclSet == nil {
		t.AclSet = make(map[Acl_AclSet_Key]*Acl_AclSet)
	}

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclSet", key)
	}

	t.AclSet[key] = &Acl_AclSet{
		Name: &Name,
		Type: Type,
	}

	return t.AclSet[key], nil
}

// RenameAclSet renames an entry in the list AclSet within
// the Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl) RenameAclSet(oldK, newK Acl_AclSet_Key) error {
	if _, ok := t.AclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in AclSet", newK)
	}

	e, ok := t.AclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclSet", oldK)
	}
	e.Name = &newK.Name
	e.Type = newK.Type

	t.AclSet[newK] = e
	delete(t.AclSet, oldK)
	return nil
}

// GetOrCreateAclSet retrieves the value with the specified keys from
// the receiver Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl) GetOrCreateAclSet(Name string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_AclSet {

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	if v, ok := t.AclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclSet(Name, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclSet got unexpected error: %v", err))
	}
	return v
}

// GetAclSet retrieves the value with the specified key from
// the AclSet map field of Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl) GetAclSet(Name string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_AclSet {

	if t == nil {
		return nil
	}

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	if lm, ok := t.AclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclSet deletes the value with the specified keys from
// the receiver Acl. If there is no such element, the function
// is a no-op.
func (t *Acl) DeleteAclSet(Name string, Type E_OpenconfigAcl_ACL_TYPE) {
	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	delete(t.AclSet, key)
}

// AppendAclSet appends the supplied Acl_AclSet struct to the
// list AclSet of Acl. If the key value(s) specified in
// the supplied Acl_AclSet already exist in the list, an error is
// returned.
func (t *Acl) AppendAclSet(v *Acl_AclSet) error {
	key := Acl_AclSet_Key{Name: *v.Name, Type: v.Type}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclSet == nil {
		t.AclSet = make(map[Acl_AclSet_Key]*Acl_AclSet)
	}

	if _, ok := t.AclSet[key]; ok {
		return fmt.Errorf("duplicate key for list AclSet %v", key)
	}

	t.AclSet[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Acl struct. The keys of the list are populated from the input
// arguments.
func (t *Acl) NewInterface(Id string) (*Acl_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Acl_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Acl_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl) GetOrCreateInterface(Id string) *Acl_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl) GetInterface(Id string) *Acl_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Acl. If there is no such element, the function
// is a no-op.
func (t *Acl) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Acl_Interface struct to the
// list Interface of Acl. If the key value(s) specified in
// the supplied Acl_Interface already exist in the list, an error is
// returned.
func (t *Acl) AppendInterface(v *Acl_Interface) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Acl_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_AclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_AclSet) NewAclEntry(SequenceId uint32) (*Acl_AclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_AclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_AclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_AclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_AclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_AclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_AclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_AclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_AclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_AclSet) GetAclEntry(SequenceId uint32) *Acl_AclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_AclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_AclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_AclSet_AclEntry struct to the
// list AclEntry of Acl_AclSet. If the key value(s) specified in
// the supplied Acl_AclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_AclSet) AppendAclEntry(v *Acl_AclSet_AclEntry) error {
	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_AclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Acl_AclSet struct, which is a YANG list entry.
func (t *Acl_AclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateActions retrieves the value of the Actions field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateActions() *Acl_AclSet_AclEntry_Actions {
	if t.Actions != nil {
		return t.Actions
	}
	t.Actions = &Acl_AclSet_AclEntry_Actions{}
	return t.Actions
}

// GetOrCreateInputInterface retrieves the value of the InputInterface field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateInputInterface() *Acl_AclSet_AclEntry_InputInterface {
	if t.InputInterface != nil {
		return t.InputInterface
	}
	t.InputInterface = &Acl_AclSet_AclEntry_InputInterface{}
	return t.InputInterface
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateIpv4() *Acl_AclSet_AclEntry_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Acl_AclSet_AclEntry_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateIpv6() *Acl_AclSet_AclEntry_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Acl_AclSet_AclEntry_Ipv6{}
	return t.Ipv6
}

// GetOrCreateL2 retrieves the value of the L2 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateL2() *Acl_AclSet_AclEntry_L2 {
	if t.L2 != nil {
		return t.L2
	}
	t.L2 = &Acl_AclSet_AclEntry_L2{}
	return t.L2
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateTransport() *Acl_AclSet_AclEntry_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &Acl_AclSet_AclEntry_Transport{}
	return t.Transport
}

// GetActions returns the value of the Actions struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Actions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetActions() *Acl_AclSet_AclEntry_Actions {
	if t != nil && t.Actions != nil {
		return t.Actions
	}
	return nil
}

// GetInputInterface returns the value of the InputInterface struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field InputInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetInputInterface() *Acl_AclSet_AclEntry_InputInterface {
	if t != nil && t.InputInterface != nil {
		return t.InputInterface
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetIpv4() *Acl_AclSet_AclEntry_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetIpv6() *Acl_AclSet_AclEntry_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetL2 returns the value of the L2 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field L2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetL2() *Acl_AclSet_AclEntry_L2 {
	if t != nil && t.L2 != nil {
		return t.L2
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetTransport() *Acl_AclSet_AclEntry_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// ΛListKeyMap returns the keys of the Acl_AclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_AclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Actions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Actions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Actions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry_InputInterface) GetOrCreateInterfaceRef() *Acl_AclSet_AclEntry_InputInterface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Acl_AclSet_AclEntry_InputInterface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Acl_AclSet_AclEntry_InputInterface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry_InputInterface) GetInterfaceRef() *Acl_AclSet_AclEntry_InputInterface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_InputInterface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_L2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_L2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_L2) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEgressAclSet creates a new entry in the EgressAclSet list of the
// Acl_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface) NewEgressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) (*Acl_Interface_EgressAclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EgressAclSet == nil {
		t.EgressAclSet = make(map[Acl_Interface_EgressAclSet_Key]*Acl_Interface_EgressAclSet)
	}

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EgressAclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EgressAclSet", key)
	}

	t.EgressAclSet[key] = &Acl_Interface_EgressAclSet{
		SetName: &SetName,
		Type:    Type,
	}

	return t.EgressAclSet[key], nil
}

// RenameEgressAclSet renames an entry in the list EgressAclSet within
// the Acl_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface) RenameEgressAclSet(oldK, newK Acl_Interface_EgressAclSet_Key) error {
	if _, ok := t.EgressAclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in EgressAclSet", newK)
	}

	e, ok := t.EgressAclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EgressAclSet", oldK)
	}
	e.SetName = &newK.SetName
	e.Type = newK.Type

	t.EgressAclSet[newK] = e
	delete(t.EgressAclSet, oldK)
	return nil
}

// GetOrCreateEgressAclSet retrieves the value with the specified keys from
// the receiver Acl_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface) GetOrCreateEgressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_Interface_EgressAclSet {

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if v, ok := t.EgressAclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEgressAclSet(SetName, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEgressAclSet got unexpected error: %v", err))
	}
	return v
}

// GetEgressAclSet retrieves the value with the specified key from
// the EgressAclSet map field of Acl_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface) GetEgressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_Interface_EgressAclSet {

	if t == nil {
		return nil
	}

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if lm, ok := t.EgressAclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteEgressAclSet deletes the value with the specified keys from
// the receiver Acl_Interface. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface) DeleteEgressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) {
	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	delete(t.EgressAclSet, key)
}

// AppendEgressAclSet appends the supplied Acl_Interface_EgressAclSet struct to the
// list EgressAclSet of Acl_Interface. If the key value(s) specified in
// the supplied Acl_Interface_EgressAclSet already exist in the list, an error is
// returned.
func (t *Acl_Interface) AppendEgressAclSet(v *Acl_Interface_EgressAclSet) error {
	key := Acl_Interface_EgressAclSet_Key{SetName: *v.SetName, Type: v.Type}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EgressAclSet == nil {
		t.EgressAclSet = make(map[Acl_Interface_EgressAclSet_Key]*Acl_Interface_EgressAclSet)
	}

	if _, ok := t.EgressAclSet[key]; ok {
		return fmt.Errorf("duplicate key for list EgressAclSet %v", key)
	}

	t.EgressAclSet[key] = v
	return nil
}

// NewIngressAclSet creates a new entry in the IngressAclSet list of the
// Acl_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface) NewIngressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) (*Acl_Interface_IngressAclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IngressAclSet == nil {
		t.IngressAclSet = make(map[Acl_Interface_IngressAclSet_Key]*Acl_Interface_IngressAclSet)
	}

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IngressAclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IngressAclSet", key)
	}

	t.IngressAclSet[key] = &Acl_Interface_IngressAclSet{
		SetName: &SetName,
		Type:    Type,
	}

	return t.IngressAclSet[key], nil
}

// RenameIngressAclSet renames an entry in the list IngressAclSet within
// the Acl_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface) RenameIngressAclSet(oldK, newK Acl_Interface_IngressAclSet_Key) error {
	if _, ok := t.IngressAclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in IngressAclSet", newK)
	}

	e, ok := t.IngressAclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IngressAclSet", oldK)
	}
	e.SetName = &newK.SetName
	e.Type = newK.Type

	t.IngressAclSet[newK] = e
	delete(t.IngressAclSet, oldK)
	return nil
}

// GetOrCreateIngressAclSet retrieves the value with the specified keys from
// the receiver Acl_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface) GetOrCreateIngressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_Interface_IngressAclSet {

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if v, ok := t.IngressAclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIngressAclSet(SetName, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIngressAclSet got unexpected error: %v", err))
	}
	return v
}

// GetIngressAclSet retrieves the value with the specified key from
// the IngressAclSet map field of Acl_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface) GetIngressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) *Acl_Interface_IngressAclSet {

	if t == nil {
		return nil
	}

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if lm, ok := t.IngressAclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteIngressAclSet deletes the value with the specified keys from
// the receiver Acl_Interface. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface) DeleteIngressAclSet(SetName string, Type E_OpenconfigAcl_ACL_TYPE) {
	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	delete(t.IngressAclSet, key)
}

// AppendIngressAclSet appends the supplied Acl_Interface_IngressAclSet struct to the
// list IngressAclSet of Acl_Interface. If the key value(s) specified in
// the supplied Acl_Interface_IngressAclSet already exist in the list, an error is
// returned.
func (t *Acl_Interface) AppendIngressAclSet(v *Acl_Interface_IngressAclSet) error {
	key := Acl_Interface_IngressAclSet_Key{SetName: *v.SetName, Type: v.Type}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IngressAclSet == nil {
		t.IngressAclSet = make(map[Acl_Interface_IngressAclSet_Key]*Acl_Interface_IngressAclSet)
	}

	if _, ok := t.IngressAclSet[key]; ok {
		return fmt.Errorf("duplicate key for list IngressAclSet %v", key)
	}

	t.IngressAclSet[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Acl_Interface) GetOrCreateInterfaceRef() *Acl_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Acl_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Acl_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_Interface) GetInterfaceRef() *Acl_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the Acl_Interface struct, which is a YANG list entry.
func (t *Acl_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_Interface_EgressAclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface_EgressAclSet) NewAclEntry(SequenceId uint32) (*Acl_Interface_EgressAclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_EgressAclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_Interface_EgressAclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_Interface_EgressAclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface_EgressAclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_Interface_EgressAclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface_EgressAclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_Interface_EgressAclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_Interface_EgressAclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface_EgressAclSet) GetAclEntry(SequenceId uint32) *Acl_Interface_EgressAclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_Interface_EgressAclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface_EgressAclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_Interface_EgressAclSet_AclEntry struct to the
// list AclEntry of Acl_Interface_EgressAclSet. If the key value(s) specified in
// the supplied Acl_Interface_EgressAclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_Interface_EgressAclSet) AppendAclEntry(v *Acl_Interface_EgressAclSet_AclEntry) error {
	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_EgressAclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Acl_Interface_EgressAclSet struct, which is a YANG list entry.
func (t *Acl_Interface_EgressAclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SetName == nil {
		return nil, fmt.Errorf("nil value for key SetName")
	}

	return map[string]interface{}{
		"set-name": *t.SetName,
		"type":     t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_EgressAclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_EgressAclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Acl_Interface_EgressAclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_Interface_EgressAclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_EgressAclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_EgressAclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_Interface_IngressAclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface_IngressAclSet) NewAclEntry(SequenceId uint32) (*Acl_Interface_IngressAclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_IngressAclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_Interface_IngressAclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_Interface_IngressAclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface_IngressAclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_Interface_IngressAclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface_IngressAclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_Interface_IngressAclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_Interface_IngressAclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface_IngressAclSet) GetAclEntry(SequenceId uint32) *Acl_Interface_IngressAclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_Interface_IngressAclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface_IngressAclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_Interface_IngressAclSet_AclEntry struct to the
// list AclEntry of Acl_Interface_IngressAclSet. If the key value(s) specified in
// the supplied Acl_Interface_IngressAclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_Interface_IngressAclSet) AppendAclEntry(v *Acl_Interface_IngressAclSet_AclEntry) error {
	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_IngressAclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Acl_Interface_IngressAclSet struct, which is a YANG list entry.
func (t *Acl_Interface_IngressAclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SetName == nil {
		return nil, fmt.Errorf("nil value for key SetName")
	}

	return map[string]interface{}{
		"set-name": *t.SetName,
		"type":     t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_IngressAclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_IngressAclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Acl_Interface_IngressAclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_Interface_IngressAclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_IngressAclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_IngressAclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewApsModule creates a new entry in the ApsModule list of the
// Aps struct. The keys of the list are populated from the input
// arguments.
func (t *Aps) NewApsModule(Name string) (*Aps_ApsModule, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApsModule == nil {
		t.ApsModule = make(map[string]*Aps_ApsModule)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ApsModule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ApsModule", key)
	}

	t.ApsModule[key] = &Aps_ApsModule{
		Name: &Name,
	}

	return t.ApsModule[key], nil
}

// RenameApsModule renames an entry in the list ApsModule within
// the Aps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Aps) RenameApsModule(oldK, newK string) error {
	if _, ok := t.ApsModule[newK]; ok {
		return fmt.Errorf("key %v already exists in ApsModule", newK)
	}

	e, ok := t.ApsModule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ApsModule", oldK)
	}
	e.Name = &newK

	t.ApsModule[newK] = e
	delete(t.ApsModule, oldK)
	return nil
}

// GetOrCreateApsModule retrieves the value with the specified keys from
// the receiver Aps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Aps) GetOrCreateApsModule(Name string) *Aps_ApsModule {

	key := Name

	if v, ok := t.ApsModule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewApsModule(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateApsModule got unexpected error: %v", err))
	}
	return v
}

// GetApsModule retrieves the value with the specified key from
// the ApsModule map field of Aps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Aps) GetApsModule(Name string) *Aps_ApsModule {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ApsModule[key]; ok {
		return lm
	}
	return nil
}

// DeleteApsModule deletes the value with the specified keys from
// the receiver Aps. If there is no such element, the function
// is a no-op.
func (t *Aps) DeleteApsModule(Name string) {
	key := Name

	delete(t.ApsModule, key)
}

// AppendApsModule appends the supplied Aps_ApsModule struct to the
// list ApsModule of Aps. If the key value(s) specified in
// the supplied Aps_ApsModule already exist in the list, an error is
// returned.
func (t *Aps) AppendApsModule(v *Aps_ApsModule) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApsModule == nil {
		t.ApsModule = make(map[string]*Aps_ApsModule)
	}

	if _, ok := t.ApsModule[key]; ok {
		return fmt.Errorf("duplicate key for list ApsModule %v", key)
	}

	t.ApsModule[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreatePorts retrieves the value of the Ports field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule) GetOrCreatePorts() *Aps_ApsModule_Ports {
	if t.Ports != nil {
		return t.Ports
	}
	t.Ports = &Aps_ApsModule_Ports{}
	return t.Ports
}

// GetPorts returns the value of the Ports struct pointer
// from Aps_ApsModule. If the receiver or the field Ports is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule) GetPorts() *Aps_ApsModule_Ports {
	if t != nil && t.Ports != nil {
		return t.Ports
	}
	return nil
}

// ΛListKeyMap returns the keys of the Aps_ApsModule struct, which is a YANG list entry.
func (t *Aps_ApsModule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCommonIn retrieves the value of the CommonIn field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateCommonIn() *Aps_ApsModule_Ports_CommonIn {
	if t.CommonIn != nil {
		return t.CommonIn
	}
	t.CommonIn = &Aps_ApsModule_Ports_CommonIn{}
	return t.CommonIn
}

// GetOrCreateCommonOutput retrieves the value of the CommonOutput field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateCommonOutput() *Aps_ApsModule_Ports_CommonOutput {
	if t.CommonOutput != nil {
		return t.CommonOutput
	}
	t.CommonOutput = &Aps_ApsModule_Ports_CommonOutput{}
	return t.CommonOutput
}

// GetOrCreateLinePrimaryIn retrieves the value of the LinePrimaryIn field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateLinePrimaryIn() *Aps_ApsModule_Ports_LinePrimaryIn {
	if t.LinePrimaryIn != nil {
		return t.LinePrimaryIn
	}
	t.LinePrimaryIn = &Aps_ApsModule_Ports_LinePrimaryIn{}
	return t.LinePrimaryIn
}

// GetOrCreateLinePrimaryOut retrieves the value of the LinePrimaryOut field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateLinePrimaryOut() *Aps_ApsModule_Ports_LinePrimaryOut {
	if t.LinePrimaryOut != nil {
		return t.LinePrimaryOut
	}
	t.LinePrimaryOut = &Aps_ApsModule_Ports_LinePrimaryOut{}
	return t.LinePrimaryOut
}

// GetOrCreateLineSecondaryIn retrieves the value of the LineSecondaryIn field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateLineSecondaryIn() *Aps_ApsModule_Ports_LineSecondaryIn {
	if t.LineSecondaryIn != nil {
		return t.LineSecondaryIn
	}
	t.LineSecondaryIn = &Aps_ApsModule_Ports_LineSecondaryIn{}
	return t.LineSecondaryIn
}

// GetOrCreateLineSecondaryOut retrieves the value of the LineSecondaryOut field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports) GetOrCreateLineSecondaryOut() *Aps_ApsModule_Ports_LineSecondaryOut {
	if t.LineSecondaryOut != nil {
		return t.LineSecondaryOut
	}
	t.LineSecondaryOut = &Aps_ApsModule_Ports_LineSecondaryOut{}
	return t.LineSecondaryOut
}

// GetCommonIn returns the value of the CommonIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field CommonIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetCommonIn() *Aps_ApsModule_Ports_CommonIn {
	if t != nil && t.CommonIn != nil {
		return t.CommonIn
	}
	return nil
}

// GetCommonOutput returns the value of the CommonOutput struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field CommonOutput is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetCommonOutput() *Aps_ApsModule_Ports_CommonOutput {
	if t != nil && t.CommonOutput != nil {
		return t.CommonOutput
	}
	return nil
}

// GetLinePrimaryIn returns the value of the LinePrimaryIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LinePrimaryIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetLinePrimaryIn() *Aps_ApsModule_Ports_LinePrimaryIn {
	if t != nil && t.LinePrimaryIn != nil {
		return t.LinePrimaryIn
	}
	return nil
}

// GetLinePrimaryOut returns the value of the LinePrimaryOut struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LinePrimaryOut is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetLinePrimaryOut() *Aps_ApsModule_Ports_LinePrimaryOut {
	if t != nil && t.LinePrimaryOut != nil {
		return t.LinePrimaryOut
	}
	return nil
}

// GetLineSecondaryIn returns the value of the LineSecondaryIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LineSecondaryIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetLineSecondaryIn() *Aps_ApsModule_Ports_LineSecondaryIn {
	if t != nil && t.LineSecondaryIn != nil {
		return t.LineSecondaryIn
	}
	return nil
}

// GetLineSecondaryOut returns the value of the LineSecondaryOut struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LineSecondaryOut is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports) GetLineSecondaryOut() *Aps_ApsModule_Ports_LineSecondaryOut {
	if t != nil && t.LineSecondaryOut != nil {
		return t.LineSecondaryOut
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_CommonIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_CommonIn_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_CommonIn_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_CommonIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_CommonIn) GetOpticalPower() *Aps_ApsModule_Ports_CommonIn_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_CommonIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonIn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonIn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_CommonIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonIn_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_CommonOutput) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_CommonOutput_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_CommonOutput_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_CommonOutput. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_CommonOutput) GetOpticalPower() *Aps_ApsModule_Ports_CommonOutput_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_CommonOutput) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonOutput"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonOutput) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_CommonOutput_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonOutput_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonOutput_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_LinePrimaryIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LinePrimaryIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_LinePrimaryIn) GetOpticalPower() *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LinePrimaryIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryIn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryIn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_LinePrimaryOut) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LinePrimaryOut. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_LinePrimaryOut) GetOpticalPower() *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LinePrimaryOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryOut"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryOut) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_LineSecondaryIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LineSecondaryIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_LineSecondaryIn) GetOpticalPower() *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LineSecondaryIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryIn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryIn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (t *Aps_ApsModule_Ports_LineSecondaryOut) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower {
	if t.OpticalPower != nil {
		return t.OpticalPower
	}
	t.OpticalPower = &Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower{}
	return t.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LineSecondaryOut. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Aps_ApsModule_Ports_LineSecondaryOut) GetOpticalPower() *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower {
	if t != nil && t.OpticalPower != nil {
		return t.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LineSecondaryOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryOut"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryOut) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp) NewNeighbor(NeighborAddress string) (*Bgp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Bgp_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Bgp_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp) GetOrCreateNeighbor(NeighborAddress string) *Bgp_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp) GetNeighbor(NeighborAddress string) *Bgp_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Bgp. If there is no such element, the function
// is a no-op.
func (t *Bgp) DeleteNeighbor(NeighborAddress string) {
	key := NeighborAddress

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Bgp_Neighbor struct to the
// list Neighbor of Bgp. If the key value(s) specified in
// the supplied Bgp_Neighbor already exist in the list, an error is
// returned.
func (t *Bgp) AppendNeighbor(v *Bgp_Neighbor) error {
	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Bgp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewPeerGroup creates a new entry in the PeerGroup list of the
// Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp) NewPeerGroup(PeerGroupName string) (*Bgp_PeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*Bgp_PeerGroup)
	}

	key := PeerGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PeerGroup", key)
	}

	t.PeerGroup[key] = &Bgp_PeerGroup{
		PeerGroupName: &PeerGroupName,
	}

	return t.PeerGroup[key], nil
}

// RenamePeerGroup renames an entry in the list PeerGroup within
// the Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp) RenamePeerGroup(oldK, newK string) error {
	if _, ok := t.PeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PeerGroup", newK)
	}

	e, ok := t.PeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PeerGroup", oldK)
	}
	e.PeerGroupName = &newK

	t.PeerGroup[newK] = e
	delete(t.PeerGroup, oldK)
	return nil
}

// GetOrCreatePeerGroup retrieves the value with the specified keys from
// the receiver Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp) GetOrCreatePeerGroup(PeerGroupName string) *Bgp_PeerGroup {

	key := PeerGroupName

	if v, ok := t.PeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPeerGroup(PeerGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetPeerGroup retrieves the value with the specified key from
// the PeerGroup map field of Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp) GetPeerGroup(PeerGroupName string) *Bgp_PeerGroup {

	if t == nil {
		return nil
	}

	key := PeerGroupName

	if lm, ok := t.PeerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeletePeerGroup deletes the value with the specified keys from
// the receiver Bgp. If there is no such element, the function
// is a no-op.
func (t *Bgp) DeletePeerGroup(PeerGroupName string) {
	key := PeerGroupName

	delete(t.PeerGroup, key)
}

// AppendPeerGroup appends the supplied Bgp_PeerGroup struct to the
// list PeerGroup of Bgp. If the key value(s) specified in
// the supplied Bgp_PeerGroup already exist in the list, an error is
// returned.
func (t *Bgp) AppendPeerGroup(v *Bgp_PeerGroup) error {
	key := *v.PeerGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*Bgp_PeerGroup)
	}

	if _, ok := t.PeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PeerGroup %v", key)
	}

	t.PeerGroup[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *Bgp) GetOrCreateGlobal() *Bgp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &Bgp_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from Bgp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp) GetGlobal() *Bgp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Global) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_Global_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Global_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_Global_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Global) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Global) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Global_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Global) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Global_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *Bgp_Global) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied Bgp_Global_AfiSafi struct to the
// list AfiSafi of Bgp_Global. If the key value(s) specified in
// the supplied Bgp_Global_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_Global) AppendAfiSafi(v *Bgp_Global_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Global_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// NewDynamicNeighborPrefix creates a new entry in the DynamicNeighborPrefix list of the
// Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Global) NewDynamicNeighborPrefix(Prefix string) (*Bgp_Global_DynamicNeighborPrefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*Bgp_Global_DynamicNeighborPrefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DynamicNeighborPrefix", key)
	}

	t.DynamicNeighborPrefix[key] = &Bgp_Global_DynamicNeighborPrefix{
		Prefix: &Prefix,
	}

	return t.DynamicNeighborPrefix[key], nil
}

// RenameDynamicNeighborPrefix renames an entry in the list DynamicNeighborPrefix within
// the Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Global) RenameDynamicNeighborPrefix(oldK, newK string) error {
	if _, ok := t.DynamicNeighborPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in DynamicNeighborPrefix", newK)
	}

	e, ok := t.DynamicNeighborPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DynamicNeighborPrefix", oldK)
	}
	e.Prefix = &newK

	t.DynamicNeighborPrefix[newK] = e
	delete(t.DynamicNeighborPrefix, oldK)
	return nil
}

// GetOrCreateDynamicNeighborPrefix retrieves the value with the specified keys from
// the receiver Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Global) GetOrCreateDynamicNeighborPrefix(Prefix string) *Bgp_Global_DynamicNeighborPrefix {

	key := Prefix

	if v, ok := t.DynamicNeighborPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamicNeighborPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamicNeighborPrefix got unexpected error: %v", err))
	}
	return v
}

// GetDynamicNeighborPrefix retrieves the value with the specified key from
// the DynamicNeighborPrefix map field of Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Global) GetDynamicNeighborPrefix(Prefix string) *Bgp_Global_DynamicNeighborPrefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.DynamicNeighborPrefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteDynamicNeighborPrefix deletes the value with the specified keys from
// the receiver Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *Bgp_Global) DeleteDynamicNeighborPrefix(Prefix string) {
	key := Prefix

	delete(t.DynamicNeighborPrefix, key)
}

// AppendDynamicNeighborPrefix appends the supplied Bgp_Global_DynamicNeighborPrefix struct to the
// list DynamicNeighborPrefix of Bgp_Global. If the key value(s) specified in
// the supplied Bgp_Global_DynamicNeighborPrefix already exist in the list, an error is
// returned.
func (t *Bgp_Global) AppendDynamicNeighborPrefix(v *Bgp_Global_DynamicNeighborPrefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*Bgp_Global_DynamicNeighborPrefix)
	}

	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list DynamicNeighborPrefix %v", key)
	}

	t.DynamicNeighborPrefix[key] = v
	return nil
}

// GetOrCreateConfederation retrieves the value of the Confederation field
// or returns the existing field if it already exists.
func (t *Bgp_Global) GetOrCreateConfederation() *Bgp_Global_Confederation {
	if t.Confederation != nil {
		return t.Confederation
	}
	t.Confederation = &Bgp_Global_Confederation{}
	return t.Confederation
}

// GetOrCreateDefaultRouteDistance retrieves the value of the DefaultRouteDistance field
// or returns the existing field if it already exists.
func (t *Bgp_Global) GetOrCreateDefaultRouteDistance() *Bgp_Global_DefaultRouteDistance {
	if t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	t.DefaultRouteDistance = &Bgp_Global_DefaultRouteDistance{}
	return t.DefaultRouteDistance
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_Global) GetOrCreateGracefulRestart() *Bgp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *Bgp_Global) GetOrCreateRouteSelectionOptions() *Bgp_Global_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &Bgp_Global_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_Global) GetOrCreateUseMultiplePaths() *Bgp_Global_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_Global_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetConfederation returns the value of the Confederation struct pointer
// from Bgp_Global. If the receiver or the field Confederation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global) GetConfederation() *Bgp_Global_Confederation {
	if t != nil && t.Confederation != nil {
		return t.Confederation
	}
	return nil
}

// GetDefaultRouteDistance returns the value of the DefaultRouteDistance struct pointer
// from Bgp_Global. If the receiver or the field DefaultRouteDistance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global) GetDefaultRouteDistance() *Bgp_Global_DefaultRouteDistance {
	if t != nil && t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global) GetGracefulRestart() *Bgp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from Bgp_Global. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global) GetRouteSelectionOptions() *Bgp_Global_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Global. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global) GetUseMultiplePaths() *Bgp_Global_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateAddPaths() *Bgp_Global_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &Bgp_Global_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateGracefulRestart() *Bgp_Global_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_Global_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &Bgp_Global_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_Global_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &Bgp_Global_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &Bgp_Global_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_Global_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &Bgp_Global_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_Global_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &Bgp_Global_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_Global_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &Bgp_Global_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &Bgp_Global_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &Bgp_Global_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &Bgp_Global_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &Bgp_Global_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateRouteSelectionOptions() *Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &Bgp_Global_AfiSafi_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &Bgp_Global_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &Bgp_Global_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_Global_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_Global_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetAddPaths() *Bgp_Global_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetGracefulRestart() *Bgp_Global_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetIpv4LabeledUnicast() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetIpv4Unicast() *Bgp_Global_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetIpv6LabeledUnicast() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetIpv6Unicast() *Bgp_Global_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL2VpnEvpn() *Bgp_Global_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL2VpnVpls() *Bgp_Global_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetRouteSelectionOptions() *Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetSrtePolicyIpv4() *Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetSrtePolicyIpv6() *Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi) GetUseMultiplePaths() *Bgp_Global_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Global_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_Global_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_RouteSelectionOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) GetIbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_Confederation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_Confederation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_Confederation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_DefaultRouteDistance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_DefaultRouteDistance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_DefaultRouteDistance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Bgp_Global_DynamicNeighborPrefix struct, which is a YANG list entry.
func (t *Bgp_Global_DynamicNeighborPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_DynamicNeighborPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_DynamicNeighborPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_DynamicNeighborPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_RouteSelectionOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_Global_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Global_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_Global_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *Bgp_Global_UseMultiplePaths) GetOrCreateIbgp() *Bgp_Global_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &Bgp_Global_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Global_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_UseMultiplePaths) GetEbgp() *Bgp_Global_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_Global_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Global_UseMultiplePaths) GetIbgp() *Bgp_Global_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Global_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Neighbor) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_Neighbor_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Neighbor_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_Neighbor_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Neighbor) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Neighbor) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Neighbor_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Neighbor) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Neighbor_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver Bgp_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Bgp_Neighbor) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied Bgp_Neighbor_AfiSafi struct to the
// list AfiSafi of Bgp_Neighbor. If the key value(s) specified in
// the supplied Bgp_Neighbor_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_Neighbor) AppendAfiSafi(v *Bgp_Neighbor_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Neighbor_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateApplyPolicy() *Bgp_Neighbor_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &Bgp_Neighbor_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateAsPathOptions() *Bgp_Neighbor_AsPathOptions {
	if t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	t.AsPathOptions = &Bgp_Neighbor_AsPathOptions{}
	return t.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateEbgpMultihop() *Bgp_Neighbor_EbgpMultihop {
	if t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	t.EbgpMultihop = &Bgp_Neighbor_EbgpMultihop{}
	return t.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateErrorHandling() *Bgp_Neighbor_ErrorHandling {
	if t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	t.ErrorHandling = &Bgp_Neighbor_ErrorHandling{}
	return t.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateGracefulRestart() *Bgp_Neighbor_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_Neighbor_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateLoggingOptions() *Bgp_Neighbor_LoggingOptions {
	if t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	t.LoggingOptions = &Bgp_Neighbor_LoggingOptions{}
	return t.LoggingOptions
}

// GetOrCreateMessages retrieves the value of the Messages field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateMessages() *Bgp_Neighbor_Messages {
	if t.Messages != nil {
		return t.Messages
	}
	t.Messages = &Bgp_Neighbor_Messages{}
	return t.Messages
}

// GetOrCreateQueues retrieves the value of the Queues field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateQueues() *Bgp_Neighbor_Queues {
	if t.Queues != nil {
		return t.Queues
	}
	t.Queues = &Bgp_Neighbor_Queues{}
	return t.Queues
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateRouteReflector() *Bgp_Neighbor_RouteReflector {
	if t.RouteReflector != nil {
		return t.RouteReflector
	}
	t.RouteReflector = &Bgp_Neighbor_RouteReflector{}
	return t.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateTimers() *Bgp_Neighbor_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &Bgp_Neighbor_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateTransport() *Bgp_Neighbor_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &Bgp_Neighbor_Transport{}
	return t.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor) GetOrCreateUseMultiplePaths() *Bgp_Neighbor_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_Neighbor_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_Neighbor. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetApplyPolicy() *Bgp_Neighbor_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from Bgp_Neighbor. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetAsPathOptions() *Bgp_Neighbor_AsPathOptions {
	if t != nil && t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from Bgp_Neighbor. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetEbgpMultihop() *Bgp_Neighbor_EbgpMultihop {
	if t != nil && t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from Bgp_Neighbor. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetErrorHandling() *Bgp_Neighbor_ErrorHandling {
	if t != nil && t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Neighbor. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetGracefulRestart() *Bgp_Neighbor_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from Bgp_Neighbor. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetLoggingOptions() *Bgp_Neighbor_LoggingOptions {
	if t != nil && t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	return nil
}

// GetMessages returns the value of the Messages struct pointer
// from Bgp_Neighbor. If the receiver or the field Messages is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetMessages() *Bgp_Neighbor_Messages {
	if t != nil && t.Messages != nil {
		return t.Messages
	}
	return nil
}

// GetQueues returns the value of the Queues struct pointer
// from Bgp_Neighbor. If the receiver or the field Queues is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetQueues() *Bgp_Neighbor_Queues {
	if t != nil && t.Queues != nil {
		return t.Queues
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from Bgp_Neighbor. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetRouteReflector() *Bgp_Neighbor_RouteReflector {
	if t != nil && t.RouteReflector != nil {
		return t.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from Bgp_Neighbor. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetTimers() *Bgp_Neighbor_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Bgp_Neighbor. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetTransport() *Bgp_Neighbor_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Neighbor. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor) GetUseMultiplePaths() *Bgp_Neighbor_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Neighbor struct, which is a YANG list entry.
func (t *Bgp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NeighborAddress == nil {
		return nil, fmt.Errorf("nil value for key NeighborAddress")
	}

	return map[string]interface{}{
		"neighbor-address": *t.NeighborAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateAddPaths() *Bgp_Neighbor_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &Bgp_Neighbor_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateApplyPolicy() *Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &Bgp_Neighbor_AfiSafi_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateGracefulRestart() *Bgp_Neighbor_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_Neighbor_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &Bgp_Neighbor_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &Bgp_Neighbor_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &Bgp_Neighbor_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &Bgp_Neighbor_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreatePrefixes retrieves the value of the Prefixes field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreatePrefixes() *Bgp_Neighbor_AfiSafi_Prefixes {
	if t.Prefixes != nil {
		return t.Prefixes
	}
	t.Prefixes = &Bgp_Neighbor_AfiSafi_Prefixes{}
	return t.Prefixes
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_Neighbor_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetAddPaths() *Bgp_Neighbor_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetApplyPolicy() *Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetGracefulRestart() *Bgp_Neighbor_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetIpv4LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetIpv4Unicast() *Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetIpv6LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetIpv6Unicast() *Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL2VpnEvpn() *Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL2VpnVpls() *Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetPrefixes returns the value of the Prefixes struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Prefixes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetPrefixes() *Bgp_Neighbor_AfiSafi_Prefixes {
	if t != nil && t.Prefixes != nil {
		return t.Prefixes
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv4() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv6() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi) GetUseMultiplePaths() *Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Neighbor_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_Neighbor_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_Prefixes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Prefixes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Prefixes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Neighbor_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_EbgpMultihop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_ErrorHandling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_LoggingOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateReceived retrieves the value of the Received field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_Messages) GetOrCreateReceived() *Bgp_Neighbor_Messages_Received {
	if t.Received != nil {
		return t.Received
	}
	t.Received = &Bgp_Neighbor_Messages_Received{}
	return t.Received
}

// GetOrCreateSent retrieves the value of the Sent field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_Messages) GetOrCreateSent() *Bgp_Neighbor_Messages_Sent {
	if t.Sent != nil {
		return t.Sent
	}
	t.Sent = &Bgp_Neighbor_Messages_Sent{}
	return t.Sent
}

// GetReceived returns the value of the Received struct pointer
// from Bgp_Neighbor_Messages. If the receiver or the field Received is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_Messages) GetReceived() *Bgp_Neighbor_Messages_Received {
	if t != nil && t.Received != nil {
		return t.Received
	}
	return nil
}

// GetSent returns the value of the Sent struct pointer
// from Bgp_Neighbor_Messages. If the receiver or the field Sent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_Messages) GetSent() *Bgp_Neighbor_Messages_Sent {
	if t != nil && t.Sent != nil {
		return t.Sent
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Messages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Messages_Received) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages_Received"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages_Received) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Messages_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages_Sent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages_Sent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Queues) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Queues"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Queues) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_RouteReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_Neighbor_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_Neighbor_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Neighbor_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_Neighbor_UseMultiplePaths) GetEbgp() *Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_Neighbor_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_PeerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_PeerGroup) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_PeerGroup_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_PeerGroup_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_PeerGroup_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_PeerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_PeerGroup) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_PeerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_PeerGroup) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_PeerGroup_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_PeerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_PeerGroup) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_PeerGroup_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver Bgp_PeerGroup. If there is no such element, the function
// is a no-op.
func (t *Bgp_PeerGroup) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied Bgp_PeerGroup_AfiSafi struct to the
// list AfiSafi of Bgp_PeerGroup. If the key value(s) specified in
// the supplied Bgp_PeerGroup_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_PeerGroup) AppendAfiSafi(v *Bgp_PeerGroup_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_PeerGroup_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateApplyPolicy() *Bgp_PeerGroup_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &Bgp_PeerGroup_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateAsPathOptions() *Bgp_PeerGroup_AsPathOptions {
	if t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	t.AsPathOptions = &Bgp_PeerGroup_AsPathOptions{}
	return t.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateEbgpMultihop() *Bgp_PeerGroup_EbgpMultihop {
	if t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	t.EbgpMultihop = &Bgp_PeerGroup_EbgpMultihop{}
	return t.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateErrorHandling() *Bgp_PeerGroup_ErrorHandling {
	if t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	t.ErrorHandling = &Bgp_PeerGroup_ErrorHandling{}
	return t.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateGracefulRestart() *Bgp_PeerGroup_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_PeerGroup_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateLoggingOptions() *Bgp_PeerGroup_LoggingOptions {
	if t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	t.LoggingOptions = &Bgp_PeerGroup_LoggingOptions{}
	return t.LoggingOptions
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateRouteReflector() *Bgp_PeerGroup_RouteReflector {
	if t.RouteReflector != nil {
		return t.RouteReflector
	}
	t.RouteReflector = &Bgp_PeerGroup_RouteReflector{}
	return t.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateTimers() *Bgp_PeerGroup_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &Bgp_PeerGroup_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateTransport() *Bgp_PeerGroup_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &Bgp_PeerGroup_Transport{}
	return t.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup) GetOrCreateUseMultiplePaths() *Bgp_PeerGroup_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_PeerGroup_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_PeerGroup. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetApplyPolicy() *Bgp_PeerGroup_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from Bgp_PeerGroup. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetAsPathOptions() *Bgp_PeerGroup_AsPathOptions {
	if t != nil && t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from Bgp_PeerGroup. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetEbgpMultihop() *Bgp_PeerGroup_EbgpMultihop {
	if t != nil && t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from Bgp_PeerGroup. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetErrorHandling() *Bgp_PeerGroup_ErrorHandling {
	if t != nil && t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_PeerGroup. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetGracefulRestart() *Bgp_PeerGroup_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from Bgp_PeerGroup. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetLoggingOptions() *Bgp_PeerGroup_LoggingOptions {
	if t != nil && t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from Bgp_PeerGroup. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetRouteReflector() *Bgp_PeerGroup_RouteReflector {
	if t != nil && t.RouteReflector != nil {
		return t.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from Bgp_PeerGroup. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetTimers() *Bgp_PeerGroup_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Bgp_PeerGroup. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetTransport() *Bgp_PeerGroup_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_PeerGroup. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup) GetUseMultiplePaths() *Bgp_PeerGroup_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_PeerGroup struct, which is a YANG list entry.
func (t *Bgp_PeerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerGroupName == nil {
		return nil, fmt.Errorf("nil value for key PeerGroupName")
	}

	return map[string]interface{}{
		"peer-group-name": *t.PeerGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateAddPaths() *Bgp_PeerGroup_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &Bgp_PeerGroup_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateApplyPolicy() *Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &Bgp_PeerGroup_AfiSafi_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateGracefulRestart() *Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &Bgp_PeerGroup_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &Bgp_PeerGroup_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &Bgp_PeerGroup_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &Bgp_PeerGroup_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &Bgp_PeerGroup_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetAddPaths() *Bgp_PeerGroup_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetApplyPolicy() *Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetGracefulRestart() *Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetIpv4LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetIpv4Unicast() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetIpv6LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetIpv6Unicast() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL2VpnEvpn() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL2VpnVpls() *Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv4() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv6() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi) GetUseMultiplePaths() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_PeerGroup_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_PeerGroup_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetIbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_EbgpMultihop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_ErrorHandling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_LoggingOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_RouteReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_UseMultiplePaths) GetOrCreateEbgp() *Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &Bgp_PeerGroup_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *Bgp_PeerGroup_UseMultiplePaths) GetOrCreateIbgp() *Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &Bgp_PeerGroup_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_UseMultiplePaths) GetEbgp() *Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Bgp_PeerGroup_UseMultiplePaths) GetIbgp() *Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewProperty creates a new entry in the Property list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewProperty(Name string) (*Component_Property, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Property[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Property", key)
	}

	t.Property[key] = &Component_Property{
		Name: &Name,
	}

	return t.Property[key], nil
}

// RenameProperty renames an entry in the list Property within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameProperty(oldK, newK string) error {
	if _, ok := t.Property[newK]; ok {
		return fmt.Errorf("key %v already exists in Property", newK)
	}

	e, ok := t.Property[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Property", oldK)
	}
	e.Name = &newK

	t.Property[newK] = e
	delete(t.Property, oldK)
	return nil
}

// GetOrCreateProperty retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateProperty(Name string) *Component_Property {

	key := Name

	if v, ok := t.Property[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProperty(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProperty got unexpected error: %v", err))
	}
	return v
}

// GetProperty retrieves the value with the specified key from
// the Property map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetProperty(Name string) *Component_Property {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Property[key]; ok {
		return lm
	}
	return nil
}

// DeleteProperty deletes the value with the specified keys from
// the receiver Component. If there is no such element, the function
// is a no-op.
func (t *Component) DeleteProperty(Name string) {
	key := Name

	delete(t.Property, key)
}

// AppendProperty appends the supplied Component_Property struct to the
// list Property of Component. If the key value(s) specified in
// the supplied Component_Property already exist in the list, an error is
// returned.
func (t *Component) AppendProperty(v *Component_Property) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	if _, ok := t.Property[key]; ok {
		return fmt.Errorf("duplicate key for list Property %v", key)
	}

	t.Property[key] = v
	return nil
}

// NewSubcomponent creates a new entry in the Subcomponent list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewSubcomponent(Name string) (*Component_Subcomponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subcomponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subcomponent", key)
	}

	t.Subcomponent[key] = &Component_Subcomponent{
		Name: &Name,
	}

	return t.Subcomponent[key], nil
}

// RenameSubcomponent renames an entry in the list Subcomponent within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameSubcomponent(oldK, newK string) error {
	if _, ok := t.Subcomponent[newK]; ok {
		return fmt.Errorf("key %v already exists in Subcomponent", newK)
	}

	e, ok := t.Subcomponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subcomponent", oldK)
	}
	e.Name = &newK

	t.Subcomponent[newK] = e
	delete(t.Subcomponent, oldK)
	return nil
}

// GetOrCreateSubcomponent retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateSubcomponent(Name string) *Component_Subcomponent {

	key := Name

	if v, ok := t.Subcomponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubcomponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubcomponent got unexpected error: %v", err))
	}
	return v
}

// GetSubcomponent retrieves the value with the specified key from
// the Subcomponent map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetSubcomponent(Name string) *Component_Subcomponent {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Subcomponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubcomponent deletes the value with the specified keys from
// the receiver Component. If there is no such element, the function
// is a no-op.
func (t *Component) DeleteSubcomponent(Name string) {
	key := Name

	delete(t.Subcomponent, key)
}

// AppendSubcomponent appends the supplied Component_Subcomponent struct to the
// list Subcomponent of Component. If the key value(s) specified in
// the supplied Component_Subcomponent already exist in the list, an error is
// returned.
func (t *Component) AppendSubcomponent(v *Component_Subcomponent) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	if _, ok := t.Subcomponent[key]; ok {
		return fmt.Errorf("duplicate key for list Subcomponent %v", key)
	}

	t.Subcomponent[key] = v
	return nil
}

// GetOrCreateBackplane retrieves the value of the Backplane field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateBackplane() *Component_Backplane {
	if t.Backplane != nil {
		return t.Backplane
	}
	t.Backplane = &Component_Backplane{}
	return t.Backplane
}

// GetOrCreateChassis retrieves the value of the Chassis field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateChassis() *Component_Chassis {
	if t.Chassis != nil {
		return t.Chassis
	}
	t.Chassis = &Component_Chassis{}
	return t.Chassis
}

// GetOrCreateCpu retrieves the value of the Cpu field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateCpu() *Component_Cpu {
	if t.Cpu != nil {
		return t.Cpu
	}
	t.Cpu = &Component_Cpu{}
	return t.Cpu
}

// GetOrCreateFabric retrieves the value of the Fabric field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateFabric() *Component_Fabric {
	if t.Fabric != nil {
		return t.Fabric
	}
	t.Fabric = &Component_Fabric{}
	return t.Fabric
}

// GetOrCreateFan retrieves the value of the Fan field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateFan() *Component_Fan {
	if t.Fan != nil {
		return t.Fan
	}
	t.Fan = &Component_Fan{}
	return t.Fan
}

// GetOrCreateIntegratedCircuit retrieves the value of the IntegratedCircuit field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateIntegratedCircuit() *Component_IntegratedCircuit {
	if t.IntegratedCircuit != nil {
		return t.IntegratedCircuit
	}
	t.IntegratedCircuit = &Component_IntegratedCircuit{}
	return t.IntegratedCircuit
}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateMemory() *Component_Memory {
	if t.Memory != nil {
		return t.Memory
	}
	t.Memory = &Component_Memory{}
	return t.Memory
}

// GetOrCreateOpticalChannel retrieves the value of the OpticalChannel field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateOpticalChannel() *Component_OpticalChannel {
	if t.OpticalChannel != nil {
		return t.OpticalChannel
	}
	t.OpticalChannel = &Component_OpticalChannel{}
	return t.OpticalChannel
}

// GetOrCreateOpticalPort retrieves the value of the OpticalPort field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateOpticalPort() *Component_OpticalPort {
	if t.OpticalPort != nil {
		return t.OpticalPort
	}
	t.OpticalPort = &Component_OpticalPort{}
	return t.OpticalPort
}

// GetOrCreatePort retrieves the value of the Port field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreatePort() *Component_Port {
	if t.Port != nil {
		return t.Port
	}
	t.Port = &Component_Port{}
	return t.Port
}

// GetOrCreatePowerSupply retrieves the value of the PowerSupply field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreatePowerSupply() *Component_PowerSupply {
	if t.PowerSupply != nil {
		return t.PowerSupply
	}
	t.PowerSupply = &Component_PowerSupply{}
	return t.PowerSupply
}

// GetOrCreateStorage retrieves the value of the Storage field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateStorage() *Component_Storage {
	if t.Storage != nil {
		return t.Storage
	}
	t.Storage = &Component_Storage{}
	return t.Storage
}

// GetOrCreateTemperature retrieves the value of the Temperature field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateTemperature() *Component_Temperature {
	if t.Temperature != nil {
		return t.Temperature
	}
	t.Temperature = &Component_Temperature{}
	return t.Temperature
}

// GetOrCreateTransceiver retrieves the value of the Transceiver field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateTransceiver() *Component_Transceiver {
	if t.Transceiver != nil {
		return t.Transceiver
	}
	t.Transceiver = &Component_Transceiver{}
	return t.Transceiver
}

// GetBackplane returns the value of the Backplane struct pointer
// from Component. If the receiver or the field Backplane is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetBackplane() *Component_Backplane {
	if t != nil && t.Backplane != nil {
		return t.Backplane
	}
	return nil
}

// GetChassis returns the value of the Chassis struct pointer
// from Component. If the receiver or the field Chassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetChassis() *Component_Chassis {
	if t != nil && t.Chassis != nil {
		return t.Chassis
	}
	return nil
}

// GetCpu returns the value of the Cpu struct pointer
// from Component. If the receiver or the field Cpu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetCpu() *Component_Cpu {
	if t != nil && t.Cpu != nil {
		return t.Cpu
	}
	return nil
}

// GetFabric returns the value of the Fabric struct pointer
// from Component. If the receiver or the field Fabric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetFabric() *Component_Fabric {
	if t != nil && t.Fabric != nil {
		return t.Fabric
	}
	return nil
}

// GetFan returns the value of the Fan struct pointer
// from Component. If the receiver or the field Fan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetFan() *Component_Fan {
	if t != nil && t.Fan != nil {
		return t.Fan
	}
	return nil
}

// GetIntegratedCircuit returns the value of the IntegratedCircuit struct pointer
// from Component. If the receiver or the field IntegratedCircuit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetIntegratedCircuit() *Component_IntegratedCircuit {
	if t != nil && t.IntegratedCircuit != nil {
		return t.IntegratedCircuit
	}
	return nil
}

// GetMemory returns the value of the Memory struct pointer
// from Component. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetMemory() *Component_Memory {
	if t != nil && t.Memory != nil {
		return t.Memory
	}
	return nil
}

// GetOpticalChannel returns the value of the OpticalChannel struct pointer
// from Component. If the receiver or the field OpticalChannel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetOpticalChannel() *Component_OpticalChannel {
	if t != nil && t.OpticalChannel != nil {
		return t.OpticalChannel
	}
	return nil
}

// GetOpticalPort returns the value of the OpticalPort struct pointer
// from Component. If the receiver or the field OpticalPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetOpticalPort() *Component_OpticalPort {
	if t != nil && t.OpticalPort != nil {
		return t.OpticalPort
	}
	return nil
}

// GetPort returns the value of the Port struct pointer
// from Component. If the receiver or the field Port is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetPort() *Component_Port {
	if t != nil && t.Port != nil {
		return t.Port
	}
	return nil
}

// GetPowerSupply returns the value of the PowerSupply struct pointer
// from Component. If the receiver or the field PowerSupply is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetPowerSupply() *Component_PowerSupply {
	if t != nil && t.PowerSupply != nil {
		return t.PowerSupply
	}
	return nil
}

// GetStorage returns the value of the Storage struct pointer
// from Component. If the receiver or the field Storage is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetStorage() *Component_Storage {
	if t != nil && t.Storage != nil {
		return t.Storage
	}
	return nil
}

// GetTemperature returns the value of the Temperature struct pointer
// from Component. If the receiver or the field Temperature is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetTemperature() *Component_Temperature {
	if t != nil && t.Temperature != nil {
		return t.Temperature
	}
	return nil
}

// GetTransceiver returns the value of the Transceiver struct pointer
// from Component. If the receiver or the field Transceiver is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetTransceiver() *Component_Transceiver {
	if t != nil && t.Transceiver != nil {
		return t.Transceiver
	}
	return nil
}

// ΛListKeyMap returns the keys of the Component struct, which is a YANG list entry.
func (t *Component) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Backplane) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Backplane"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Backplane) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Chassis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Cpu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Cpu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fabric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fabric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_IntegratedCircuit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_IntegratedCircuit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Memory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Memory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateChromaticDispersion retrieves the value of the ChromaticDispersion field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreateChromaticDispersion() *Component_OpticalChannel_ChromaticDispersion {
	if t.ChromaticDispersion != nil {
		return t.ChromaticDispersion
	}
	t.ChromaticDispersion = &Component_OpticalChannel_ChromaticDispersion{}
	return t.ChromaticDispersion
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreateInputPower() *Component_OpticalChannel_InputPower {
	if t.InputPower != nil {
		return t.InputPower
	}
	t.InputPower = &Component_OpticalChannel_InputPower{}
	return t.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreateLaserBiasCurrent() *Component_OpticalChannel_LaserBiasCurrent {
	if t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	t.LaserBiasCurrent = &Component_OpticalChannel_LaserBiasCurrent{}
	return t.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreateOutputPower() *Component_OpticalChannel_OutputPower {
	if t.OutputPower != nil {
		return t.OutputPower
	}
	t.OutputPower = &Component_OpticalChannel_OutputPower{}
	return t.OutputPower
}

// GetOrCreatePolarizationDependentLoss retrieves the value of the PolarizationDependentLoss field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreatePolarizationDependentLoss() *Component_OpticalChannel_PolarizationDependentLoss {
	if t.PolarizationDependentLoss != nil {
		return t.PolarizationDependentLoss
	}
	t.PolarizationDependentLoss = &Component_OpticalChannel_PolarizationDependentLoss{}
	return t.PolarizationDependentLoss
}

// GetOrCreatePolarizationModeDispersion retrieves the value of the PolarizationModeDispersion field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreatePolarizationModeDispersion() *Component_OpticalChannel_PolarizationModeDispersion {
	if t.PolarizationModeDispersion != nil {
		return t.PolarizationModeDispersion
	}
	t.PolarizationModeDispersion = &Component_OpticalChannel_PolarizationModeDispersion{}
	return t.PolarizationModeDispersion
}

// GetOrCreateSecondOrderPolarizationModeDispersion retrieves the value of the SecondOrderPolarizationModeDispersion field
// or returns the existing field if it already exists.
func (t *Component_OpticalChannel) GetOrCreateSecondOrderPolarizationModeDispersion() *Component_OpticalChannel_SecondOrderPolarizationModeDispersion {
	if t.SecondOrderPolarizationModeDispersion != nil {
		return t.SecondOrderPolarizationModeDispersion
	}
	t.SecondOrderPolarizationModeDispersion = &Component_OpticalChannel_SecondOrderPolarizationModeDispersion{}
	return t.SecondOrderPolarizationModeDispersion
}

// GetChromaticDispersion returns the value of the ChromaticDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field ChromaticDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetChromaticDispersion() *Component_OpticalChannel_ChromaticDispersion {
	if t != nil && t.ChromaticDispersion != nil {
		return t.ChromaticDispersion
	}
	return nil
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_OpticalChannel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetInputPower() *Component_OpticalChannel_InputPower {
	if t != nil && t.InputPower != nil {
		return t.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_OpticalChannel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetLaserBiasCurrent() *Component_OpticalChannel_LaserBiasCurrent {
	if t != nil && t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_OpticalChannel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetOutputPower() *Component_OpticalChannel_OutputPower {
	if t != nil && t.OutputPower != nil {
		return t.OutputPower
	}
	return nil
}

// GetPolarizationDependentLoss returns the value of the PolarizationDependentLoss struct pointer
// from Component_OpticalChannel. If the receiver or the field PolarizationDependentLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetPolarizationDependentLoss() *Component_OpticalChannel_PolarizationDependentLoss {
	if t != nil && t.PolarizationDependentLoss != nil {
		return t.PolarizationDependentLoss
	}
	return nil
}

// GetPolarizationModeDispersion returns the value of the PolarizationModeDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field PolarizationModeDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetPolarizationModeDispersion() *Component_OpticalChannel_PolarizationModeDispersion {
	if t != nil && t.PolarizationModeDispersion != nil {
		return t.PolarizationModeDispersion
	}
	return nil
}

// GetSecondOrderPolarizationModeDispersion returns the value of the SecondOrderPolarizationModeDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field SecondOrderPolarizationModeDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalChannel) GetSecondOrderPolarizationModeDispersion() *Component_OpticalChannel_SecondOrderPolarizationModeDispersion {
	if t != nil && t.SecondOrderPolarizationModeDispersion != nil {
		return t.SecondOrderPolarizationModeDispersion
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_ChromaticDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_ChromaticDispersion"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_ChromaticDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_PolarizationDependentLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_PolarizationDependentLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_PolarizationDependentLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_PolarizationModeDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_PolarizationModeDispersion"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_PolarizationModeDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalChannel_SecondOrderPolarizationModeDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_SecondOrderPolarizationModeDispersion"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_SecondOrderPolarizationModeDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (t *Component_OpticalPort) GetOrCreateInputPower() *Component_OpticalPort_InputPower {
	if t.InputPower != nil {
		return t.InputPower
	}
	t.InputPower = &Component_OpticalPort_InputPower{}
	return t.InputPower
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (t *Component_OpticalPort) GetOrCreateOutputPower() *Component_OpticalPort_OutputPower {
	if t.OutputPower != nil {
		return t.OutputPower
	}
	t.OutputPower = &Component_OpticalPort_OutputPower{}
	return t.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_OpticalPort. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalPort) GetInputPower() *Component_OpticalPort_InputPower {
	if t != nil && t.InputPower != nil {
		return t.InputPower
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_OpticalPort. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_OpticalPort) GetOutputPower() *Component_OpticalPort_OutputPower {
	if t != nil && t.OutputPower != nil {
		return t.OutputPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalPort_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_OpticalPort_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateBreakoutMode retrieves the value of the BreakoutMode field
// or returns the existing field if it already exists.
func (t *Component_Port) GetOrCreateBreakoutMode() *Component_Port_BreakoutMode {
	if t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	t.BreakoutMode = &Component_Port_BreakoutMode{}
	return t.BreakoutMode
}

// GetBreakoutMode returns the value of the BreakoutMode struct pointer
// from Component_Port. If the receiver or the field BreakoutMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Port) GetBreakoutMode() *Component_Port_BreakoutMode {
	if t != nil && t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port_BreakoutMode) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port_BreakoutMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port_BreakoutMode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_PowerSupply) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_PowerSupply"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_PowerSupply) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Component_Property struct, which is a YANG list entry.
func (t *Component_Property) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Property) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Property"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Property) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Storage) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Storage"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Storage) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Component_Subcomponent struct, which is a YANG list entry.
func (t *Component_Subcomponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Subcomponent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Subcomponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Subcomponent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewChannel creates a new entry in the Channel list of the
// Component_Transceiver struct. The keys of the list are populated from the input
// arguments.
func (t *Component_Transceiver) NewChannel(Index uint16) (*Component_Transceiver_Channel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint16]*Component_Transceiver_Channel)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Channel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Channel", key)
	}

	t.Channel[key] = &Component_Transceiver_Channel{
		Index: &Index,
	}

	return t.Channel[key], nil
}

// RenameChannel renames an entry in the list Channel within
// the Component_Transceiver struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component_Transceiver) RenameChannel(oldK, newK uint16) error {
	if _, ok := t.Channel[newK]; ok {
		return fmt.Errorf("key %v already exists in Channel", newK)
	}

	e, ok := t.Channel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Channel", oldK)
	}
	e.Index = &newK

	t.Channel[newK] = e
	delete(t.Channel, oldK)
	return nil
}

// GetOrCreateChannel retrieves the value with the specified keys from
// the receiver Component_Transceiver. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component_Transceiver) GetOrCreateChannel(Index uint16) *Component_Transceiver_Channel {

	key := Index

	if v, ok := t.Channel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChannel(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChannel got unexpected error: %v", err))
	}
	return v
}

// GetChannel retrieves the value with the specified key from
// the Channel map field of Component_Transceiver. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component_Transceiver) GetChannel(Index uint16) *Component_Transceiver_Channel {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Channel[key]; ok {
		return lm
	}
	return nil
}

// DeleteChannel deletes the value with the specified keys from
// the receiver Component_Transceiver. If there is no such element, the function
// is a no-op.
func (t *Component_Transceiver) DeleteChannel(Index uint16) {
	key := Index

	delete(t.Channel, key)
}

// AppendChannel appends the supplied Component_Transceiver_Channel struct to the
// list Channel of Component_Transceiver. If the key value(s) specified in
// the supplied Component_Transceiver_Channel already exist in the list, an error is
// returned.
func (t *Component_Transceiver) AppendChannel(v *Component_Transceiver_Channel) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint16]*Component_Transceiver_Channel)
	}

	if _, ok := t.Channel[key]; ok {
		return fmt.Errorf("duplicate key for list Channel %v", key)
	}

	t.Channel[key] = v
	return nil
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (t *Component_Transceiver) GetOrCreateInputPower() *Component_Transceiver_InputPower {
	if t.InputPower != nil {
		return t.InputPower
	}
	t.InputPower = &Component_Transceiver_InputPower{}
	return t.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (t *Component_Transceiver) GetOrCreateLaserBiasCurrent() *Component_Transceiver_LaserBiasCurrent {
	if t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	t.LaserBiasCurrent = &Component_Transceiver_LaserBiasCurrent{}
	return t.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (t *Component_Transceiver) GetOrCreateOutputPower() *Component_Transceiver_OutputPower {
	if t.OutputPower != nil {
		return t.OutputPower
	}
	t.OutputPower = &Component_Transceiver_OutputPower{}
	return t.OutputPower
}

// GetOrCreatePostFecBer retrieves the value of the PostFecBer field
// or returns the existing field if it already exists.
func (t *Component_Transceiver) GetOrCreatePostFecBer() *Component_Transceiver_PostFecBer {
	if t.PostFecBer != nil {
		return t.PostFecBer
	}
	t.PostFecBer = &Component_Transceiver_PostFecBer{}
	return t.PostFecBer
}

// GetOrCreatePreFecBer retrieves the value of the PreFecBer field
// or returns the existing field if it already exists.
func (t *Component_Transceiver) GetOrCreatePreFecBer() *Component_Transceiver_PreFecBer {
	if t.PreFecBer != nil {
		return t.PreFecBer
	}
	t.PreFecBer = &Component_Transceiver_PreFecBer{}
	return t.PreFecBer
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_Transceiver. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver) GetInputPower() *Component_Transceiver_InputPower {
	if t != nil && t.InputPower != nil {
		return t.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_Transceiver. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver) GetLaserBiasCurrent() *Component_Transceiver_LaserBiasCurrent {
	if t != nil && t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_Transceiver. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver) GetOutputPower() *Component_Transceiver_OutputPower {
	if t != nil && t.OutputPower != nil {
		return t.OutputPower
	}
	return nil
}

// GetPostFecBer returns the value of the PostFecBer struct pointer
// from Component_Transceiver. If the receiver or the field PostFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver) GetPostFecBer() *Component_Transceiver_PostFecBer {
	if t != nil && t.PostFecBer != nil {
		return t.PostFecBer
	}
	return nil
}

// GetPreFecBer returns the value of the PreFecBer struct pointer
// from Component_Transceiver. If the receiver or the field PreFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver) GetPreFecBer() *Component_Transceiver_PreFecBer {
	if t != nil && t.PreFecBer != nil {
		return t.PreFecBer
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (t *Component_Transceiver_Channel) GetOrCreateInputPower() *Component_Transceiver_Channel_InputPower {
	if t.InputPower != nil {
		return t.InputPower
	}
	t.InputPower = &Component_Transceiver_Channel_InputPower{}
	return t.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (t *Component_Transceiver_Channel) GetOrCreateLaserBiasCurrent() *Component_Transceiver_Channel_LaserBiasCurrent {
	if t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	t.LaserBiasCurrent = &Component_Transceiver_Channel_LaserBiasCurrent{}
	return t.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (t *Component_Transceiver_Channel) GetOrCreateOutputPower() *Component_Transceiver_Channel_OutputPower {
	if t.OutputPower != nil {
		return t.OutputPower
	}
	t.OutputPower = &Component_Transceiver_Channel_OutputPower{}
	return t.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_Transceiver_Channel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver_Channel) GetInputPower() *Component_Transceiver_Channel_InputPower {
	if t != nil && t.InputPower != nil {
		return t.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_Transceiver_Channel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver_Channel) GetLaserBiasCurrent() *Component_Transceiver_Channel_LaserBiasCurrent {
	if t != nil && t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_Transceiver_Channel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Transceiver_Channel) GetOutputPower() *Component_Transceiver_Channel_OutputPower {
	if t != nil && t.OutputPower != nil {
		return t.OutputPower
	}
	return nil
}

// ΛListKeyMap returns the keys of the Component_Transceiver_Channel struct, which is a YANG list entry.
func (t *Component_Transceiver_Channel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_Channel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_Channel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_Channel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_Channel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_PostFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_PostFecBer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_PostFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Transceiver_PreFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_PreFecBer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_PreFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewComponent creates a new entry in the Component list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewComponent(Name string) (*Component, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Component[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Component", key)
	}

	t.Component[key] = &Component{
		Name: &Name,
	}

	return t.Component[key], nil
}

// RenameComponent renames an entry in the list Component within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameComponent(oldK, newK string) error {
	if _, ok := t.Component[newK]; ok {
		return fmt.Errorf("key %v already exists in Component", newK)
	}

	e, ok := t.Component[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Component", oldK)
	}
	e.Name = &newK

	t.Component[newK] = e
	delete(t.Component, oldK)
	return nil
}

// GetOrCreateComponent retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateComponent(Name string) *Component {

	key := Name

	if v, ok := t.Component[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewComponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateComponent got unexpected error: %v", err))
	}
	return v
}

// GetComponent retrieves the value with the specified key from
// the Component map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetComponent(Name string) *Component {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Component[key]; ok {
		return lm
	}
	return nil
}

// DeleteComponent deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteComponent(Name string) {
	key := Name

	delete(t.Component, key)
}

// AppendComponent appends the supplied Component struct to the
// list Component of Device. If the key value(s) specified in
// the supplied Component already exist in the list, an error is
// returned.
func (t *Device) AppendComponent(v *Component) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	if _, ok := t.Component[key]; ok {
		return fmt.Errorf("duplicate key for list Component %v", key)
	}

	t.Component[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewNetworkInstance(Name string) (*NetworkInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateNetworkInstance(Name string) *NetworkInstance {

	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetNetworkInstance(Name string) *NetworkInstance {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied NetworkInstance struct to the
// list NetworkInstance of Device. If the key value(s) specified in
// the supplied NetworkInstance already exist in the list, an error is
// returned.
func (t *Device) AppendNetworkInstance(v *NetworkInstance) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateAcl() *Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &Acl{}
	return t.Acl
}

// GetOrCreateAps retrieves the value of the Aps field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateAps() *Aps {
	if t.Aps != nil {
		return t.Aps
	}
	t.Aps = &Aps{}
	return t.Aps
}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateBgp() *Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &Bgp{}
	return t.Bgp
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLacp() *Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &Lacp{}
	return t.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLldp() *Lldp {
	if t.Lldp != nil {
		return t.Lldp
	}
	t.Lldp = &Lldp{}
	return t.Lldp
}

// GetOrCreateLocalRoutes retrieves the value of the LocalRoutes field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLocalRoutes() *LocalRoutes {
	if t.LocalRoutes != nil {
		return t.LocalRoutes
	}
	t.LocalRoutes = &LocalRoutes{}
	return t.LocalRoutes
}

// GetOrCreateOpticalAmplifier retrieves the value of the OpticalAmplifier field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateOpticalAmplifier() *OpticalAmplifier {
	if t.OpticalAmplifier != nil {
		return t.OpticalAmplifier
	}
	t.OpticalAmplifier = &OpticalAmplifier{}
	return t.OpticalAmplifier
}

// GetOrCreateRoutingPolicy retrieves the value of the RoutingPolicy field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateRoutingPolicy() *RoutingPolicy {
	if t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	t.RoutingPolicy = &RoutingPolicy{}
	return t.RoutingPolicy
}

// GetOrCreateStp retrieves the value of the Stp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateStp() *Stp {
	if t.Stp != nil {
		return t.Stp
	}
	t.Stp = &Stp{}
	return t.Stp
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystem() *System {
	if t.System != nil {
		return t.System
	}
	t.System = &System{}
	return t.System
}

// GetOrCreateTerminalDevice retrieves the value of the TerminalDevice field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateTerminalDevice() *TerminalDevice {
	if t.TerminalDevice != nil {
		return t.TerminalDevice
	}
	t.TerminalDevice = &TerminalDevice{}
	return t.TerminalDevice
}

// GetAcl returns the value of the Acl struct pointer
// from Device. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetAcl() *Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetAps returns the value of the Aps struct pointer
// from Device. If the receiver or the field Aps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetAps() *Aps {
	if t != nil && t.Aps != nil {
		return t.Aps
	}
	return nil
}

// GetBgp returns the value of the Bgp struct pointer
// from Device. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetBgp() *Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from Device. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLacp() *Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from Device. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLldp() *Lldp {
	if t != nil && t.Lldp != nil {
		return t.Lldp
	}
	return nil
}

// GetLocalRoutes returns the value of the LocalRoutes struct pointer
// from Device. If the receiver or the field LocalRoutes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLocalRoutes() *LocalRoutes {
	if t != nil && t.LocalRoutes != nil {
		return t.LocalRoutes
	}
	return nil
}

// GetOpticalAmplifier returns the value of the OpticalAmplifier struct pointer
// from Device. If the receiver or the field OpticalAmplifier is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetOpticalAmplifier() *OpticalAmplifier {
	if t != nil && t.OpticalAmplifier != nil {
		return t.OpticalAmplifier
	}
	return nil
}

// GetRoutingPolicy returns the value of the RoutingPolicy struct pointer
// from Device. If the receiver or the field RoutingPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetRoutingPolicy() *RoutingPolicy {
	if t != nil && t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	return nil
}

// GetStp returns the value of the Stp struct pointer
// from Device. If the receiver or the field Stp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetStp() *Stp {
	if t != nil && t.Stp != nil {
		return t.Stp
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystem() *System {
	if t != nil && t.System != nil {
		return t.System
	}
	return nil
}

// GetTerminalDevice returns the value of the TerminalDevice struct pointer
// from Device. If the receiver or the field TerminalDevice is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetTerminalDevice() *TerminalDevice {
	if t != nil && t.TerminalDevice != nil {
		return t.TerminalDevice
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewSubinterface creates a new entry in the Subinterface list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewSubinterface(Index uint32) (*Interface_Subinterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateSubinterface(Index uint32) *Interface_Subinterface {

	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetSubinterface(Index uint32) *Interface_Subinterface {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver Interface. If there is no such element, the function
// is a no-op.
func (t *Interface) DeleteSubinterface(Index uint32) {
	key := Index

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied Interface_Subinterface struct to the
// list Subinterface of Interface. If the key value(s) specified in
// the supplied Interface_Subinterface already exist in the list, an error is
// returned.
func (t *Interface) AppendSubinterface(v *Interface_Subinterface) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateAggregation retrieves the value of the Aggregation field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateAggregation() *Interface_Aggregation {
	if t.Aggregation != nil {
		return t.Aggregation
	}
	t.Aggregation = &Interface_Aggregation{}
	return t.Aggregation
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateCounters() *Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Counters{}
	return t.Counters
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateEthernet() *Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateHoldTime() *Interface_HoldTime {
	if t.HoldTime != nil {
		return t.HoldTime
	}
	t.HoldTime = &Interface_HoldTime{}
	return t.HoldTime
}

// GetOrCreateRoutedVlan retrieves the value of the RoutedVlan field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateRoutedVlan() *Interface_RoutedVlan {
	if t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	t.RoutedVlan = &Interface_RoutedVlan{}
	return t.RoutedVlan
}

// GetOrCreateSonet retrieves the value of the Sonet field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateSonet() *Interface_Sonet {
	if t.Sonet != nil {
		return t.Sonet
	}
	t.Sonet = &Interface_Sonet{}
	return t.Sonet
}

// GetAggregation returns the value of the Aggregation struct pointer
// from Interface. If the receiver or the field Aggregation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetAggregation() *Interface_Aggregation {
	if t != nil && t.Aggregation != nil {
		return t.Aggregation
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetCounters() *Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetEthernet() *Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from Interface. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetHoldTime() *Interface_HoldTime {
	if t != nil && t.HoldTime != nil {
		return t.HoldTime
	}
	return nil
}

// GetRoutedVlan returns the value of the RoutedVlan struct pointer
// from Interface. If the receiver or the field RoutedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetRoutedVlan() *Interface_RoutedVlan {
	if t != nil && t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	return nil
}

// GetSonet returns the value of the Sonet struct pointer
// from Interface. If the receiver or the field Sonet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetSonet() *Interface_Sonet {
	if t != nil && t.Sonet != nil {
		return t.Sonet
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Aggregation) GetOrCreateSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Aggregation_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Aggregation. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Aggregation) GetSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateCounters() *Interface_Ethernet_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Ethernet_Counters{}
	return t.Counters
}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Ethernet_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Ethernet. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetCounters() *Interface_Ethernet_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Ethernet. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_HoldTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv4() *Interface_RoutedVlan_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_RoutedVlan_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv6() *Interface_RoutedVlan_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_RoutedVlan_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv4() *Interface_RoutedVlan_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv6() *Interface_RoutedVlan_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv4_Address struct to the
// list Address of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendAddress(v *Interface_RoutedVlan_Ipv4_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv4_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendNeighbor(v *Interface_RoutedVlan_Ipv4_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_RoutedVlan_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv6_Address struct to the
// list Address of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendAddress(v *Interface_RoutedVlan_Ipv6_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv6_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendNeighbor(v *Interface_RoutedVlan_Ipv6_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_RoutedVlan_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Sonet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Sonet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Sonet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateCounters() *Interface_Subinterface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Counters{}
	return t.Counters
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv4() *Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv6() *Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateVlan() *Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetCounters() *Interface_Subinterface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv4() *Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv6() *Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetVlan() *Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface struct, which is a YANG list entry.
func (t *Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewAddress(Ip string) (*Interface_Subinterface_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv4_Address struct to the
// list Address of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendAddress(v *Interface_Subinterface_Ipv4_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendNeighbor(v *Interface_Subinterface_Ipv4_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateCounters() *Interface_Subinterface_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_Subinterface_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetCounters() *Interface_Subinterface_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv4_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewAddress(Ip string) (*Interface_Subinterface_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv6_Address struct to the
// list Address of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendAddress(v *Interface_Subinterface_Ipv6_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendNeighbor(v *Interface_Subinterface_Ipv6_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateAutoconf retrieves the value of the Autoconf field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t.Autoconf != nil {
		return t.Autoconf
	}
	t.Autoconf = &Interface_Subinterface_Ipv6_Autoconf{}
	return t.Autoconf
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateCounters() *Interface_Subinterface_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetAutoconf returns the value of the Autoconf struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Autoconf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t != nil && t.Autoconf != nil {
		return t.Autoconf
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetCounters() *Interface_Subinterface_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv6_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Autoconf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// DeleteMember deletes the value with the specified keys from
// the receiver Lacp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lacp_Interface) DeleteMember(Interface string) {
	key := Interface

	delete(t.Member, key)
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_Interface_Member_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lldp. If there is no such element, the function
// is a no-op.
func (t *Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp) GetCounters() *Lldp_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Lldp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface) DeleteNeighbor(Id string) {
	key := Id

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) {
	key := Name

	delete(t.Capability, key)
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteTlv(Type int32, Oui string, OuiSubtype string) {
	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	key := Lldp_Interface_Neighbor_Tlv_Key{Type: *v.Type, Oui: *v.Oui, OuiSubtype: *v.OuiSubtype}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAggregate creates a new entry in the Aggregate list of the
// LocalRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes) NewAggregate(Prefix string) (*LocalRoutes_Aggregate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*LocalRoutes_Aggregate)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aggregate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aggregate", key)
	}

	t.Aggregate[key] = &LocalRoutes_Aggregate{
		Prefix: &Prefix,
	}

	return t.Aggregate[key], nil
}

// RenameAggregate renames an entry in the list Aggregate within
// the LocalRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes) RenameAggregate(oldK, newK string) error {
	if _, ok := t.Aggregate[newK]; ok {
		return fmt.Errorf("key %v already exists in Aggregate", newK)
	}

	e, ok := t.Aggregate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aggregate", oldK)
	}
	e.Prefix = &newK

	t.Aggregate[newK] = e
	delete(t.Aggregate, oldK)
	return nil
}

// GetOrCreateAggregate retrieves the value with the specified keys from
// the receiver LocalRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes) GetOrCreateAggregate(Prefix string) *LocalRoutes_Aggregate {

	key := Prefix

	if v, ok := t.Aggregate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregate(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregate got unexpected error: %v", err))
	}
	return v
}

// GetAggregate retrieves the value with the specified key from
// the Aggregate map field of LocalRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes) GetAggregate(Prefix string) *LocalRoutes_Aggregate {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Aggregate[key]; ok {
		return lm
	}
	return nil
}

// DeleteAggregate deletes the value with the specified keys from
// the receiver LocalRoutes. If there is no such element, the function
// is a no-op.
func (t *LocalRoutes) DeleteAggregate(Prefix string) {
	key := Prefix

	delete(t.Aggregate, key)
}

// AppendAggregate appends the supplied LocalRoutes_Aggregate struct to the
// list Aggregate of LocalRoutes. If the key value(s) specified in
// the supplied LocalRoutes_Aggregate already exist in the list, an error is
// returned.
func (t *LocalRoutes) AppendAggregate(v *LocalRoutes_Aggregate) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*LocalRoutes_Aggregate)
	}

	if _, ok := t.Aggregate[key]; ok {
		return fmt.Errorf("duplicate key for list Aggregate %v", key)
	}

	t.Aggregate[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// LocalRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes) NewStatic(Prefix string) (*LocalRoutes_Static, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*LocalRoutes_Static)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &LocalRoutes_Static{
		Prefix: &Prefix,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the LocalRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Prefix = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver LocalRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes) GetOrCreateStatic(Prefix string) *LocalRoutes_Static {

	key := Prefix

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of LocalRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes) GetStatic(Prefix string) *LocalRoutes_Static {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatic deletes the value with the specified keys from
// the receiver LocalRoutes. If there is no such element, the function
// is a no-op.
func (t *LocalRoutes) DeleteStatic(Prefix string) {
	key := Prefix

	delete(t.Static, key)
}

// AppendStatic appends the supplied LocalRoutes_Static struct to the
// list Static of LocalRoutes. If the key value(s) specified in
// the supplied LocalRoutes_Static already exist in the list, an error is
// returned.
func (t *LocalRoutes) AppendStatic(v *LocalRoutes_Static) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*LocalRoutes_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *LocalRoutes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the LocalRoutes_Aggregate struct, which is a YANG list entry.
func (t *LocalRoutes_Aggregate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *LocalRoutes_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Aggregate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNextHop creates a new entry in the NextHop list of the
// LocalRoutes_Static struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes_Static) NewNextHop(Index string) (*LocalRoutes_Static_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*LocalRoutes_Static_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &LocalRoutes_Static_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the LocalRoutes_Static struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes_Static) RenameNextHop(oldK, newK string) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver LocalRoutes_Static. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes_Static) GetOrCreateNextHop(Index string) *LocalRoutes_Static_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of LocalRoutes_Static. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes_Static) GetNextHop(Index string) *LocalRoutes_Static_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver LocalRoutes_Static. If there is no such element, the function
// is a no-op.
func (t *LocalRoutes_Static) DeleteNextHop(Index string) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied LocalRoutes_Static_NextHop struct to the
// list NextHop of LocalRoutes_Static. If the key value(s) specified in
// the supplied LocalRoutes_Static_NextHop already exist in the list, an error is
// returned.
func (t *LocalRoutes_Static) AppendNextHop(v *LocalRoutes_Static_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*LocalRoutes_Static_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the LocalRoutes_Static struct, which is a YANG list entry.
func (t *LocalRoutes_Static) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *LocalRoutes_Static) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *LocalRoutes_Static_NextHop) GetOrCreateInterfaceRef() *LocalRoutes_Static_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &LocalRoutes_Static_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from LocalRoutes_Static_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *LocalRoutes_Static_NextHop) GetInterfaceRef() *LocalRoutes_Static_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the LocalRoutes_Static_NextHop struct, which is a YANG list entry.
func (t *LocalRoutes_Static_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *LocalRoutes_Static_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *LocalRoutes_Static_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteConnectionPoint(ConnectionPointId string) {
	key := ConnectionPointId

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) {
	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	key := NetworkInstance_Protocol_Key{Identifier: v.Identifier, Name: *v.Name}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewRouteLimit creates a new entry in the RouteLimit list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewRouteLimit(Afi E_OpenconfigTypes_ADDRESS_FAMILY) (*NetworkInstance_RouteLimit, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_OpenconfigTypes_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	key := Afi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RouteLimit[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RouteLimit", key)
	}

	t.RouteLimit[key] = &NetworkInstance_RouteLimit{
		Afi: Afi,
	}

	return t.RouteLimit[key], nil
}

// RenameRouteLimit renames an entry in the list RouteLimit within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameRouteLimit(oldK, newK E_OpenconfigTypes_ADDRESS_FAMILY) error {
	if _, ok := t.RouteLimit[newK]; ok {
		return fmt.Errorf("key %v already exists in RouteLimit", newK)
	}

	e, ok := t.RouteLimit[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RouteLimit", oldK)
	}
	e.Afi = newK

	t.RouteLimit[newK] = e
	delete(t.RouteLimit, oldK)
	return nil
}

// GetOrCreateRouteLimit retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateRouteLimit(Afi E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	key := Afi

	if v, ok := t.RouteLimit[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRouteLimit(Afi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRouteLimit got unexpected error: %v", err))
	}
	return v
}

// GetRouteLimit retrieves the value with the specified key from
// the RouteLimit map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetRouteLimit(Afi E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	if t == nil {
		return nil
	}

	key := Afi

	if lm, ok := t.RouteLimit[key]; ok {
		return lm
	}
	return nil
}

// DeleteRouteLimit deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteRouteLimit(Afi E_OpenconfigTypes_ADDRESS_FAMILY) {
	key := Afi

	delete(t.RouteLimit, key)
}

// AppendRouteLimit appends the supplied NetworkInstance_RouteLimit struct to the
// list RouteLimit of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_RouteLimit already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendRouteLimit(v *NetworkInstance_RouteLimit) error {
	key := v.Afi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_OpenconfigTypes_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	if _, ok := t.RouteLimit[key]; ok {
		return fmt.Errorf("duplicate key for list RouteLimit %v", key)
	}

	t.RouteLimit[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// DeleteTable deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) {
	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	delete(t.Table, key)
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{Protocol: v.Protocol, AddressFamily: v.AddressFamily}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteTableConnection deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	delete(t.TableConnection, key)
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{SrcProtocol: v.SrcProtocol, DstProtocol: v.DstProtocol, AddressFamily: v.AddressFamily}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if t.Afts != nil {
		return t.Afts
	}
	t.Afts = &NetworkInstance_Afts{}
	return t.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &NetworkInstance_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if t.Fdb != nil {
		return t.Fdb
	}
	t.Fdb = &NetworkInstance_Fdb{}
	return t.Fdb
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if t != nil && t.Afts != nil {
		return t.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if t != nil && t.Fdb != nil {
		return t.Fdb
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv4Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv4Entry, key)
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv6Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv6Entry, key)
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteLabelEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) {
	key := Label

	delete(t.LabelEntry, key)
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteMacEntry(MacAddress string) {
	key := MacAddress

	delete(t.MacEntry, key)
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHop struct to the
// list NextHop of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHop(v *NetworkInstance_Afts_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHopGroup(Id uint64) (*NetworkInstance_Afts_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Afts_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Afts_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHopGroup(v *NetworkInstance_Afts_NextHopGroup) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyForwardingEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeletePolicyForwardingEntry(Index uint64) {
	key := Index

	delete(t.PolicyForwardingEntry, key)
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Afts_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendNextHop(v *NetworkInstance_Afts_NextHopGroup_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpoint deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint) DeleteEndpoint(EndpointId string) {
	key := EndpointId

	delete(t.Endpoint, key)
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return t.Remote
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_MacTable{}
	return t.MacTable
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string, Vlan uint16) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
		Vlan:       &Vlan,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK NetworkInstance_Fdb_MacTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.Vlan = &newK.Vlan

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, Vlan)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_MacTable) DeleteEntry(MacAddress string, Vlan uint16) {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{MacAddress: *v.MacAddress, Vlan: *v.Vlan}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t.Interface != nil {
		return t.Interface
	}
	t.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return t.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t != nil && t.Interface != nil {
		return t.Interface
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	if t.Vlan == nil {
		return nil, fmt.Errorf("nil value for key Vlan")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
		"vlan":        *t.Vlan,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_Global{}
	return t.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if t.Lsps != nil {
		return t.Lsps
	}
	t.Lsps = &NetworkInstance_Mpls_Lsps{}
	return t.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	t.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return t.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	t.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return t.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if t != nil && t.Lsps != nil {
		return t.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t != nil && t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t != nil && t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// DeleteReservedLabelBlock deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteReservedLabelBlock(LocalId string) {
	key := LocalId

	delete(t.ReservedLabelBlock, key)
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	t.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return t.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t != nil && t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps) DeleteStaticLsp(Name string) {
	key := Name

	delete(t.StaticLsp, key)
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	t.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return t.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	t.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return t.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t != nil && t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t != nil && t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteNamedExplicitPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteNamedExplicitPath(Name string) {
	key := Name

	delete(t.NamedExplicitPath, key)
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnel deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteTunnel(Name string) {
	key := Name

	delete(t.Tunnel, key)
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) DeleteExplicitRouteObject(Index uint8) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return t.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	t.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return t.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t != nil && t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	t.AutoBandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return t.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t != nil && t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t.Overflow != nil {
		return t.Overflow
	}
	t.Overflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return t.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t.Underflow != nil {
		return t.Underflow
	}
	t.Underflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return t.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t != nil && t.Overflow != nil {
		return t.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t != nil && t.Underflow != nil {
		return t.Underflow
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewP2PPrimaryPath creates a new entry in the P2PPrimaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PPrimaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PPrimaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PPrimaryPath", key)
	}

	t.P2PPrimaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
		Name: &Name,
	}

	return t.P2PPrimaryPath[key], nil
}

// RenameP2PPrimaryPath renames an entry in the list P2PPrimaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PPrimaryPath(oldK, newK string) error {
	if _, ok := t.P2PPrimaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PPrimaryPath", newK)
	}

	e, ok := t.P2PPrimaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PPrimaryPath", oldK)
	}
	e.Name = &newK

	t.P2PPrimaryPath[newK] = e
	delete(t.P2PPrimaryPath, oldK)
	return nil
}

// GetOrCreateP2PPrimaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	key := Name

	if v, ok := t.P2PPrimaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PPrimaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PPrimaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PPrimaryPath retrieves the value with the specified key from
// the P2PPrimaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PPrimaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PPrimaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PPrimaryPath(Name string) {
	key := Name

	delete(t.P2PPrimaryPath, key)
}

// AppendP2PPrimaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct to the
// list P2PPrimaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PPrimaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	if _, ok := t.P2PPrimaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PPrimaryPath %v", key)
	}

	t.P2PPrimaryPath[key] = v
	return nil
}

// NewP2PSecondaryPath creates a new entry in the P2PSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PSecondaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PSecondaryPath", key)
	}

	t.P2PSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
		Name: &Name,
	}

	return t.P2PSecondaryPath[key], nil
}

// RenameP2PSecondaryPath renames an entry in the list P2PSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PSecondaryPath(oldK, newK string) error {
	if _, ok := t.P2PSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PSecondaryPath", newK)
	}

	e, ok := t.P2PSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PSecondaryPath", oldK)
	}
	e.Name = &newK

	t.P2PSecondaryPath[newK] = e
	delete(t.P2PSecondaryPath, oldK)
	return nil
}

// GetOrCreateP2PSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	key := Name

	if v, ok := t.P2PSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PSecondaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PSecondaryPath retrieves the value with the specified key from
// the P2PSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PSecondaryPath(Name string) {
	key := Name

	delete(t.P2PSecondaryPath, key)
}

// AppendP2PSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct to the
// list P2PSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	if _, ok := t.P2PSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PSecondaryPath %v", key)
	}

	t.P2PSecondaryPath[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewCandidateSecondaryPath creates a new entry in the CandidateSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewCandidateSecondaryPath(SecondaryPath string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	key := SecondaryPath

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CandidateSecondaryPath", key)
	}

	t.CandidateSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
		SecondaryPath: &SecondaryPath,
	}

	return t.CandidateSecondaryPath[key], nil
}

// RenameCandidateSecondaryPath renames an entry in the list CandidateSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenameCandidateSecondaryPath(oldK, newK string) error {
	if _, ok := t.CandidateSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in CandidateSecondaryPath", newK)
	}

	e, ok := t.CandidateSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CandidateSecondaryPath", oldK)
	}
	e.SecondaryPath = &newK

	t.CandidateSecondaryPath[newK] = e
	delete(t.CandidateSecondaryPath, oldK)
	return nil
}

// GetOrCreateCandidateSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	key := SecondaryPath

	if v, ok := t.CandidateSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCandidateSecondaryPath(SecondaryPath)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCandidateSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetCandidateSecondaryPath retrieves the value with the specified key from
// the CandidateSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	if t == nil {
		return nil
	}

	key := SecondaryPath

	if lm, ok := t.CandidateSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteCandidateSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) DeleteCandidateSecondaryPath(SecondaryPath string) {
	key := SecondaryPath

	delete(t.CandidateSecondaryPath, key)
}

// AppendCandidateSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct to the
// list CandidateSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendCandidateSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) error {
	key := *v.SecondaryPath

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list CandidateSecondaryPath %v", key)
	}

	t.CandidateSecondaryPath[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	return t.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t.Transit != nil {
		return t.Transit
	}
	t.Transit = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	return t.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t != nil && t.Transit != nil {
		return t.Transit
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	t.PathSetupProtocol = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return t.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t != nil && t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return t.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	return t.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t.RsvpTe != nil {
		return t.RsvpTe
	}
	t.RsvpTe = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	return t.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	return t.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t != nil && t.RsvpTe != nil {
		return t.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) NewNeighbor(LsrId string, LabelSpaceId uint16) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
		LsrId:        &LsrId,
		LabelSpaceId: &LabelSpaceId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) RenameNeighbor(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.LsrId = &newK.LsrId
	e.LabelSpaceId = &newK.LabelSpaceId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(LsrId, LabelSpaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) DeleteNeighbor(LsrId string, LabelSpaceId uint16) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) error {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{LsrId: *v.LsrId, LabelSpaceId: *v.LabelSpaceId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	return t.Global
}

// GetOrCreateInterfaceAttributes retrieves the value of the InterfaceAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	t.InterfaceAttributes = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	return t.InterfaceAttributes
}

// GetOrCreateTargeted retrieves the value of the Targeted field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t.Targeted != nil {
		return t.Targeted
	}
	t.Targeted = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	return t.Targeted
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetInterfaceAttributes returns the value of the InterfaceAttributes struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field InterfaceAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t != nil && t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	return nil
}

// GetTargeted returns the value of the Targeted struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Targeted is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t != nil && t.Targeted != nil {
		return t.Targeted
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	return t.Authentication
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddressFamily creates a new entry in the AddressFamily list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) NewAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_OpenconfigMplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AddressFamily[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AddressFamily", key)
	}

	t.AddressFamily[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
		AfiName: AfiName,
	}

	return t.AddressFamily[key], nil
}

// RenameAddressFamily renames an entry in the list AddressFamily within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) RenameAddressFamily(oldK, newK E_OpenconfigMplsLdp_MplsLdpAfi) error {
	if _, ok := t.AddressFamily[newK]; ok {
		return fmt.Errorf("key %v already exists in AddressFamily", newK)
	}

	e, ok := t.AddressFamily[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AddressFamily", oldK)
	}
	e.AfiName = newK

	t.AddressFamily[newK] = e
	delete(t.AddressFamily, oldK)
	return nil
}

// GetOrCreateAddressFamily retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	key := AfiName

	if v, ok := t.AddressFamily[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddressFamily(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddressFamily got unexpected error: %v", err))
	}
	return v
}

// GetAddressFamily retrieves the value with the specified key from
// the AddressFamily map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.AddressFamily[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddressFamily deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) DeleteAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) {
	key := AfiName

	delete(t.AddressFamily, key)
}

// AppendAddressFamily appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct to the
// list AddressFamily of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) AppendAddressFamily(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_OpenconfigMplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	if _, ok := t.AddressFamily[key]; ok {
		return fmt.Errorf("duplicate key for list AddressFamily %v", key)
	}

	t.AddressFamily[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewHelloAdjacency creates a new entry in the HelloAdjacency list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) NewHelloAdjacency(RemoteAddress string, LocalAddress string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HelloAdjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HelloAdjacency", key)
	}

	t.HelloAdjacency[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
		RemoteAddress: &RemoteAddress,
		LocalAddress:  &LocalAddress,
	}

	return t.HelloAdjacency[key], nil
}

// RenameHelloAdjacency renames an entry in the list HelloAdjacency within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) RenameHelloAdjacency(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key) error {
	if _, ok := t.HelloAdjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in HelloAdjacency", newK)
	}

	e, ok := t.HelloAdjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HelloAdjacency", oldK)
	}
	e.RemoteAddress = &newK.RemoteAddress
	e.LocalAddress = &newK.LocalAddress

	t.HelloAdjacency[newK] = e
	delete(t.HelloAdjacency, oldK)
	return nil
}

// GetOrCreateHelloAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if v, ok := t.HelloAdjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHelloAdjacency(RemoteAddress, LocalAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHelloAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetHelloAdjacency retrieves the value with the specified key from
// the HelloAdjacency map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if lm, ok := t.HelloAdjacency[key]; ok {
		return lm
	}
	return nil
}

// DeleteHelloAdjacency deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) DeleteHelloAdjacency(RemoteAddress string, LocalAddress string) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	delete(t.HelloAdjacency, key)
}

// AppendHelloAdjacency appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct to the
// list HelloAdjacency of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) AppendHelloAdjacency(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) error {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{RemoteAddress: *v.RemoteAddress, LocalAddress: *v.LocalAddress}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	if _, ok := t.HelloAdjacency[key]; ok {
		return fmt.Errorf("duplicate key for list HelloAdjacency %v", key)
	}

	t.HelloAdjacency[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	return t.Authentication
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LabelSpaceId == nil {
		return nil, fmt.Errorf("nil value for key LabelSpaceId")
	}

	if t.LsrId == nil {
		return nil, fmt.Errorf("nil value for key LsrId")
	}

	return map[string]interface{}{
		"label-space-id": *t.LabelSpaceId,
		"lsr-id":         *t.LsrId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateHelloHoldtime retrieves the value of the HelloHoldtime field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetOrCreateHelloHoldtime() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	if t.HelloHoldtime != nil {
		return t.HelloHoldtime
	}
	t.HelloHoldtime = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	return t.HelloHoldtime
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	return t.InterfaceRef
}

// GetHelloHoldtime returns the value of the HelloHoldtime struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency. If the receiver or the field HelloHoldtime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetHelloHoldtime() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	if t != nil && t.HelloHoldtime != nil {
		return t.HelloHoldtime
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalAddress == nil {
		return nil, fmt.Errorf("nil value for key LocalAddress")
	}

	if t.RemoteAddress == nil {
		return nil, fmt.Errorf("nil value for key RemoteAddress")
	}

	return map[string]interface{}{
		"local-address":  *t.LocalAddress,
		"remote-address": *t.RemoteAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddressFamily creates a new entry in the AddressFamily list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) NewAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_OpenconfigMplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AddressFamily[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AddressFamily", key)
	}

	t.AddressFamily[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
		AfiName: AfiName,
	}

	return t.AddressFamily[key], nil
}

// RenameAddressFamily renames an entry in the list AddressFamily within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) RenameAddressFamily(oldK, newK E_OpenconfigMplsLdp_MplsLdpAfi) error {
	if _, ok := t.AddressFamily[newK]; ok {
		return fmt.Errorf("key %v already exists in AddressFamily", newK)
	}

	e, ok := t.AddressFamily[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AddressFamily", oldK)
	}
	e.AfiName = newK

	t.AddressFamily[newK] = e
	delete(t.AddressFamily, oldK)
	return nil
}

// GetOrCreateAddressFamily retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetOrCreateAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {

	key := AfiName

	if v, ok := t.AddressFamily[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddressFamily(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddressFamily got unexpected error: %v", err))
	}
	return v
}

// GetAddressFamily retrieves the value with the specified key from
// the AddressFamily map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.AddressFamily[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddressFamily deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) DeleteAddressFamily(AfiName E_OpenconfigMplsLdp_MplsLdpAfi) {
	key := AfiName

	delete(t.AddressFamily, key)
}

// AppendAddressFamily appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct to the
// list AddressFamily of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) AppendAddressFamily(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_OpenconfigMplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
	}

	if _, ok := t.AddressFamily[key]; ok {
		return fmt.Errorf("duplicate key for list AddressFamily %v", key)
	}

	t.AddressFamily[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTarget creates a new entry in the Target list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) NewTarget(RemoteAddress string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
	}

	key := RemoteAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
		RemoteAddress: &RemoteAddress,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.RemoteAddress = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) GetOrCreateTarget(RemoteAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {

	key := RemoteAddress

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(RemoteAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) GetTarget(RemoteAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {

	if t == nil {
		return nil
	}

	key := RemoteAddress

	if lm, ok := t.Target[key]; ok {
		return lm
	}
	return nil
}

// DeleteTarget deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) DeleteTarget(RemoteAddress string) {
	key := RemoteAddress

	delete(t.Target, key)
}

// AppendTarget appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target struct to the
// list Target of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) AppendTarget(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) error {
	key := *v.RemoteAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RemoteAddress == nil {
		return nil, fmt.Errorf("nil value for key RemoteAddress")
	}

	return map[string]interface{}{
		"remote-address": *t.RemoteAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewNeighbor(Address string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
		Address: &Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	key := Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteNeighbor(Address string) {
	key := Address

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewSession creates a new entry in the Session list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewSession(LocalIndex uint64) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	key := LocalIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
		LocalIndex: &LocalIndex,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameSession(oldK, newK uint64) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.LocalIndex = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	key := LocalIndex

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(LocalIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	if t == nil {
		return nil
	}

	key := LocalIndex

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteSession(LocalIndex uint64) {
	key := LocalIndex

	delete(t.Session, key)
}

// AppendSession appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct to the
// list Session of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendSession(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) error {
	key := *v.LocalIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	return t.Counters
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if t.Hellos != nil {
		return t.Hellos
	}
	t.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	return t.Hellos
}

// GetOrCreateSoftPreemption retrieves the value of the SoftPreemption field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if t.SoftPreemption != nil {
		return t.SoftPreemption
	}
	t.SoftPreemption = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	return t.SoftPreemption
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if t != nil && t.Hellos != nil {
		return t.Hellos
	}
	return nil
}

// GetSoftPreemption returns the value of the SoftPreemption struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field SoftPreemption is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if t != nil && t.SoftPreemption != nil {
		return t.SoftPreemption
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateErrors retrieves the value of the Errors field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOrCreateErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	if t.Errors != nil {
		return t.Errors
	}
	t.Errors = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	return t.Errors
}

// GetErrors returns the value of the Errors struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters. If the receiver or the field Errors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	if t != nil && t.Errors != nil {
		return t.Errors
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewBandwidthReservation creates a new entry in the BandwidthReservation list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) NewBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthReservation[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthReservation", key)
	}

	t.BandwidthReservation[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
		Priority: Priority,
	}

	return t.BandwidthReservation[key], nil
}

// RenameBandwidthReservation renames an entry in the list BandwidthReservation within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) RenameBandwidthReservation(oldK, newK NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) error {
	if _, ok := t.BandwidthReservation[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthReservation", newK)
	}

	e, ok := t.BandwidthReservation[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthReservation", oldK)
	}
	e.Priority = newK

	t.BandwidthReservation[newK] = e
	delete(t.BandwidthReservation, oldK)
	return nil
}

// GetOrCreateBandwidthReservation retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	key := Priority

	if v, ok := t.BandwidthReservation[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthReservation(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthReservation got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthReservation retrieves the value with the specified key from
// the BandwidthReservation map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.BandwidthReservation[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthReservation deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) DeleteBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) {
	key := Priority

	delete(t.BandwidthReservation, key)
}

// AppendBandwidthReservation appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct to the
// list BandwidthReservation of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) AppendBandwidthReservation(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) error {
	key := v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	if _, ok := t.BandwidthReservation[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthReservation %v", key)
	}

	t.BandwidthReservation[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	return t.Authentication
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	return t.Counters
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if t.Hellos != nil {
		return t.Hellos
	}
	t.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	return t.Hellos
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateProtection retrieves the value of the Protection field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if t.Protection != nil {
		return t.Protection
	}
	t.Protection = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	return t.Protection
}

// GetOrCreateSubscription retrieves the value of the Subscription field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if t.Subscription != nil {
		return t.Subscription
	}
	t.Subscription = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	return t.Subscription
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if t != nil && t.Hellos != nil {
		return t.Hellos
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetProtection returns the value of the Protection struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Protection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if t != nil && t.Protection != nil {
		return t.Protection
	}
	return nil
}

// GetSubscription returns the value of the Subscription struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Subscription is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if t != nil && t.Subscription != nil {
		return t.Subscription
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"priority": t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateErrors retrieves the value of the Errors field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOrCreateErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	if t.Errors != nil {
		return t.Errors
	}
	t.Errors = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	return t.Errors
}

// GetErrors returns the value of the Errors struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters. If the receiver or the field Errors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	if t != nil && t.Errors != nil {
		return t.Errors
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) NewExplicitRouteObject(Index uint64) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) RenameExplicitRouteObject(oldK, newK uint64) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateExplicitRouteObject(Index uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetExplicitRouteObject(Index uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) DeleteExplicitRouteObject(Index uint64) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) AppendExplicitRouteObject(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// NewRecordRouteObject creates a new entry in the RecordRouteObject list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) NewRecordRouteObject(Index uint8) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RecordRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RecordRouteObject", key)
	}

	t.RecordRouteObject[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
		Index: &Index,
	}

	return t.RecordRouteObject[key], nil
}

// RenameRecordRouteObject renames an entry in the list RecordRouteObject within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) RenameRecordRouteObject(oldK, newK uint8) error {
	if _, ok := t.RecordRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in RecordRouteObject", newK)
	}

	e, ok := t.RecordRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RecordRouteObject", oldK)
	}
	e.Index = &newK

	t.RecordRouteObject[newK] = e
	delete(t.RecordRouteObject, oldK)
	return nil
}

// GetOrCreateRecordRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	key := Index

	if v, ok := t.RecordRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRecordRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRecordRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetRecordRouteObject retrieves the value with the specified key from
// the RecordRouteObject map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.RecordRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteRecordRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) DeleteRecordRouteObject(Index uint8) {
	key := Index

	delete(t.RecordRouteObject, key)
}

// AppendRecordRouteObject appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct to the
// list RecordRouteObject of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) AppendRecordRouteObject(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	if _, ok := t.RecordRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list RecordRouteObject %v", key)
	}

	t.RecordRouteObject[key] = v
	return nil
}

// GetOrCreateSenderTspec retrieves the value of the SenderTspec field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if t.SenderTspec != nil {
		return t.SenderTspec
	}
	t.SenderTspec = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	return t.SenderTspec
}

// GetSenderTspec returns the value of the SenderTspec struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver or the field SenderTspec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if t != nil && t.SenderTspec != nil {
		return t.SenderTspec
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalIndex == nil {
		return nil, fmt.Errorf("nil value for key LocalIndex")
	}

	return map[string]interface{}{
		"local-index": *t.LocalIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAggregateSidCounter creates a new entry in the AggregateSidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AggregateSidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AggregateSidCounter", key)
	}

	t.AggregateSidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
		MplsLabel: MplsLabel,
	}

	return t.AggregateSidCounter[key], nil
}

// RenameAggregateSidCounter renames an entry in the list AggregateSidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameAggregateSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) error {
	if _, ok := t.AggregateSidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in AggregateSidCounter", newK)
	}

	e, ok := t.AggregateSidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AggregateSidCounter", oldK)
	}
	e.MplsLabel = newK

	t.AggregateSidCounter[newK] = e
	delete(t.AggregateSidCounter, oldK)
	return nil
}

// GetOrCreateAggregateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	key := MplsLabel

	if v, ok := t.AggregateSidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregateSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetAggregateSidCounter retrieves the value with the specified key from
// the AggregateSidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.AggregateSidCounter[key]; ok {
		return lm
	}
	return nil
}

// DeleteAggregateSidCounter deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) DeleteAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) {
	key := MplsLabel

	delete(t.AggregateSidCounter, key)
}

// AppendAggregateSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct to the
// list AggregateSidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendAggregateSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	if _, ok := t.AggregateSidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list AggregateSidCounter %v", key)
	}

	t.AggregateSidCounter[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSidCounter creates a new entry in the SidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) NewSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SidCounter", key)
	}

	t.SidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
		MplsLabel: MplsLabel,
	}

	return t.SidCounter[key], nil
}

// RenameSidCounter renames an entry in the list SidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) RenameSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) error {
	if _, ok := t.SidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in SidCounter", newK)
	}

	e, ok := t.SidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SidCounter", oldK)
	}
	e.MplsLabel = newK

	t.SidCounter[newK] = e
	delete(t.SidCounter, oldK)
	return nil
}

// GetOrCreateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	key := MplsLabel

	if v, ok := t.SidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetSidCounter retrieves the value with the specified key from
// the SidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.SidCounter[key]; ok {
		return lm
	}
	return nil
}

// DeleteSidCounter deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) DeleteSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) {
	key := MplsLabel

	delete(t.SidCounter, key)
}

// AppendSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct to the
// list SidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) AppendSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	if _, ok := t.SidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list SidCounter %v", key)
	}

	t.SidCounter[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) NewForwardingClass(Exp uint8) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	key := Exp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
		Exp: &Exp,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) RenameForwardingClass(oldK, newK uint8) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Exp = &newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOrCreateForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	key := Exp

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Exp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	if t == nil {
		return nil
	}

	key := Exp

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) DeleteForwardingClass(Exp uint8) {
	key := Exp

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct to the
// list ForwardingClass of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) AppendForwardingClass(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) error {
	key := *v.Exp

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Exp == nil {
		return nil, fmt.Errorf("nil value for key Exp")
	}

	return map[string]interface{}{
		"exp": *t.Exp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewAdminGroup(AdminGroupName string) (*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	key := AdminGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
		AdminGroupName: &AdminGroupName,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameAdminGroup(oldK, newK string) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.AdminGroupName = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	key := AdminGroupName

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(AdminGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	if t == nil {
		return nil
	}

	key := AdminGroupName

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdminGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) DeleteAdminGroup(AdminGroupName string) {
	key := AdminGroupName

	delete(t.AdminGroup, key)
}

// AppendAdminGroup appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct to the
// list AdminGroup of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendAdminGroup(v *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) error {
	key := *v.AdminGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewSrlg creates a new entry in the Srlg list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewSrlg(Name string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlg", key)
	}

	t.Srlg[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg{
		Name: &Name,
	}

	return t.Srlg[key], nil
}

// RenameSrlg renames an entry in the list Srlg within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameSrlg(oldK, newK string) error {
	if _, ok := t.Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlg", newK)
	}

	e, ok := t.Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlg", oldK)
	}
	e.Name = &newK

	t.Srlg[newK] = e
	delete(t.Srlg, oldK)
	return nil
}

// GetOrCreateSrlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	key := Name

	if v, ok := t.Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlg(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlg got unexpected error: %v", err))
	}
	return v
}

// GetSrlg retrieves the value with the specified key from
// the Srlg map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrlg deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) DeleteSrlg(Name string) {
	key := Name

	delete(t.Srlg, key)
}

// AppendSrlg appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct to the
// list Srlg of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendSrlg(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	if _, ok := t.Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Srlg %v", key)
	}

	t.Srlg[key] = v
	return nil
}

// GetOrCreateTeLspTimers retrieves the value of the TeLspTimers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if t.TeLspTimers != nil {
		return t.TeLspTimers
	}
	t.TeLspTimers = &NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	return t.TeLspTimers
}

// GetTeLspTimers returns the value of the TeLspTimers struct pointer
// from NetworkInstance_Mpls_TeGlobalAttributes. If the receiver or the field TeLspTimers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if t != nil && t.TeLspTimers != nil {
		return t.TeLspTimers
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AdminGroupName == nil {
		return nil, fmt.Errorf("nil value for key AdminGroupName")
	}

	return map[string]interface{}{
		"admin-group-name": *t.AdminGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewMembersList creates a new entry in the MembersList list of the
// NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) NewMembersList(FromAddress string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	key := FromAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MembersList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MembersList", key)
	}

	t.MembersList[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
		FromAddress: &FromAddress,
	}

	return t.MembersList[key], nil
}

// RenameMembersList renames an entry in the list MembersList within
// the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) RenameMembersList(oldK, newK string) error {
	if _, ok := t.MembersList[newK]; ok {
		return fmt.Errorf("key %v already exists in MembersList", newK)
	}

	e, ok := t.MembersList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MembersList", oldK)
	}
	e.FromAddress = &newK

	t.MembersList[newK] = e
	delete(t.MembersList, oldK)
	return nil
}

// GetOrCreateMembersList retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetOrCreateMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	key := FromAddress

	if v, ok := t.MembersList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMembersList(FromAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMembersList got unexpected error: %v", err))
	}
	return v
}

// GetMembersList retrieves the value with the specified key from
// the MembersList map field of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	if t == nil {
		return nil
	}

	key := FromAddress

	if lm, ok := t.MembersList[key]; ok {
		return lm
	}
	return nil
}

// DeleteMembersList deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) DeleteMembersList(FromAddress string) {
	key := FromAddress

	delete(t.MembersList, key)
}

// AppendMembersList appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct to the
// list MembersList of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) AppendMembersList(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) error {
	key := *v.FromAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	if _, ok := t.MembersList[key]; ok {
		return fmt.Errorf("duplicate key for list MembersList %v", key)
	}

	t.MembersList[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FromAddress == nil {
		return nil, fmt.Errorf("nil value for key FromAddress")
	}

	return map[string]interface{}{
		"from-address": *t.FromAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewInterface(InterfaceId string) (*NetworkInstance_PolicyForwarding_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_PolicyForwarding_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreateInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_PolicyForwarding_Interface struct to the
// list Interface of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendInterface(v *NetworkInstance_PolicyForwarding_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewPathSelectionGroup creates a new entry in the PathSelectionGroup list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPathSelectionGroup(GroupId string) (*NetworkInstance_PolicyForwarding_PathSelectionGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	key := GroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathSelectionGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathSelectionGroup", key)
	}

	t.PathSelectionGroup[key] = &NetworkInstance_PolicyForwarding_PathSelectionGroup{
		GroupId: &GroupId,
	}

	return t.PathSelectionGroup[key], nil
}

// RenamePathSelectionGroup renames an entry in the list PathSelectionGroup within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePathSelectionGroup(oldK, newK string) error {
	if _, ok := t.PathSelectionGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PathSelectionGroup", newK)
	}

	e, ok := t.PathSelectionGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathSelectionGroup", oldK)
	}
	e.GroupId = &newK

	t.PathSelectionGroup[newK] = e
	delete(t.PathSelectionGroup, oldK)
	return nil
}

// GetOrCreatePathSelectionGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	key := GroupId

	if v, ok := t.PathSelectionGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathSelectionGroup(GroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathSelectionGroup got unexpected error: %v", err))
	}
	return v
}

// GetPathSelectionGroup retrieves the value with the specified key from
// the PathSelectionGroup map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	if t == nil {
		return nil
	}

	key := GroupId

	if lm, ok := t.PathSelectionGroup[key]; ok {
		return lm
	}
	return nil
}

// DeletePathSelectionGroup deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeletePathSelectionGroup(GroupId string) {
	key := GroupId

	delete(t.PathSelectionGroup, key)
}

// AppendPathSelectionGroup appends the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup struct to the
// list PathSelectionGroup of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPathSelectionGroup(v *NetworkInstance_PolicyForwarding_PathSelectionGroup) error {
	key := *v.GroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	if _, ok := t.PathSelectionGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PathSelectionGroup %v", key)
	}

	t.PathSelectionGroup[key] = v
	return nil
}

// NewPolicy creates a new entry in the Policy list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPolicy(PolicyId string) (*NetworkInstance_PolicyForwarding_Policy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	key := PolicyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &NetworkInstance_PolicyForwarding_Policy{
		PolicyId: &PolicyId,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.PolicyId = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	key := PolicyId

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(PolicyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	if t == nil {
		return nil
	}

	key := PolicyId

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeletePolicy(PolicyId string) {
	key := PolicyId

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied NetworkInstance_PolicyForwarding_Policy struct to the
// list Policy of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPolicy(v *NetworkInstance_PolicyForwarding_Policy) error {
	key := *v.PolicyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Interface) GetOrCreateInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_PolicyForwarding_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_PolicyForwarding_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Interface) GetInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_PathSelectionGroup struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupId == nil {
		return nil, fmt.Errorf("nil value for key GroupId")
	}

	return map[string]interface{}{
		"group-id": *t.GroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_PathSelectionGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewRule creates a new entry in the Rule list of the
// NetworkInstance_PolicyForwarding_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy) NewRule(SequenceId uint32) (*NetworkInstance_PolicyForwarding_Policy_Rule, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rule", key)
	}

	t.Rule[key] = &NetworkInstance_PolicyForwarding_Policy_Rule{
		SequenceId: &SequenceId,
	}

	return t.Rule[key], nil
}

// RenameRule renames an entry in the list Rule within
// the NetworkInstance_PolicyForwarding_Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy) RenameRule(oldK, newK uint32) error {
	if _, ok := t.Rule[newK]; ok {
		return fmt.Errorf("key %v already exists in Rule", newK)
	}

	e, ok := t.Rule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rule", oldK)
	}
	e.SequenceId = &newK

	t.Rule[newK] = e
	delete(t.Rule, oldK)
	return nil
}

// GetOrCreateRule retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy) GetOrCreateRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	key := SequenceId

	if v, ok := t.Rule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRule(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRule got unexpected error: %v", err))
	}
	return v
}

// GetRule retrieves the value with the specified key from
// the Rule map field of NetworkInstance_PolicyForwarding_Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy) GetRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Rule[key]; ok {
		return lm
	}
	return nil
}

// DeleteRule deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding_Policy) DeleteRule(SequenceId uint32) {
	key := SequenceId

	delete(t.Rule, key)
}

// AppendRule appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule struct to the
// list Rule of NetworkInstance_PolicyForwarding_Policy. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy) AppendRule(v *NetworkInstance_PolicyForwarding_Policy_Rule) error {
	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	if _, ok := t.Rule[key]; ok {
		return fmt.Errorf("duplicate key for list Rule %v", key)
	}

	t.Rule[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PolicyId == nil {
		return nil, fmt.Errorf("nil value for key PolicyId")
	}

	return map[string]interface{}{
		"policy-id": *t.PolicyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &NetworkInstance_PolicyForwarding_Policy_Rule_Action{}
	return t.Action
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6{}
	return t.Ipv6
}

// GetOrCreateL2 retrieves the value of the L2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if t.L2 != nil {
		return t.L2
	}
	t.L2 = &NetworkInstance_PolicyForwarding_Policy_Rule_L2{}
	return t.L2
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_PolicyForwarding_Policy_Rule_Transport{}
	return t.Transport
}

// GetAction returns the value of the Action struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetL2 returns the value of the L2 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field L2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if t != nil && t.L2 != nil {
		return t.L2
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEncapsulateGre retrieves the value of the EncapsulateGre field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetOrCreateEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if t.EncapsulateGre != nil {
		return t.EncapsulateGre
	}
	t.EncapsulateGre = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre{}
	return t.EncapsulateGre
}

// GetEncapsulateGre returns the value of the EncapsulateGre struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule_Action. If the receiver or the field EncapsulateGre is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if t != nil && t.EncapsulateGre != nil {
		return t.EncapsulateGre
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTarget creates a new entry in the Target list of the
// NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) NewTarget(Id string) (*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target{
		Id: &Id,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.Id = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetOrCreateTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	key := Id

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Target[key]; ok {
		return lm
	}
	return nil
}

// DeleteTarget deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) DeleteTarget(Id string) {
	key := Id

	delete(t.Target, key)
}

// AppendTarget appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct to the
// list Target of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) AppendTarget(v *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_L2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAggregate creates a new entry in the Aggregate list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewAggregate(Prefix string) (*NetworkInstance_Protocol_Aggregate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aggregate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aggregate", key)
	}

	t.Aggregate[key] = &NetworkInstance_Protocol_Aggregate{
		Prefix: &Prefix,
	}

	return t.Aggregate[key], nil
}

// RenameAggregate renames an entry in the list Aggregate within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameAggregate(oldK, newK string) error {
	if _, ok := t.Aggregate[newK]; ok {
		return fmt.Errorf("key %v already exists in Aggregate", newK)
	}

	e, ok := t.Aggregate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aggregate", oldK)
	}
	e.Prefix = &newK

	t.Aggregate[newK] = e
	delete(t.Aggregate, oldK)
	return nil
}

// GetOrCreateAggregate retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	key := Prefix

	if v, ok := t.Aggregate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregate(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregate got unexpected error: %v", err))
	}
	return v
}

// GetAggregate retrieves the value with the specified key from
// the Aggregate map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Aggregate[key]; ok {
		return lm
	}
	return nil
}

// DeleteAggregate deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol) DeleteAggregate(Prefix string) {
	key := Prefix

	delete(t.Aggregate, key)
}

// AppendAggregate appends the supplied NetworkInstance_Protocol_Aggregate struct to the
// list Aggregate of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Aggregate already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendAggregate(v *NetworkInstance_Protocol_Aggregate) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	if _, ok := t.Aggregate[key]; ok {
		return fmt.Errorf("duplicate key for list Aggregate %v", key)
	}

	t.Aggregate[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewStatic(Prefix string) (*NetworkInstance_Protocol_Static, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &NetworkInstance_Protocol_Static{
		Prefix: &Prefix,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Prefix = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateStatic(Prefix string) *NetworkInstance_Protocol_Static {

	key := Prefix

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetStatic(Prefix string) *NetworkInstance_Protocol_Static {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatic deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol) DeleteStatic(Prefix string) {
	key := Prefix

	delete(t.Static, key)
}

// AppendStatic appends the supplied NetworkInstance_Protocol_Static struct to the
// list Static of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Static already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendStatic(v *NetworkInstance_Protocol_Static) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateBgp() *NetworkInstance_Protocol_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &NetworkInstance_Protocol_Bgp{}
	return t.Bgp
}

// GetOrCreateIgmp retrieves the value of the Igmp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateIgmp() *NetworkInstance_Protocol_Igmp {
	if t.Igmp != nil {
		return t.Igmp
	}
	t.Igmp = &NetworkInstance_Protocol_Igmp{}
	return t.Igmp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateIsis() *NetworkInstance_Protocol_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &NetworkInstance_Protocol_Isis{}
	return t.Isis
}

// GetOrCreateOspfv2 retrieves the value of the Ospfv2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if t.Ospfv2 != nil {
		return t.Ospfv2
	}
	t.Ospfv2 = &NetworkInstance_Protocol_Ospfv2{}
	return t.Ospfv2
}

// GetOrCreatePim retrieves the value of the Pim field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreatePim() *NetworkInstance_Protocol_Pim {
	if t.Pim != nil {
		return t.Pim
	}
	t.Pim = &NetworkInstance_Protocol_Pim{}
	return t.Pim
}

// GetBgp returns the value of the Bgp struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetBgp() *NetworkInstance_Protocol_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIgmp returns the value of the Igmp struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Igmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetIgmp() *NetworkInstance_Protocol_Igmp {
	if t != nil && t.Igmp != nil {
		return t.Igmp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetIsis() *NetworkInstance_Protocol_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// GetOspfv2 returns the value of the Ospfv2 struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Ospfv2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if t != nil && t.Ospfv2 != nil {
		return t.Ospfv2
	}
	return nil
}

// GetPim returns the value of the Pim struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Pim is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetPim() *NetworkInstance_Protocol_Pim {
	if t != nil && t.Pim != nil {
		return t.Pim
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"identifier": t.Identifier,
		"name":       *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Aggregate struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Aggregate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Aggregate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewNeighbor(NeighborAddress string) (*NetworkInstance_Protocol_Bgp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Bgp_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp) DeleteNeighbor(NeighborAddress string) {
	key := NeighborAddress

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Bgp_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendNeighbor(v *NetworkInstance_Protocol_Bgp_Neighbor) error {
	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewPeerGroup creates a new entry in the PeerGroup list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewPeerGroup(PeerGroupName string) (*NetworkInstance_Protocol_Bgp_PeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	key := PeerGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PeerGroup", key)
	}

	t.PeerGroup[key] = &NetworkInstance_Protocol_Bgp_PeerGroup{
		PeerGroupName: &PeerGroupName,
	}

	return t.PeerGroup[key], nil
}

// RenamePeerGroup renames an entry in the list PeerGroup within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenamePeerGroup(oldK, newK string) error {
	if _, ok := t.PeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PeerGroup", newK)
	}

	e, ok := t.PeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PeerGroup", oldK)
	}
	e.PeerGroupName = &newK

	t.PeerGroup[newK] = e
	delete(t.PeerGroup, oldK)
	return nil
}

// GetOrCreatePeerGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreatePeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	key := PeerGroupName

	if v, ok := t.PeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPeerGroup(PeerGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetPeerGroup retrieves the value with the specified key from
// the PeerGroup map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetPeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	if t == nil {
		return nil
	}

	key := PeerGroupName

	if lm, ok := t.PeerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeletePeerGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp) DeletePeerGroup(PeerGroupName string) {
	key := PeerGroupName

	delete(t.PeerGroup, key)
}

// AppendPeerGroup appends the supplied NetworkInstance_Protocol_Bgp_PeerGroup struct to the
// list PeerGroup of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_PeerGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendPeerGroup(v *NetworkInstance_Protocol_Bgp_PeerGroup) error {
	key := *v.PeerGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	if _, ok := t.PeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PeerGroup %v", key)
	}

	t.PeerGroup[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Bgp_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Bgp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_Global_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_Global_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_Global) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_Global_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// NewDynamicNeighborPrefix creates a new entry in the DynamicNeighborPrefix list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewDynamicNeighborPrefix(Prefix string) (*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DynamicNeighborPrefix", key)
	}

	t.DynamicNeighborPrefix[key] = &NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix{
		Prefix: &Prefix,
	}

	return t.DynamicNeighborPrefix[key], nil
}

// RenameDynamicNeighborPrefix renames an entry in the list DynamicNeighborPrefix within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameDynamicNeighborPrefix(oldK, newK string) error {
	if _, ok := t.DynamicNeighborPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in DynamicNeighborPrefix", newK)
	}

	e, ok := t.DynamicNeighborPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DynamicNeighborPrefix", oldK)
	}
	e.Prefix = &newK

	t.DynamicNeighborPrefix[newK] = e
	delete(t.DynamicNeighborPrefix, oldK)
	return nil
}

// GetOrCreateDynamicNeighborPrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	key := Prefix

	if v, ok := t.DynamicNeighborPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamicNeighborPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamicNeighborPrefix got unexpected error: %v", err))
	}
	return v
}

// GetDynamicNeighborPrefix retrieves the value with the specified key from
// the DynamicNeighborPrefix map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.DynamicNeighborPrefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteDynamicNeighborPrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_Global) DeleteDynamicNeighborPrefix(Prefix string) {
	key := Prefix

	delete(t.DynamicNeighborPrefix, key)
}

// AppendDynamicNeighborPrefix appends the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix struct to the
// list DynamicNeighborPrefix of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendDynamicNeighborPrefix(v *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list DynamicNeighborPrefix %v", key)
	}

	t.DynamicNeighborPrefix[key] = v
	return nil
}

// GetOrCreateConfederation retrieves the value of the Confederation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if t.Confederation != nil {
		return t.Confederation
	}
	t.Confederation = &NetworkInstance_Protocol_Bgp_Global_Confederation{}
	return t.Confederation
}

// GetOrCreateDefaultRouteDistance retrieves the value of the DefaultRouteDistance field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	t.DefaultRouteDistance = &NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance{}
	return t.DefaultRouteDistance
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetConfederation returns the value of the Confederation struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field Confederation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if t != nil && t.Confederation != nil {
		return t.Confederation
	}
	return nil
}

// GetDefaultRouteDistance returns the value of the DefaultRouteDistance struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field DefaultRouteDistance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if t != nil && t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Global_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_Confederation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_Confederation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_Confederation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateAsPathOptions() *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions {
	if t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	t.AsPathOptions = &NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions{}
	return t.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateEbgpMultihop() *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop {
	if t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	t.EbgpMultihop = &NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop{}
	return t.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateErrorHandling() *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling {
	if t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	t.ErrorHandling = &NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling{}
	return t.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateLoggingOptions() *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions {
	if t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	t.LoggingOptions = &NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions{}
	return t.LoggingOptions
}

// GetOrCreateMessages retrieves the value of the Messages field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateMessages() *NetworkInstance_Protocol_Bgp_Neighbor_Messages {
	if t.Messages != nil {
		return t.Messages
	}
	t.Messages = &NetworkInstance_Protocol_Bgp_Neighbor_Messages{}
	return t.Messages
}

// GetOrCreateQueues retrieves the value of the Queues field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateQueues() *NetworkInstance_Protocol_Bgp_Neighbor_Queues {
	if t.Queues != nil {
		return t.Queues
	}
	t.Queues = &NetworkInstance_Protocol_Bgp_Neighbor_Queues{}
	return t.Queues
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateRouteReflector() *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector {
	if t.RouteReflector != nil {
		return t.RouteReflector
	}
	t.RouteReflector = &NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector{}
	return t.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateTimers() *NetworkInstance_Protocol_Bgp_Neighbor_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Bgp_Neighbor_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateTransport() *NetworkInstance_Protocol_Bgp_Neighbor_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_Protocol_Bgp_Neighbor_Transport{}
	return t.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetAsPathOptions() *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions {
	if t != nil && t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetEbgpMultihop() *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop {
	if t != nil && t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetErrorHandling() *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling {
	if t != nil && t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetLoggingOptions() *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions {
	if t != nil && t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	return nil
}

// GetMessages returns the value of the Messages struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Messages is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetMessages() *NetworkInstance_Protocol_Bgp_Neighbor_Messages {
	if t != nil && t.Messages != nil {
		return t.Messages
	}
	return nil
}

// GetQueues returns the value of the Queues struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Queues is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetQueues() *NetworkInstance_Protocol_Bgp_Neighbor_Queues {
	if t != nil && t.Queues != nil {
		return t.Queues
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetRouteReflector() *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector {
	if t != nil && t.RouteReflector != nil {
		return t.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetTimers() *NetworkInstance_Protocol_Bgp_Neighbor_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetTransport() *NetworkInstance_Protocol_Bgp_Neighbor_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NeighborAddress == nil {
		return nil, fmt.Errorf("nil value for key NeighborAddress")
	}

	return map[string]interface{}{
		"neighbor-address": *t.NeighborAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreatePrefixes retrieves the value of the Prefixes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreatePrefixes() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes {
	if t.Prefixes != nil {
		return t.Prefixes
	}
	t.Prefixes = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes{}
	return t.Prefixes
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetPrefixes returns the value of the Prefixes struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Prefixes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetPrefixes() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes {
	if t != nil && t.Prefixes != nil {
		return t.Prefixes
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateReceived retrieves the value of the Received field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetOrCreateReceived() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received {
	if t.Received != nil {
		return t.Received
	}
	t.Received = &NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received{}
	return t.Received
}

// GetOrCreateSent retrieves the value of the Sent field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetOrCreateSent() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent {
	if t.Sent != nil {
		return t.Sent
	}
	t.Sent = &NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent{}
	return t.Sent
}

// GetReceived returns the value of the Received struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_Messages. If the receiver or the field Received is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetReceived() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received {
	if t != nil && t.Received != nil {
		return t.Received
	}
	return nil
}

// GetSent returns the value of the Sent struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_Messages. If the receiver or the field Sent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetSent() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent {
	if t != nil && t.Sent != nil {
		return t.Sent
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Queues) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Queues"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Queues) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_PeerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_PeerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_PeerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_PeerGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) DeleteAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_PeerGroup. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateAsPathOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions {
	if t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	t.AsPathOptions = &NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions{}
	return t.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateEbgpMultihop() *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop {
	if t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	t.EbgpMultihop = &NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop{}
	return t.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateErrorHandling() *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling {
	if t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	t.ErrorHandling = &NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling{}
	return t.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateLoggingOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions {
	if t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	t.LoggingOptions = &NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions{}
	return t.LoggingOptions
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateRouteReflector() *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector {
	if t.RouteReflector != nil {
		return t.RouteReflector
	}
	t.RouteReflector = &NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector{}
	return t.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateTimers() *NetworkInstance_Protocol_Bgp_PeerGroup_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Bgp_PeerGroup_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateTransport() *NetworkInstance_Protocol_Bgp_PeerGroup_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_Protocol_Bgp_PeerGroup_Transport{}
	return t.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetAsPathOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions {
	if t != nil && t.AsPathOptions != nil {
		return t.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetEbgpMultihop() *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop {
	if t != nil && t.EbgpMultihop != nil {
		return t.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetErrorHandling() *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling {
	if t != nil && t.ErrorHandling != nil {
		return t.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetLoggingOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions {
	if t != nil && t.LoggingOptions != nil {
		return t.LoggingOptions
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetRouteReflector() *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector {
	if t != nil && t.RouteReflector != nil {
		return t.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetTimers() *NetworkInstance_Protocol_Bgp_PeerGroup_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetTransport() *NetworkInstance_Protocol_Bgp_PeerGroup_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_PeerGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerGroupName == nil {
		return nil, fmt.Errorf("nil value for key PeerGroupName")
	}

	return map[string]interface{}{
		"peer-group-name": *t.PeerGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return t.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if t.Ebgp != nil {
		return t.Ebgp
	}
	t.Ebgp = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp{}
	return t.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if t.Ibgp != nil {
		return t.Ibgp
	}
	t.Ibgp = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp{}
	return t.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if t != nil && t.Ebgp != nil {
		return t.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if t != nil && t.Ibgp != nil {
		return t.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Igmp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Igmp) NewInterface(InterfaceId string) (*NetworkInstance_Protocol_Igmp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Igmp_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Igmp_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Igmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Igmp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Igmp) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Protocol_Igmp_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Igmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Igmp) GetInterface(InterfaceId string) *NetworkInstance_Protocol_Igmp_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Igmp) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Igmp_Interface struct to the
// list Interface of NetworkInstance_Protocol_Igmp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Igmp_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Igmp) AppendInterface(v *NetworkInstance_Protocol_Igmp_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Igmp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp) GetOrCreateGlobal() *NetworkInstance_Protocol_Igmp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Igmp_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Igmp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp) GetGlobal() *NetworkInstance_Protocol_Igmp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateSsm retrieves the value of the Ssm field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Global) GetOrCreateSsm() *NetworkInstance_Protocol_Igmp_Global_Ssm {
	if t.Ssm != nil {
		return t.Ssm
	}
	t.Ssm = &NetworkInstance_Protocol_Igmp_Global_Ssm{}
	return t.Ssm
}

// GetSsm returns the value of the Ssm struct pointer
// from NetworkInstance_Protocol_Igmp_Global. If the receiver or the field Ssm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Global) GetSsm() *NetworkInstance_Protocol_Igmp_Global_Ssm {
	if t != nil && t.Ssm != nil {
		return t.Ssm
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewMapping creates a new entry in the Mapping list of the
// NetworkInstance_Protocol_Igmp_Global_Ssm struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) NewMapping(Source string) (*NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mapping == nil {
		t.Mapping = make(map[string]*NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping)
	}

	key := Source

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mapping[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mapping", key)
	}

	t.Mapping[key] = &NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
		Source: &Source,
	}

	return t.Mapping[key], nil
}

// RenameMapping renames an entry in the list Mapping within
// the NetworkInstance_Protocol_Igmp_Global_Ssm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) RenameMapping(oldK, newK string) error {
	if _, ok := t.Mapping[newK]; ok {
		return fmt.Errorf("key %v already exists in Mapping", newK)
	}

	e, ok := t.Mapping[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mapping", oldK)
	}
	e.Source = &newK

	t.Mapping[newK] = e
	delete(t.Mapping, oldK)
	return nil
}

// GetOrCreateMapping retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp_Global_Ssm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) GetOrCreateMapping(Source string) *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {

	key := Source

	if v, ok := t.Mapping[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMapping(Source)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMapping got unexpected error: %v", err))
	}
	return v
}

// GetMapping retrieves the value with the specified key from
// the Mapping map field of NetworkInstance_Protocol_Igmp_Global_Ssm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) GetMapping(Source string) *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {

	if t == nil {
		return nil
	}

	key := Source

	if lm, ok := t.Mapping[key]; ok {
		return lm
	}
	return nil
}

// DeleteMapping deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp_Global_Ssm. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) DeleteMapping(Source string) {
	key := Source

	delete(t.Mapping, key)
}

// AppendMapping appends the supplied NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping struct to the
// list Mapping of NetworkInstance_Protocol_Igmp_Global_Ssm. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) AppendMapping(v *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) error {
	key := *v.Source

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mapping == nil {
		t.Mapping = make(map[string]*NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping)
	}

	if _, ok := t.Mapping[key]; ok {
		return fmt.Errorf("duplicate key for list Mapping %v", key)
	}

	t.Mapping[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Global_Ssm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Source == nil {
		return nil, fmt.Errorf("nil value for key Source")
	}

	return map[string]interface{}{
		"source": *t.Source,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewGroup creates a new entry in the Group list of the
// NetworkInstance_Protocol_Igmp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Igmp_Interface) NewGroup(Group string) (*NetworkInstance_Protocol_Igmp_Interface_Group, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*NetworkInstance_Protocol_Igmp_Interface_Group)
	}

	key := Group

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &NetworkInstance_Protocol_Igmp_Interface_Group{
		Group: &Group,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the NetworkInstance_Protocol_Igmp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Igmp_Interface) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Group = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetOrCreateGroup(Group string) *NetworkInstance_Protocol_Igmp_Interface_Group {

	key := Group

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Group)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of NetworkInstance_Protocol_Igmp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetGroup(Group string) *NetworkInstance_Protocol_Igmp_Interface_Group {

	if t == nil {
		return nil
	}

	key := Group

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Igmp_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Igmp_Interface) DeleteGroup(Group string) {
	key := Group

	delete(t.Group, key)
}

// AppendGroup appends the supplied NetworkInstance_Protocol_Igmp_Interface_Group struct to the
// list Group of NetworkInstance_Protocol_Igmp_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Igmp_Interface_Group already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Igmp_Interface) AppendGroup(v *NetworkInstance_Protocol_Igmp_Interface_Group) error {
	key := *v.Group

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*NetworkInstance_Protocol_Igmp_Interface_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetOrCreateCounters() *NetworkInstance_Protocol_Igmp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Protocol_Igmp_Interface_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Protocol_Igmp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetCounters() *NetworkInstance_Protocol_Igmp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Igmp_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Igmp_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Igmp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateQueries retrieves the value of the Queries field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) GetOrCreateQueries() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	if t.Queries != nil {
		return t.Queries
	}
	t.Queries = &NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	return t.Queries
}

// GetOrCreateReports retrieves the value of the Reports field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) GetOrCreateReports() *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	if t.Reports != nil {
		return t.Reports
	}
	t.Reports = &NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	return t.Reports
}

// GetQueries returns the value of the Queries struct pointer
// from NetworkInstance_Protocol_Igmp_Interface_Counters. If the receiver or the field Queries is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) GetQueries() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	if t != nil && t.Queries != nil {
		return t.Queries
	}
	return nil
}

// GetReports returns the value of the Reports struct pointer
// from NetworkInstance_Protocol_Igmp_Interface_Counters. If the receiver or the field Reports is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) GetReports() *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	if t != nil && t.Reports != nil {
		return t.Reports
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateReceived retrieves the value of the Received field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) GetOrCreateReceived() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	if t.Received != nil {
		return t.Received
	}
	t.Received = &NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	return t.Received
}

// GetOrCreateSent retrieves the value of the Sent field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) GetOrCreateSent() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	if t.Sent != nil {
		return t.Sent
	}
	t.Sent = &NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	return t.Sent
}

// GetReceived returns the value of the Received struct pointer
// from NetworkInstance_Protocol_Igmp_Interface_Counters_Queries. If the receiver or the field Received is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) GetReceived() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	if t != nil && t.Received != nil {
		return t.Received
	}
	return nil
}

// GetSent returns the value of the Sent struct pointer
// from NetworkInstance_Protocol_Igmp_Interface_Counters_Queries. If the receiver or the field Sent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) GetSent() *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	if t != nil && t.Sent != nil {
		return t.Sent
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Queries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Reports"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Igmp_Interface_Group struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Group == nil {
		return nil, fmt.Errorf("nil value for key Group")
	}

	return map[string]interface{}{
		"group": *t.Group,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewInterface(InterfaceId string) (*NetworkInstance_Protocol_Isis_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Isis_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Isis_Interface struct to the
// list Interface of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendInterface(v *NetworkInstance_Protocol_Isis_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// DeleteLevel deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis) DeleteLevel(LevelNumber uint8) {
	key := LevelNumber

	delete(t.Level, key)
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Level struct to the
// list Level of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendLevel(v *NetworkInstance_Protocol_Isis_Level) error {
	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateGlobal() *NetworkInstance_Protocol_Isis_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Isis_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Isis. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetGlobal() *NetworkInstance_Protocol_Isis_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Global_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Global_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global) DeleteAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Global_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAf(v *NetworkInstance_Protocol_Isis_Global_Af) error {
	key := NetworkInstance_Protocol_Isis_Global_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewAfi creates a new entry in the Afi list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Afi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_OpenconfigIsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Afi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Afi", key)
	}

	t.Afi[key] = &NetworkInstance_Protocol_Isis_Global_Afi{
		AfiName: AfiName,
	}

	return t.Afi[key], nil
}

// RenameAfi renames an entry in the list Afi within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAfi(oldK, newK E_OpenconfigIsisTypes_AFI_TYPE) error {
	if _, ok := t.Afi[newK]; ok {
		return fmt.Errorf("key %v already exists in Afi", newK)
	}

	e, ok := t.Afi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Afi", oldK)
	}
	e.AfiName = newK

	t.Afi[newK] = e
	delete(t.Afi, oldK)
	return nil
}

// GetOrCreateAfi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	key := AfiName

	if v, ok := t.Afi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfi(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfi got unexpected error: %v", err))
	}
	return v
}

// GetAfi retrieves the value with the specified key from
// the Afi map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.Afi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global) DeleteAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) {
	key := AfiName

	delete(t.Afi, key)
}

// AppendAfi appends the supplied NetworkInstance_Protocol_Isis_Global_Afi struct to the
// list Afi of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Afi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAfi(v *NetworkInstance_Protocol_Isis_Global_Afi) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_OpenconfigIsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	if _, ok := t.Afi[key]; ok {
		return fmt.Errorf("duplicate key for list Afi %v", key)
	}

	t.Afi[key] = v
	return nil
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateInterLevelPropagationPolicies retrieves the value of the InterLevelPropagationPolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if t.InterLevelPropagationPolicies != nil {
		return t.InterLevelPropagationPolicies
	}
	t.InterLevelPropagationPolicies = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	return t.InterLevelPropagationPolicies
}

// GetOrCreateLspBit retrieves the value of the LspBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if t.LspBit != nil {
		return t.LspBit
	}
	t.LspBit = &NetworkInstance_Protocol_Isis_Global_LspBit{}
	return t.LspBit
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Isis_Global_Mpls{}
	return t.Mpls
}

// GetOrCreateNsr retrieves the value of the Nsr field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if t.Nsr != nil {
		return t.Nsr
	}
	t.Nsr = &NetworkInstance_Protocol_Isis_Global_Nsr{}
	return t.Nsr
}

// GetOrCreateReferenceBandwidth retrieves the value of the ReferenceBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if t.ReferenceBandwidth != nil {
		return t.ReferenceBandwidth
	}
	t.ReferenceBandwidth = &NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	return t.ReferenceBandwidth
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	return t.SegmentRouting
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Global_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_Protocol_Isis_Global_Transport{}
	return t.Transport
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetInterLevelPropagationPolicies returns the value of the InterLevelPropagationPolicies struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field InterLevelPropagationPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if t != nil && t.InterLevelPropagationPolicies != nil {
		return t.InterLevelPropagationPolicies
	}
	return nil
}

// GetLspBit returns the value of the LspBit struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field LspBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if t != nil && t.LspBit != nil {
		return t.LspBit
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetNsr returns the value of the Nsr struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Nsr is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if t != nil && t.Nsr != nil {
		return t.Nsr
	}
	return nil
}

// GetReferenceBandwidth returns the value of the ReferenceBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field ReferenceBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if t != nil && t.ReferenceBandwidth != nil {
		return t.ReferenceBandwidth
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if t.MultiTopology != nil {
		return t.MultiTopology
	}
	t.MultiTopology = &NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	return t.MultiTopology
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Global_Af. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if t != nil && t.MultiTopology != nil {
		return t.MultiTopology
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af_MultiTopology"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Afi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Afi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLevel1ToLevel2 retrieves the value of the Level1ToLevel2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if t.Level1ToLevel2 != nil {
		return t.Level1ToLevel2
	}
	t.Level1ToLevel2 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	return t.Level1ToLevel2
}

// GetOrCreateLevel2ToLevel1 retrieves the value of the Level2ToLevel1 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if t.Level2ToLevel1 != nil {
		return t.Level2ToLevel1
	}
	t.Level2ToLevel1 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	return t.Level2ToLevel1
}

// GetLevel1ToLevel2 returns the value of the Level1ToLevel2 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level1ToLevel2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if t != nil && t.Level1ToLevel2 != nil {
		return t.Level1ToLevel2
	}
	return nil
}

// GetLevel2ToLevel1 returns the value of the Level2ToLevel1 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level2ToLevel1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if t != nil && t.Level2ToLevel1 != nil {
		return t.Level2ToLevel1
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAttachedBit retrieves the value of the AttachedBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if t.AttachedBit != nil {
		return t.AttachedBit
	}
	t.AttachedBit = &NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	return t.AttachedBit
}

// GetOrCreateOverloadBit retrieves the value of the OverloadBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if t.OverloadBit != nil {
		return t.OverloadBit
	}
	t.OverloadBit = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	return t.OverloadBit
}

// GetAttachedBit returns the value of the AttachedBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field AttachedBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if t != nil && t.AttachedBit != nil {
		return t.AttachedBit
	}
	return nil
}

// GetOverloadBit returns the value of the OverloadBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field OverloadBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if t != nil && t.OverloadBit != nil {
		return t.OverloadBit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewResetTrigger creates a new entry in the ResetTrigger list of the
// NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) NewResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) (*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	key := ResetTrigger

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ResetTrigger[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ResetTrigger", key)
	}

	t.ResetTrigger[key] = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
		ResetTrigger: ResetTrigger,
	}

	return t.ResetTrigger[key], nil
}

// RenameResetTrigger renames an entry in the list ResetTrigger within
// the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) RenameResetTrigger(oldK, newK E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) error {
	if _, ok := t.ResetTrigger[newK]; ok {
		return fmt.Errorf("key %v already exists in ResetTrigger", newK)
	}

	e, ok := t.ResetTrigger[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ResetTrigger", oldK)
	}
	e.ResetTrigger = newK

	t.ResetTrigger[newK] = e
	delete(t.ResetTrigger, oldK)
	return nil
}

// GetOrCreateResetTrigger retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetOrCreateResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	key := ResetTrigger

	if v, ok := t.ResetTrigger[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResetTrigger(ResetTrigger)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResetTrigger got unexpected error: %v", err))
	}
	return v
}

// GetResetTrigger retrieves the value with the specified key from
// the ResetTrigger map field of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	if t == nil {
		return nil
	}

	key := ResetTrigger

	if lm, ok := t.ResetTrigger[key]; ok {
		return lm
	}
	return nil
}

// DeleteResetTrigger deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) DeleteResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) {
	key := ResetTrigger

	delete(t.ResetTrigger, key)
}

// AppendResetTrigger appends the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct to the
// list ResetTrigger of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) AppendResetTrigger(v *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) error {
	key := v.ResetTrigger

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	if _, ok := t.ResetTrigger[key]; ok {
		return fmt.Errorf("duplicate key for list ResetTrigger %v", key)
	}

	t.ResetTrigger[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"reset-trigger": t.ResetTrigger,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	t.IgpLdpSync = &NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	return t.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Isis_Global_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if t != nil && t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Nsr"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLspGeneration retrieves the value of the LspGeneration field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if t.LspGeneration != nil {
		return t.LspGeneration
	}
	t.LspGeneration = &NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	return t.LspGeneration
}

// GetOrCreateSpf retrieves the value of the Spf field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if t.Spf != nil {
		return t.Spf
	}
	t.Spf = &NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	return t.Spf
}

// GetLspGeneration returns the value of the LspGeneration struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field LspGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if t != nil && t.LspGeneration != nil {
		return t.LspGeneration
	}
	return nil
}

// GetSpf returns the value of the Spf struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field Spf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if t != nil && t.Spf != nil {
		return t.Spf
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_Spf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface) DeleteAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Interface_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Interface_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// DeleteLevel deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface) DeleteLevel(LevelNumber uint8) {
	key := LevelNumber

	delete(t.Level, key)
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Interface_Level struct to the
// list Level of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendLevel(v *NetworkInstance_Protocol_Isis_Interface_Level) error {
	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Interface_Authentication{}
	return t.Authentication
}

// GetOrCreateBfd retrieves the value of the Bfd field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if t.Bfd != nil {
		return t.Bfd
	}
	t.Bfd = &NetworkInstance_Protocol_Isis_Interface_Bfd{}
	return t.Bfd
}

// GetOrCreateCircuitCounters retrieves the value of the CircuitCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if t.CircuitCounters != nil {
		return t.CircuitCounters
	}
	t.CircuitCounters = &NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	return t.CircuitCounters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Interface_Timers{}
	return t.Timers
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetBfd returns the value of the Bfd struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Bfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if t != nil && t.Bfd != nil {
		return t.Bfd
	}
	return nil
}

// GetCircuitCounters returns the value of the CircuitCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field CircuitCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if t != nil && t.CircuitCounters != nil {
		return t.CircuitCounters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Interface_Authentication_Key {
	if t.Key != nil {
		return t.Key
	}
	t.Key = &NetworkInstance_Protocol_Isis_Interface_Authentication_Key{}
	return t.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain {
	if t.Keychain != nil {
		return t.Keychain
	}
	t.Keychain = &NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain{}
	return t.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Authentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetKey() *NetworkInstance_Protocol_Isis_Interface_Authentication_Key {
	if t != nil && t.Key != nil {
		return t.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Authentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetKeychain() *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain {
	if t != nil && t.Keychain != nil {
		return t.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_CircuitCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacency creates a new entry in the Adjacency list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAdjacency(SystemId string) (*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Adjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Adjacency", key)
	}

	t.Adjacency[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
		SystemId: &SystemId,
	}

	return t.Adjacency[key], nil
}

// RenameAdjacency renames an entry in the list Adjacency within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAdjacency(oldK, newK string) error {
	if _, ok := t.Adjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in Adjacency", newK)
	}

	e, ok := t.Adjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Adjacency", oldK)
	}
	e.SystemId = &newK

	t.Adjacency[newK] = e
	delete(t.Adjacency, oldK)
	return nil
}

// GetOrCreateAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	key := SystemId

	if v, ok := t.Adjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacency(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetAdjacency retrieves the value with the specified key from
// the Adjacency map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Adjacency[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacency deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) DeleteAdjacency(SystemId string) {
	key := SystemId

	delete(t.Adjacency, key)
}

// AppendAdjacency appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct to the
// list Adjacency of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAdjacency(v *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	if _, ok := t.Adjacency[key]; ok {
		return fmt.Errorf("duplicate key for list Adjacency %v", key)
	}

	t.Adjacency[key] = v
	return nil
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Level_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) DeleteAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Level_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// GetOrCreateHelloAuthentication retrieves the value of the HelloAuthentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if t.HelloAuthentication != nil {
		return t.HelloAuthentication
	}
	t.HelloAuthentication = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	return t.HelloAuthentication
}

// GetOrCreatePacketCounters retrieves the value of the PacketCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreatePacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if t.PacketCounters != nil {
		return t.PacketCounters
	}
	t.PacketCounters = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	return t.PacketCounters
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	return t.Timers
}

// GetHelloAuthentication returns the value of the HelloAuthentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field HelloAuthentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if t != nil && t.HelloAuthentication != nil {
		return t.HelloAuthentication
	}
	return nil
}

// GetPacketCounters returns the value of the PacketCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field PacketCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetPacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if t != nil && t.PacketCounters != nil {
		return t.PacketCounters
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Adjacency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	return t.SegmentRouting
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_Af. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
		Neighbor: &Neighbor,
		SidId:    SidId,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenameAdjacencySid(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Neighbor = &newK.Neighbor
	e.SidId = newK.SidId

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreateAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Neighbor, SidId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) DeleteAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) error {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{Neighbor: *v.Neighbor, SidId: v.SidId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewPrefixSid(Prefix string) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
		Prefix: &Prefix,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenamePrefixSid(oldK, newK string) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Prefix = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreatePrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	key := Prefix

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetPrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) DeletePrefixSid(Prefix string) {
	key := Prefix

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"sid-id":   t.SidId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key {
	if t.Key != nil {
		return t.Key
	}
	t.Key = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key{}
	return t.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain {
	if t.Keychain != nil {
		return t.Keychain
	}
	t.Keychain = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain{}
	return t.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetKey() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key {
	if t != nil && t.Key != nil {
		return t.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetKeychain() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain {
	if t != nil && t.Keychain != nil {
		return t.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateCsnp retrieves the value of the Csnp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if t.Csnp != nil {
		return t.Csnp
	}
	t.Csnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	return t.Csnp
}

// GetOrCreateEsh retrieves the value of the Esh field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if t.Esh != nil {
		return t.Esh
	}
	t.Esh = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	return t.Esh
}

// GetOrCreateIih retrieves the value of the Iih field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if t.Iih != nil {
		return t.Iih
	}
	t.Iih = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	return t.Iih
}

// GetOrCreateIsh retrieves the value of the Ish field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if t.Ish != nil {
		return t.Ish
	}
	t.Ish = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	return t.Ish
}

// GetOrCreateLsp retrieves the value of the Lsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if t.Lsp != nil {
		return t.Lsp
	}
	t.Lsp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	return t.Lsp
}

// GetOrCreatePsnp retrieves the value of the Psnp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreatePsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if t.Psnp != nil {
		return t.Psnp
	}
	t.Psnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	return t.Psnp
}

// GetOrCreateUnknown retrieves the value of the Unknown field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if t.Unknown != nil {
		return t.Unknown
	}
	t.Unknown = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	return t.Unknown
}

// GetCsnp returns the value of the Csnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Csnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if t != nil && t.Csnp != nil {
		return t.Csnp
	}
	return nil
}

// GetEsh returns the value of the Esh struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Esh is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if t != nil && t.Esh != nil {
		return t.Esh
	}
	return nil
}

// GetIih returns the value of the Iih struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Iih is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if t != nil && t.Iih != nil {
		return t.Iih
	}
	return nil
}

// GetIsh returns the value of the Ish struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Ish is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if t != nil && t.Ish != nil {
		return t.Ish
	}
	return nil
}

// GetLsp returns the value of the Lsp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Lsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if t != nil && t.Lsp != nil {
		return t.Lsp
	}
	return nil
}

// GetPsnp returns the value of the Psnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Psnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetPsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if t != nil && t.Psnp != nil {
		return t.Psnp
	}
	return nil
}

// GetUnknown returns the value of the Unknown struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Unknown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if t != nil && t.Unknown != nil {
		return t.Unknown
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsp creates a new entry in the Lsp list of the
// NetworkInstance_Protocol_Isis_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level) NewLsp(LspId string) (*NetworkInstance_Protocol_Isis_Level_Lsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	key := LspId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsp", key)
	}

	t.Lsp[key] = &NetworkInstance_Protocol_Isis_Level_Lsp{
		LspId: &LspId,
	}

	return t.Lsp[key], nil
}

// RenameLsp renames an entry in the list Lsp within
// the NetworkInstance_Protocol_Isis_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level) RenameLsp(oldK, newK string) error {
	if _, ok := t.Lsp[newK]; ok {
		return fmt.Errorf("key %v already exists in Lsp", newK)
	}

	e, ok := t.Lsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lsp", oldK)
	}
	e.LspId = &newK

	t.Lsp[newK] = e
	delete(t.Lsp, oldK)
	return nil
}

// GetOrCreateLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	key := LspId

	if v, ok := t.Lsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsp(LspId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsp got unexpected error: %v", err))
	}
	return v
}

// GetLsp retrieves the value with the specified key from
// the Lsp map field of NetworkInstance_Protocol_Isis_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	if t == nil {
		return nil
	}

	key := LspId

	if lm, ok := t.Lsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level) DeleteLsp(LspId string) {
	key := LspId

	delete(t.Lsp, key)
}

// AppendLsp appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp struct to the
// list Lsp of NetworkInstance_Protocol_Isis_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level) AppendLsp(v *NetworkInstance_Protocol_Isis_Level_Lsp) error {
	key := *v.LspId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	if _, ok := t.Lsp[key]; ok {
		return fmt.Errorf("duplicate key for list Lsp %v", key)
	}

	t.Lsp[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Level_Authentication{}
	return t.Authentication
}

// GetOrCreateRoutePreference retrieves the value of the RoutePreference field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if t.RoutePreference != nil {
		return t.RoutePreference
	}
	t.RoutePreference = &NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	return t.RoutePreference
}

// GetOrCreateSystemLevelCounters retrieves the value of the SystemLevelCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if t.SystemLevelCounters != nil {
		return t.SystemLevelCounters
	}
	t.SystemLevelCounters = &NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	return t.SystemLevelCounters
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	t.TrafficEngineering = &NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	return t.TrafficEngineering
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetRoutePreference returns the value of the RoutePreference struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field RoutePreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if t != nil && t.RoutePreference != nil {
		return t.RoutePreference
	}
	return nil
}

// GetSystemLevelCounters returns the value of the SystemLevelCounters struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field SystemLevelCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if t != nil && t.SystemLevelCounters != nil {
		return t.SystemLevelCounters
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if t != nil && t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Level_Authentication_Key {
	if t.Key != nil {
		return t.Key
	}
	t.Key = &NetworkInstance_Protocol_Isis_Level_Authentication_Key{}
	return t.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain {
	if t.Keychain != nil {
		return t.Keychain
	}
	t.Keychain = &NetworkInstance_Protocol_Isis_Level_Authentication_Keychain{}
	return t.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Level_Authentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetKey() *NetworkInstance_Protocol_Isis_Level_Authentication_Key {
	if t != nil && t.Key != nil {
		return t.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Level_Authentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetKeychain() *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain {
	if t != nil && t.Keychain != nil {
		return t.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication_Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTlv creates a new entry in the Tlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
		Type: Type,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameTlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = newK

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	key := Type

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) DeleteTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) {
	key := Type

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct to the
// list Tlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// NewUndefinedTlv creates a new entry in the UndefinedTlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewUndefinedTlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedTlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedTlv", key)
	}

	t.UndefinedTlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
		Type: &Type,
	}

	return t.UndefinedTlv[key], nil
}

// RenameUndefinedTlv renames an entry in the list UndefinedTlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameUndefinedTlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedTlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedTlv", newK)
	}

	e, ok := t.UndefinedTlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedTlv", oldK)
	}
	e.Type = &newK

	t.UndefinedTlv[newK] = e
	delete(t.UndefinedTlv, oldK)
	return nil
}

// GetOrCreateUndefinedTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	key := Type

	if v, ok := t.UndefinedTlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedTlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedTlv retrieves the value with the specified key from
// the UndefinedTlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedTlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedTlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) DeleteUndefinedTlv(Type uint8) {
	key := Type

	delete(t.UndefinedTlv, key)
}

// AppendUndefinedTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv struct to the
// list UndefinedTlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendUndefinedTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	if _, ok := t.UndefinedTlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedTlv %v", key)
	}

	t.UndefinedTlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LspId == nil {
		return nil, fmt.Errorf("nil value for key LspId")
	}

	return map[string]interface{}{
		"lsp-id": *t.LspId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewCapability creates a new entry in the Capability list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewCapability(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
		InstanceNumber: &InstanceNumber,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameCapability(oldK, newK uint32) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.InstanceNumber = &newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	key := InstanceNumber

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteCapability(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Capability, key)
}

// AppendCapability appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct to the
// list Capability of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendCapability(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewInstanceId creates a new entry in the InstanceId list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewInstanceId(InstanceId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	key := InstanceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InstanceId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InstanceId", key)
	}

	t.InstanceId[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId{
		InstanceId: &InstanceId,
	}

	return t.InstanceId[key], nil
}

// RenameInstanceId renames an entry in the list InstanceId within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameInstanceId(oldK, newK uint16) error {
	if _, ok := t.InstanceId[newK]; ok {
		return fmt.Errorf("key %v already exists in InstanceId", newK)
	}

	e, ok := t.InstanceId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InstanceId", oldK)
	}
	e.InstanceId = &newK

	t.InstanceId[newK] = e
	delete(t.InstanceId, oldK)
	return nil
}

// GetOrCreateInstanceId retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	key := InstanceId

	if v, ok := t.InstanceId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstanceId(InstanceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstanceId got unexpected error: %v", err))
	}
	return v
}

// GetInstanceId retrieves the value with the specified key from
// the InstanceId map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	if t == nil {
		return nil
	}

	key := InstanceId

	if lm, ok := t.InstanceId[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstanceId deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteInstanceId(InstanceId uint16) {
	key := InstanceId

	delete(t.InstanceId, key)
}

// AppendInstanceId appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId struct to the
// list InstanceId of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendInstanceId(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) error {
	key := *v.InstanceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	if _, ok := t.InstanceId[key]; ok {
		return fmt.Errorf("duplicate key for list InstanceId %v", key)
	}

	t.InstanceId[key] = v
	return nil
}

// NewIpv4Srlg creates a new entry in the Ipv4Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv4Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Srlg", key)
	}

	t.Ipv4Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv4Srlg[key], nil
}

// RenameIpv4Srlg renames an entry in the list Ipv4Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv4Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv4Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Srlg", newK)
	}

	e, ok := t.Ipv4Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv4Srlg[newK] = e
	delete(t.Ipv4Srlg, oldK)
	return nil
}

// GetOrCreateIpv4Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv4Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Srlg retrieves the value with the specified key from
// the Ipv4Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv4Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Srlg deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteIpv4Srlg(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Ipv4Srlg, key)
}

// AppendIpv4Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg struct to the
// list Ipv4Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv4Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	if _, ok := t.Ipv4Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Srlg %v", key)
	}

	t.Ipv4Srlg[key] = v
	return nil
}

// NewIpv6Srlg creates a new entry in the Ipv6Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv6Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Srlg", key)
	}

	t.Ipv6Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv6Srlg[key], nil
}

// RenameIpv6Srlg renames an entry in the list Ipv6Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv6Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv6Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Srlg", newK)
	}

	e, ok := t.Ipv6Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv6Srlg[newK] = e
	delete(t.Ipv6Srlg, oldK)
	return nil
}

// GetOrCreateIpv6Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv6Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Srlg retrieves the value with the specified key from
// the Ipv6Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv6Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Srlg deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteIpv6Srlg(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Ipv6Srlg, key)
}

// AppendIpv6Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg struct to the
// list Ipv6Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv6Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	if _, ok := t.Ipv6Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Srlg %v", key)
	}

	t.Ipv6Srlg[key] = v
	return nil
}

// GetOrCreateAreaAddress retrieves the value of the AreaAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if t.AreaAddress != nil {
		return t.AreaAddress
	}
	t.AreaAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	return t.AreaAddress
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	return t.Authentication
}

// GetOrCreateExtendedIpv4Reachability retrieves the value of the ExtendedIpv4Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	t.ExtendedIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	return t.ExtendedIpv4Reachability
}

// GetOrCreateExtendedIsReachability retrieves the value of the ExtendedIsReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	t.ExtendedIsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability{}
	return t.ExtendedIsReachability
}

// GetOrCreateHostname retrieves the value of the Hostname field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if t.Hostname != nil {
		return t.Hostname
	}
	t.Hostname = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname{}
	return t.Hostname
}

// GetOrCreateIpv4ExternalReachability retrieves the value of the Ipv4ExternalReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	t.Ipv4ExternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability{}
	return t.Ipv4ExternalReachability
}

// GetOrCreateIpv4InterfaceAddresses retrieves the value of the Ipv4InterfaceAddresses field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if t.Ipv4InterfaceAddresses != nil {
		return t.Ipv4InterfaceAddresses
	}
	t.Ipv4InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses{}
	return t.Ipv4InterfaceAddresses
}

// GetOrCreateIpv4InternalReachability retrieves the value of the Ipv4InternalReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	t.Ipv4InternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability{}
	return t.Ipv4InternalReachability
}

// GetOrCreateIpv4TeRouterId retrieves the value of the Ipv4TeRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if t.Ipv4TeRouterId != nil {
		return t.Ipv4TeRouterId
	}
	t.Ipv4TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId{}
	return t.Ipv4TeRouterId
}

// GetOrCreateIpv6InterfaceAddresses retrieves the value of the Ipv6InterfaceAddresses field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if t.Ipv6InterfaceAddresses != nil {
		return t.Ipv6InterfaceAddresses
	}
	t.Ipv6InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses{}
	return t.Ipv6InterfaceAddresses
}

// GetOrCreateIpv6Reachability retrieves the value of the Ipv6Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	t.Ipv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability{}
	return t.Ipv6Reachability
}

// GetOrCreateIpv6TeRouterId retrieves the value of the Ipv6TeRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if t.Ipv6TeRouterId != nil {
		return t.Ipv6TeRouterId
	}
	t.Ipv6TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId{}
	return t.Ipv6TeRouterId
}

// GetOrCreateIsAliasId retrieves the value of the IsAliasId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if t.IsAliasId != nil {
		return t.IsAliasId
	}
	t.IsAliasId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId{}
	return t.IsAliasId
}

// GetOrCreateIsReachability retrieves the value of the IsReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if t.IsReachability != nil {
		return t.IsReachability
	}
	t.IsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability{}
	return t.IsReachability
}

// GetOrCreateIsisNeighborAttribute retrieves the value of the IsisNeighborAttribute field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if t.IsisNeighborAttribute != nil {
		return t.IsisNeighborAttribute
	}
	t.IsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute{}
	return t.IsisNeighborAttribute
}

// GetOrCreateLspBufferSize retrieves the value of the LspBufferSize field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if t.LspBufferSize != nil {
		return t.LspBufferSize
	}
	t.LspBufferSize = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize{}
	return t.LspBufferSize
}

// GetOrCreateMtIpv4Reachability retrieves the value of the MtIpv4Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if t.MtIpv4Reachability != nil {
		return t.MtIpv4Reachability
	}
	t.MtIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability{}
	return t.MtIpv4Reachability
}

// GetOrCreateMtIpv6Reachability retrieves the value of the MtIpv6Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if t.MtIpv6Reachability != nil {
		return t.MtIpv6Reachability
	}
	t.MtIpv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability{}
	return t.MtIpv6Reachability
}

// GetOrCreateMtIsisNeighborAttribute retrieves the value of the MtIsisNeighborAttribute field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if t.MtIsisNeighborAttribute != nil {
		return t.MtIsisNeighborAttribute
	}
	t.MtIsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute{}
	return t.MtIsisNeighborAttribute
}

// GetOrCreateMtIsn retrieves the value of the MtIsn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if t.MtIsn != nil {
		return t.MtIsn
	}
	t.MtIsn = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn{}
	return t.MtIsn
}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if t.MultiTopology != nil {
		return t.MultiTopology
	}
	t.MultiTopology = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	return t.MultiTopology
}

// GetOrCreateNlpid retrieves the value of the Nlpid field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if t.Nlpid != nil {
		return t.Nlpid
	}
	t.Nlpid = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	return t.Nlpid
}

// GetOrCreatePurgeOi retrieves the value of the PurgeOi field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreatePurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if t.PurgeOi != nil {
		return t.PurgeOi
	}
	t.PurgeOi = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	return t.PurgeOi
}

// GetAreaAddress returns the value of the AreaAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field AreaAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if t != nil && t.AreaAddress != nil {
		return t.AreaAddress
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetExtendedIpv4Reachability returns the value of the ExtendedIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if t != nil && t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	return nil
}

// GetExtendedIsReachability returns the value of the ExtendedIsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if t != nil && t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	return nil
}

// GetHostname returns the value of the Hostname struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Hostname is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if t != nil && t.Hostname != nil {
		return t.Hostname
	}
	return nil
}

// GetIpv4ExternalReachability returns the value of the Ipv4ExternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4ExternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if t != nil && t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	return nil
}

// GetIpv4InterfaceAddresses returns the value of the Ipv4InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if t != nil && t.Ipv4InterfaceAddresses != nil {
		return t.Ipv4InterfaceAddresses
	}
	return nil
}

// GetIpv4InternalReachability returns the value of the Ipv4InternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if t != nil && t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	return nil
}

// GetIpv4TeRouterId returns the value of the Ipv4TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if t != nil && t.Ipv4TeRouterId != nil {
		return t.Ipv4TeRouterId
	}
	return nil
}

// GetIpv6InterfaceAddresses returns the value of the Ipv6InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if t != nil && t.Ipv6InterfaceAddresses != nil {
		return t.Ipv6InterfaceAddresses
	}
	return nil
}

// GetIpv6Reachability returns the value of the Ipv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if t != nil && t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	return nil
}

// GetIpv6TeRouterId returns the value of the Ipv6TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if t != nil && t.Ipv6TeRouterId != nil {
		return t.Ipv6TeRouterId
	}
	return nil
}

// GetIsAliasId returns the value of the IsAliasId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsAliasId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if t != nil && t.IsAliasId != nil {
		return t.IsAliasId
	}
	return nil
}

// GetIsReachability returns the value of the IsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if t != nil && t.IsReachability != nil {
		return t.IsReachability
	}
	return nil
}

// GetIsisNeighborAttribute returns the value of the IsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if t != nil && t.IsisNeighborAttribute != nil {
		return t.IsisNeighborAttribute
	}
	return nil
}

// GetLspBufferSize returns the value of the LspBufferSize struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field LspBufferSize is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if t != nil && t.LspBufferSize != nil {
		return t.LspBufferSize
	}
	return nil
}

// GetMtIpv4Reachability returns the value of the MtIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if t != nil && t.MtIpv4Reachability != nil {
		return t.MtIpv4Reachability
	}
	return nil
}

// GetMtIpv6Reachability returns the value of the MtIpv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if t != nil && t.MtIpv6Reachability != nil {
		return t.MtIpv6Reachability
	}
	return nil
}

// GetMtIsisNeighborAttribute returns the value of the MtIsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if t != nil && t.MtIsisNeighborAttribute != nil {
		return t.MtIsisNeighborAttribute
	}
	return nil
}

// GetMtIsn returns the value of the MtIsn struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if t != nil && t.MtIsn != nil {
		return t.MtIsn
	}
	return nil
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if t != nil && t.MultiTopology != nil {
		return t.MultiTopology
	}
	return nil
}

// GetNlpid returns the value of the Nlpid struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Nlpid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if t != nil && t.Nlpid != nil {
		return t.Nlpid
	}
	return nil
}

// GetPurgeOi returns the value of the PurgeOi struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field PurgeOi is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetPurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if t != nil && t.PurgeOi != nil {
		return t.PurgeOi
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSegmentRoutingAlgorithms retrieves the value of the SegmentRoutingAlgorithms field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if t.SegmentRoutingAlgorithms != nil {
		return t.SegmentRoutingAlgorithms
	}
	t.SegmentRoutingAlgorithms = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	return t.SegmentRoutingAlgorithms
}

// GetOrCreateSegmentRoutingCapability retrieves the value of the SegmentRoutingCapability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if t.SegmentRoutingCapability != nil {
		return t.SegmentRoutingCapability
	}
	t.SegmentRoutingCapability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	return t.SegmentRoutingCapability
}

// GetSegmentRoutingAlgorithms returns the value of the SegmentRoutingAlgorithms struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingAlgorithms is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if t != nil && t.SegmentRoutingAlgorithms != nil {
		return t.SegmentRoutingAlgorithms
	}
	return nil
}

// GetSegmentRoutingCapability returns the value of the SegmentRoutingCapability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingCapability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if t != nil && t.SegmentRoutingCapability != nil {
		return t.SegmentRoutingCapability
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSrgbDescriptor creates a new entry in the SrgbDescriptor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) NewSrgbDescriptor(Range uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	key := Range

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SrgbDescriptor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SrgbDescriptor", key)
	}

	t.SrgbDescriptor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
		Range: &Range,
	}

	return t.SrgbDescriptor[key], nil
}

// RenameSrgbDescriptor renames an entry in the list SrgbDescriptor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) RenameSrgbDescriptor(oldK, newK uint32) error {
	if _, ok := t.SrgbDescriptor[newK]; ok {
		return fmt.Errorf("key %v already exists in SrgbDescriptor", newK)
	}

	e, ok := t.SrgbDescriptor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SrgbDescriptor", oldK)
	}
	e.Range = &newK

	t.SrgbDescriptor[newK] = e
	delete(t.SrgbDescriptor, oldK)
	return nil
}

// GetOrCreateSrgbDescriptor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetOrCreateSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	key := Range

	if v, ok := t.SrgbDescriptor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrgbDescriptor(Range)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrgbDescriptor got unexpected error: %v", err))
	}
	return v
}

// GetSrgbDescriptor retrieves the value with the specified key from
// the SrgbDescriptor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	if t == nil {
		return nil
	}

	key := Range

	if lm, ok := t.SrgbDescriptor[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrgbDescriptor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) DeleteSrgbDescriptor(Range uint32) {
	key := Range

	delete(t.SrgbDescriptor, key)
}

// AppendSrgbDescriptor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct to the
// list SrgbDescriptor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) AppendSrgbDescriptor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) error {
	key := *v.Range

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	if _, ok := t.SrgbDescriptor[key]; ok {
		return fmt.Errorf("duplicate key for list SrgbDescriptor %v", key)
	}

	t.SrgbDescriptor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Range == nil {
		return nil, fmt.Errorf("nil value for key Range")
	}

	return map[string]interface{}{
		"range": *t.Range,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) DeletePrefixSid(Value uint32) {
	key := Value

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if t.Flags != nil {
		return t.Flags
	}
	t.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	return t.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	t.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return t.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	t.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return t.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if t.Tag != nil {
		return t.Tag
	}
	t.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag{}
	return t.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t.Tag64 != nil {
		return t.Tag64
	}
	t.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64{}
	return t.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if t != nil && t.Flags != nil {
		return t.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t != nil && t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t != nil && t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if t != nil && t.Tag != nil {
		return t.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t != nil && t.Tag64 != nil {
		return t.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInstance creates a new entry in the Instance list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) NewInstance(Id uint64) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance{
		Id: &Id,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) RenameInstance(oldK, newK uint64) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Id = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetOrCreateInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance {

	key := Id

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) DeleteInstance(Id uint64) {
	key := Id

	delete(t.Instance, key)
}

// AppendInstance appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct to the
// list Instance of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) AppendInstance(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteAdjacencySid(Value uint32) {
	key := Value

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteBandwidthConstraint(ModelId uint8) {
	key := ModelId

	delete(t.BandwidthConstraint, key)
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLanAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteLanAdjacencySid(Value uint32) {
	key := Value

	delete(t.LanAdjacencySid, key)
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// DeleteSetupPriority deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteSetupPriority(Priority uint8) {
	key := Priority

	delete(t.SetupPriority, key)
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup {
	if t.AdminGroup != nil {
		return t.AdminGroup
	}
	t.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup{}
	return t.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	t.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	return t.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	t.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	return t.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	t.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	return t.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	t.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	return t.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	t.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	return t.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	t.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	return t.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes {
	if t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	t.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes{}
	return t.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay {
	if t.LinkDelay != nil {
		return t.LinkDelay
	}
	t.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay{}
	return t.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	t.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	return t.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId {
	if t.LinkId != nil {
		return t.LinkId
	}
	t.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId{}
	return t.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss {
	if t.LinkLoss != nil {
		return t.LinkLoss
	}
	t.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss{}
	return t.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	t.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType{}
	return t.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	t.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	return t.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	t.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	return t.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	t.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	return t.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	t.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	return t.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	t.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	return t.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	t.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	return t.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	t.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	return t.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup {
	if t != nil && t.AdminGroup != nil {
		return t.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t != nil && t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t != nil && t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t != nil && t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t != nil && t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t != nil && t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t != nil && t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes {
	if t != nil && t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay {
	if t != nil && t.LinkDelay != nil {
		return t.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t != nil && t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId {
	if t != nil && t.LinkId != nil {
		return t.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss {
	if t != nil && t.LinkLoss != nil {
		return t.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t != nil && t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t != nil && t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t != nil && t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t != nil && t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t != nil && t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t != nil && t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t != nil && t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t != nil && t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) DeleteConstraint(ConstraintId uint32) {
	key := ConstraintId

	delete(t.Constraint, key)
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceId == nil {
		return nil, fmt.Errorf("nil value for key InstanceId")
	}

	return map[string]interface{}{
		"instance-id": *t.InstanceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric {
	if t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	t.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric{}
	return t.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric {
	if t.DelayMetric != nil {
		return t.DelayMetric
	}
	t.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric{}
	return t.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric {
	if t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	t.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric{}
	return t.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric {
	if t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	t.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric{}
	return t.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric {
	if t != nil && t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric {
	if t != nil && t.DelayMetric != nil {
		return t.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric {
	if t != nil && t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric {
	if t != nil && t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric {
	if t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	t.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric{}
	return t.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric {
	if t.DelayMetric != nil {
		return t.DelayMetric
	}
	t.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric{}
	return t.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric {
	if t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	t.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric{}
	return t.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric {
	if t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	t.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric{}
	return t.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric {
	if t != nil && t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric {
	if t != nil && t.DelayMetric != nil {
		return t.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric {
	if t != nil && t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric {
	if t != nil && t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) DeletePrefixSid(Value uint32) {
	key := Value

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags {
	if t.Flags != nil {
		return t.Flags
	}
	t.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags{}
	return t.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	t.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return t.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	t.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return t.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag {
	if t.Tag != nil {
		return t.Tag
	}
	t.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag{}
	return t.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64 {
	if t.Tag64 != nil {
		return t.Tag64
	}
	t.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64{}
	return t.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags {
	if t != nil && t.Flags != nil {
		return t.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t != nil && t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t != nil && t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag {
	if t != nil && t.Tag != nil {
		return t.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64 {
	if t != nil && t.Tag64 != nil {
		return t.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric {
	if t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	t.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric{}
	return t.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric {
	if t.DelayMetric != nil {
		return t.DelayMetric
	}
	t.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric{}
	return t.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric {
	if t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	t.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric{}
	return t.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric {
	if t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	t.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric{}
	return t.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric {
	if t != nil && t.DefaultMetric != nil {
		return t.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric {
	if t != nil && t.DelayMetric != nil {
		return t.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric {
	if t != nil && t.ErrorMetric != nil {
		return t.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric {
	if t != nil && t.ExpenseMetric != nil {
		return t.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInstance creates a new entry in the Instance list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) NewInstance(Id uint64) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance{
		Id: &Id,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) RenameInstance(oldK, newK uint64) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Id = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetOrCreateInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance {

	key := Id

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) DeleteInstance(Id uint64) {
	key := Id

	delete(t.Instance, key)
}

// AppendInstance appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct to the
// list Instance of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) AppendInstance(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteAdjacencySid(Value uint32) {
	key := Value

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteBandwidthConstraint(ModelId uint8) {
	key := ModelId

	delete(t.BandwidthConstraint, key)
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLanAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteLanAdjacencySid(Value uint32) {
	key := Value

	delete(t.LanAdjacencySid, key)
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// DeleteSetupPriority deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteSetupPriority(Priority uint8) {
	key := Priority

	delete(t.SetupPriority, key)
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup {
	if t.AdminGroup != nil {
		return t.AdminGroup
	}
	t.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup{}
	return t.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	t.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	return t.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	t.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	return t.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	t.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	return t.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	t.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	return t.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	t.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	return t.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	t.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	return t.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes {
	if t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	t.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes{}
	return t.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay {
	if t.LinkDelay != nil {
		return t.LinkDelay
	}
	t.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay{}
	return t.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	t.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	return t.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId {
	if t.LinkId != nil {
		return t.LinkId
	}
	t.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId{}
	return t.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss {
	if t.LinkLoss != nil {
		return t.LinkLoss
	}
	t.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss{}
	return t.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	t.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType{}
	return t.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	t.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	return t.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	t.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	return t.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	t.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	return t.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	t.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	return t.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	t.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	return t.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	t.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	return t.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	t.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	return t.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup {
	if t != nil && t.AdminGroup != nil {
		return t.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t != nil && t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t != nil && t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t != nil && t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t != nil && t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t != nil && t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t != nil && t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes {
	if t != nil && t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay {
	if t != nil && t.LinkDelay != nil {
		return t.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t != nil && t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId {
	if t != nil && t.LinkId != nil {
		return t.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss {
	if t != nil && t.LinkLoss != nil {
		return t.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t != nil && t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t != nil && t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t != nil && t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t != nil && t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t != nil && t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t != nil && t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t != nil && t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t != nil && t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) DeleteConstraint(ConstraintId uint32) {
	key := ConstraintId

	delete(t.Constraint, key)
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) NewPrefix(MtId uint16, Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix{
		MtId:   &MtId,
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) RenamePrefix(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.MtId = &newK.MtId
	e.Prefix = &newK.Prefix

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) GetOrCreatePrefix(MtId uint16, Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(MtId, Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) GetPrefix(MtId uint16, Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) DeletePrefix(MtId uint16, Prefix string) {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{MtId: *v.MtId, Prefix: *v.Prefix}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"mt-id":  *t.MtId,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) DeletePrefixSid(Value uint32) {
	key := Value

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags {
	if t.Flags != nil {
		return t.Flags
	}
	t.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags{}
	return t.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	t.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return t.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	t.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return t.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag {
	if t.Tag != nil {
		return t.Tag
	}
	t.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag{}
	return t.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t.Tag64 != nil {
		return t.Tag64
	}
	t.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64{}
	return t.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags {
	if t != nil && t.Flags != nil {
		return t.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t != nil && t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t != nil && t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag {
	if t != nil && t.Tag != nil {
		return t.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t != nil && t.Tag64 != nil {
		return t.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) NewPrefix(Prefix string, MtId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix{
		Prefix: &Prefix,
		MtId:   &MtId,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) RenamePrefix(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK.Prefix
	e.MtId = &newK.MtId

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) GetOrCreatePrefix(Prefix string, MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix, MtId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) GetPrefix(Prefix string, MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) DeletePrefix(Prefix string, MtId uint16) {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{Prefix: *v.Prefix, MtId: *v.MtId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"mt-id":  *t.MtId,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) DeletePrefixSid(Value uint32) {
	key := Value

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags {
	if t.Flags != nil {
		return t.Flags
	}
	t.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags{}
	return t.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	t.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return t.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	t.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return t.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag {
	if t.Tag != nil {
		return t.Tag
	}
	t.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag{}
	return t.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64 {
	if t.Tag64 != nil {
		return t.Tag64
	}
	t.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64{}
	return t.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags {
	if t != nil && t.Flags != nil {
		return t.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t != nil && t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t != nil && t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag {
	if t != nil && t.Tag != nil {
		return t.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64 {
	if t != nil && t.Tag64 != nil {
		return t.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) NewNeighbor(MtId uint16, SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor{
		MtId:     &MtId,
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) RenameNeighbor(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.MtId = &newK.MtId
	e.SystemId = &newK.SystemId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) GetOrCreateNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(MtId, SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) GetNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) DeleteNeighbor(MtId uint16, SystemId string) {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{MtId: *v.MtId, SystemId: *v.SystemId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInstance creates a new entry in the Instance list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) NewInstance(Id uint64) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance{
		Id: &Id,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) RenameInstance(oldK, newK uint64) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Id = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetOrCreateInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance {

	key := Id

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) DeleteInstance(Id uint64) {
	key := Id

	delete(t.Instance, key)
}

// AppendInstance appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct to the
// list Instance of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) AppendInstance(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"mt-id":     *t.MtId,
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteAdjacencySid(Value uint32) {
	key := Value

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteBandwidthConstraint(ModelId uint8) {
	key := ModelId

	delete(t.BandwidthConstraint, key)
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLanAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteLanAdjacencySid(Value uint32) {
	key := Value

	delete(t.LanAdjacencySid, key)
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// DeleteSetupPriority deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) DeleteSetupPriority(Priority uint8) {
	key := Priority

	delete(t.SetupPriority, key)
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup {
	if t.AdminGroup != nil {
		return t.AdminGroup
	}
	t.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup{}
	return t.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	t.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	return t.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	t.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	return t.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	t.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	return t.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	t.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	return t.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	t.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	return t.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	t.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	return t.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes {
	if t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	t.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes{}
	return t.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay {
	if t.LinkDelay != nil {
		return t.LinkDelay
	}
	t.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay{}
	return t.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	t.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	return t.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId {
	if t.LinkId != nil {
		return t.LinkId
	}
	t.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId{}
	return t.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss {
	if t.LinkLoss != nil {
		return t.LinkLoss
	}
	t.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss{}
	return t.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	t.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType{}
	return t.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	t.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	return t.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	t.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	return t.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	t.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	return t.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	t.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	return t.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	t.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	return t.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	t.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	return t.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	t.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	return t.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup {
	if t != nil && t.AdminGroup != nil {
		return t.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t != nil && t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t != nil && t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t != nil && t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t != nil && t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t != nil && t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t != nil && t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes {
	if t != nil && t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay {
	if t != nil && t.LinkDelay != nil {
		return t.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t != nil && t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId {
	if t != nil && t.LinkId != nil {
		return t.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss {
	if t != nil && t.LinkLoss != nil {
		return t.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t != nil && t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t != nil && t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t != nil && t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t != nil && t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t != nil && t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t != nil && t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t != nil && t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t != nil && t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) DeleteConstraint(ConstraintId uint32) {
	key := ConstraintId

	delete(t.Constraint, key)
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Instance_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) NewNeighbor(MtId uint16, SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{
		MtId:     &MtId,
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) RenameNeighbor(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.MtId = &newK.MtId
	e.SystemId = &newK.SystemId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) GetOrCreateNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(MtId, SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) GetNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) DeleteNeighbor(MtId uint16, SystemId string) {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{MtId: *v.MtId, SystemId: *v.SystemId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInstance creates a new entry in the Instance list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) NewInstance(Id uint64) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance{
		Id: &Id,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) RenameInstance(oldK, newK uint64) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Id = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetOrCreateInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance {

	key := Id

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) DeleteInstance(Id uint64) {
	key := Id

	delete(t.Instance, key)
}

// AppendInstance appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct to the
// list Instance of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) AppendInstance(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"mt-id":     *t.MtId,
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) DeleteSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) DeleteAdjacencySid(Value uint32) {
	key := Value

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) DeleteBandwidthConstraint(ModelId uint8) {
	key := ModelId

	delete(t.BandwidthConstraint, key)
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLanAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) DeleteLanAdjacencySid(Value uint32) {
	key := Value

	delete(t.LanAdjacencySid, key)
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// DeleteSetupPriority deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) DeleteSetupPriority(Priority uint8) {
	key := Priority

	delete(t.SetupPriority, key)
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	if t.AdminGroup != nil {
		return t.AdminGroup
	}
	t.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup{}
	return t.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	t.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	return t.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	t.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	return t.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	t.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	return t.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	t.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	return t.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	t.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	return t.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	t.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	return t.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	if t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	t.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes{}
	return t.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	if t.LinkDelay != nil {
		return t.LinkDelay
	}
	t.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay{}
	return t.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	t.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	return t.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	if t.LinkId != nil {
		return t.LinkId
	}
	t.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId{}
	return t.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	if t.LinkLoss != nil {
		return t.LinkLoss
	}
	t.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss{}
	return t.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	t.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType{}
	return t.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	t.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	return t.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	t.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	return t.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	t.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	return t.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	t.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	return t.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	t.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	return t.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	t.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	return t.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	t.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	return t.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup {
	if t != nil && t.AdminGroup != nil {
		return t.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t != nil && t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t != nil && t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t != nil && t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t != nil && t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t != nil && t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t != nil && t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes {
	if t != nil && t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay {
	if t != nil && t.LinkDelay != nil {
		return t.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t != nil && t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId {
	if t != nil && t.LinkId != nil {
		return t.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss {
	if t != nil && t.LinkLoss != nil {
		return t.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t != nil && t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t != nil && t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t != nil && t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t != nil && t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t != nil && t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t != nil && t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t != nil && t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t != nil && t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) DeleteConstraint(ConstraintId uint32) {
	key := ConstraintId

	delete(t.Constraint, key)
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Instance_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTopology creates a new entry in the Topology list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) NewTopology(MtId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Topology == nil {
		t.Topology = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)
	}

	key := MtId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Topology[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Topology", key)
	}

	t.Topology[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
		MtId: &MtId,
	}

	return t.Topology[key], nil
}

// RenameTopology renames an entry in the list Topology within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) RenameTopology(oldK, newK uint16) error {
	if _, ok := t.Topology[newK]; ok {
		return fmt.Errorf("key %v already exists in Topology", newK)
	}

	e, ok := t.Topology[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Topology", oldK)
	}
	e.MtId = &newK

	t.Topology[newK] = e
	delete(t.Topology, oldK)
	return nil
}

// GetOrCreateTopology retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) GetOrCreateTopology(MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {

	key := MtId

	if v, ok := t.Topology[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTopology(MtId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTopology got unexpected error: %v", err))
	}
	return v
}

// GetTopology retrieves the value with the specified key from
// the Topology map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) GetTopology(MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {

	if t == nil {
		return nil
	}

	key := MtId

	if lm, ok := t.Topology[key]; ok {
		return lm
	}
	return nil
}

// DeleteTopology deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) DeleteTopology(MtId uint16) {
	key := MtId

	delete(t.Topology, key)
}

// AppendTopology appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology struct to the
// list Topology of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) AppendTopology(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) error {
	key := *v.MtId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Topology == nil {
		t.Topology = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)
	}

	if _, ok := t.Topology[key]; ok {
		return fmt.Errorf("duplicate key for list Topology %v", key)
	}

	t.Topology[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	return map[string]interface{}{
		"mt-id": *t.MtId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_RoutePreference) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_RoutePreference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_RoutePreference) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_SystemLevelCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_TrafficEngineering) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_TrafficEngineering"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_TrafficEngineering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewArea creates a new entry in the Area list of the
// NetworkInstance_Protocol_Ospfv2 struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2) NewArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) (*NetworkInstance_Protocol_Ospfv2_Area, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Area == nil {
		t.Area = make(map[NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union]*NetworkInstance_Protocol_Ospfv2_Area)
	}

	key := Identifier

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Area[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Area", key)
	}

	t.Area[key] = &NetworkInstance_Protocol_Ospfv2_Area{
		Identifier: Identifier,
	}

	return t.Area[key], nil
}

// RenameArea renames an entry in the list Area within
// the NetworkInstance_Protocol_Ospfv2 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2) RenameArea(oldK, newK NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) error {
	if _, ok := t.Area[newK]; ok {
		return fmt.Errorf("key %v already exists in Area", newK)
	}

	e, ok := t.Area[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Area", oldK)
	}
	e.Identifier = newK

	t.Area[newK] = e
	delete(t.Area, oldK)
	return nil
}

// GetOrCreateArea retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2) GetOrCreateArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Area {

	key := Identifier

	if v, ok := t.Area[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArea(Identifier)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArea got unexpected error: %v", err))
	}
	return v
}

// GetArea retrieves the value with the specified key from
// the Area map field of NetworkInstance_Protocol_Ospfv2. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2) GetArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Area {

	if t == nil {
		return nil
	}

	key := Identifier

	if lm, ok := t.Area[key]; ok {
		return lm
	}
	return nil
}

// DeleteArea deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2) DeleteArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) {
	key := Identifier

	delete(t.Area, key)
}

// AppendArea appends the supplied NetworkInstance_Protocol_Ospfv2_Area struct to the
// list Area of NetworkInstance_Protocol_Ospfv2. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2) AppendArea(v *NetworkInstance_Protocol_Ospfv2_Area) error {
	key := v.Identifier

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Area == nil {
		t.Area = make(map[NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union]*NetworkInstance_Protocol_Ospfv2_Area)
	}

	if _, ok := t.Area[key]; ok {
		return fmt.Errorf("duplicate key for list Area %v", key)
	}

	t.Area[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2) GetOrCreateGlobal() *NetworkInstance_Protocol_Ospfv2_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Ospfv2_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Ospfv2. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2) GetGlobal() *NetworkInstance_Protocol_Ospfv2_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Ospfv2_Area struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area) NewInterface(Id string) (*NetworkInstance_Protocol_Ospfv2_Area_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Ospfv2_Area_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Ospfv2_Area struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateInterface(Id string) *NetworkInstance_Protocol_Ospfv2_Area_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Ospfv2_Area. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetInterface(Id string) *NetworkInstance_Protocol_Ospfv2_Area_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface struct to the
// list Interface of NetworkInstance_Protocol_Ospfv2_Area. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area) AppendInterface(v *NetworkInstance_Protocol_Ospfv2_Area_Interface) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewVirtualLink creates a new entry in the VirtualLink list of the
// NetworkInstance_Protocol_Ospfv2_Area struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area) NewVirtualLink(RemoteRouterId string) (*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VirtualLink == nil {
		t.VirtualLink = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink)
	}

	key := RemoteRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VirtualLink[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VirtualLink", key)
	}

	t.VirtualLink[key] = &NetworkInstance_Protocol_Ospfv2_Area_VirtualLink{
		RemoteRouterId: &RemoteRouterId,
	}

	return t.VirtualLink[key], nil
}

// RenameVirtualLink renames an entry in the list VirtualLink within
// the NetworkInstance_Protocol_Ospfv2_Area struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area) RenameVirtualLink(oldK, newK string) error {
	if _, ok := t.VirtualLink[newK]; ok {
		return fmt.Errorf("key %v already exists in VirtualLink", newK)
	}

	e, ok := t.VirtualLink[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VirtualLink", oldK)
	}
	e.RemoteRouterId = &newK

	t.VirtualLink[newK] = e
	delete(t.VirtualLink, oldK)
	return nil
}

// GetOrCreateVirtualLink retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateVirtualLink(RemoteRouterId string) *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink {

	key := RemoteRouterId

	if v, ok := t.VirtualLink[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVirtualLink(RemoteRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVirtualLink got unexpected error: %v", err))
	}
	return v
}

// GetVirtualLink retrieves the value with the specified key from
// the VirtualLink map field of NetworkInstance_Protocol_Ospfv2_Area. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetVirtualLink(RemoteRouterId string) *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink {

	if t == nil {
		return nil
	}

	key := RemoteRouterId

	if lm, ok := t.VirtualLink[key]; ok {
		return lm
	}
	return nil
}

// DeleteVirtualLink deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area) DeleteVirtualLink(RemoteRouterId string) {
	key := RemoteRouterId

	delete(t.VirtualLink, key)
}

// AppendVirtualLink appends the supplied NetworkInstance_Protocol_Ospfv2_Area_VirtualLink struct to the
// list VirtualLink of NetworkInstance_Protocol_Ospfv2_Area. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_VirtualLink already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area) AppendVirtualLink(v *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) error {
	key := *v.RemoteRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VirtualLink == nil {
		t.VirtualLink = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink)
	}

	if _, ok := t.VirtualLink[key]; ok {
		return fmt.Errorf("duplicate key for list VirtualLink %v", key)
	}

	t.VirtualLink[key] = v
	return nil
}

// GetOrCreateLsdb retrieves the value of the Lsdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateLsdb() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb {
	if t.Lsdb != nil {
		return t.Lsdb
	}
	t.Lsdb = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb{}
	return t.Lsdb
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Area_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Ospfv2_Area_Mpls{}
	return t.Mpls
}

// GetLsdb returns the value of the Lsdb struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area. If the receiver or the field Lsdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetLsdb() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb {
	if t != nil && t.Lsdb != nil {
		return t.Lsdb
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetMpls() *NetworkInstance_Protocol_Ospfv2_Area_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"identifier": t.Identifier,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Ospfv2_Area_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) NewNeighbor(RouterId string) (*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)
	}

	key := RouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
		RouterId: &RouterId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Ospfv2_Area_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.RouterId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateNeighbor(RouterId string) *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {

	key := RouterId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(RouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetNeighbor(RouterId string) *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := RouterId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) DeleteNeighbor(RouterId string) {
	key := RouterId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Ospfv2_Area_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) AppendNeighbor(v *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) error {
	key := *v.RouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateLsaFilter retrieves the value of the LsaFilter field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateLsaFilter() *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	if t.LsaFilter != nil {
		return t.LsaFilter
	}
	t.LsaFilter = &NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	return t.LsaFilter
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	return t.Mpls
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateTimers() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers{}
	return t.Timers
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetLsaFilter returns the value of the LsaFilter struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field LsaFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetLsaFilter() *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	if t != nil && t.LsaFilter != nil {
		return t.LsaFilter
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetMpls() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetTimers() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	if t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	t.IgpLdpSync = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	return t.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	if t != nil && t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RouterId == nil {
		return nil, fmt.Errorf("nil value for key RouterId")
	}

	return map[string]interface{}{
		"router-id": *t.RouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsaType creates a new entry in the LsaType list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) NewLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LsaType == nil {
		t.LsaType = make(map[E_OpenconfigOspfTypes_OSPF_LSA_TYPE]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LsaType[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LsaType", key)
	}

	t.LsaType[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType{
		Type: Type,
	}

	return t.LsaType[key], nil
}

// RenameLsaType renames an entry in the list LsaType within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) RenameLsaType(oldK, newK E_OpenconfigOspfTypes_OSPF_LSA_TYPE) error {
	if _, ok := t.LsaType[newK]; ok {
		return fmt.Errorf("key %v already exists in LsaType", newK)
	}

	e, ok := t.LsaType[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LsaType", oldK)
	}
	e.Type = newK

	t.LsaType[newK] = e
	delete(t.LsaType, oldK)
	return nil
}

// GetOrCreateLsaType retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) GetOrCreateLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType {

	key := Type

	if v, ok := t.LsaType[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsaType(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsaType got unexpected error: %v", err))
	}
	return v
}

// GetLsaType retrieves the value with the specified key from
// the LsaType map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) GetLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.LsaType[key]; ok {
		return lm
	}
	return nil
}

// DeleteLsaType deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) DeleteLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) {
	key := Type

	delete(t.LsaType, key)
}

// AppendLsaType appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct to the
// list LsaType of NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) AppendLsaType(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LsaType == nil {
		t.LsaType = make(map[E_OpenconfigOspfTypes_OSPF_LSA_TYPE]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType)
	}

	if _, ok := t.LsaType[key]; ok {
		return fmt.Errorf("duplicate key for list LsaType %v", key)
	}

	t.LsaType[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsa creates a new entry in the Lsa list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) NewLsa(LinkStateId string) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsa == nil {
		t.Lsa = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa)
	}

	key := LinkStateId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsa", key)
	}

	t.Lsa[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa{
		LinkStateId: &LinkStateId,
	}

	return t.Lsa[key], nil
}

// RenameLsa renames an entry in the list Lsa within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) RenameLsa(oldK, newK string) error {
	if _, ok := t.Lsa[newK]; ok {
		return fmt.Errorf("key %v already exists in Lsa", newK)
	}

	e, ok := t.Lsa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lsa", oldK)
	}
	e.LinkStateId = &newK

	t.Lsa[newK] = e
	delete(t.Lsa, oldK)
	return nil
}

// GetOrCreateLsa retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) GetOrCreateLsa(LinkStateId string) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa {

	key := LinkStateId

	if v, ok := t.Lsa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsa(LinkStateId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsa got unexpected error: %v", err))
	}
	return v
}

// GetLsa retrieves the value with the specified key from
// the Lsa map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) GetLsa(LinkStateId string) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa {

	if t == nil {
		return nil
	}

	key := LinkStateId

	if lm, ok := t.Lsa[key]; ok {
		return lm
	}
	return nil
}

// DeleteLsa deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) DeleteLsa(LinkStateId string) {
	key := LinkStateId

	delete(t.Lsa, key)
}

// AppendLsa appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa struct to the
// list Lsa of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) AppendLsa(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) error {
	key := *v.LinkStateId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsa == nil {
		t.Lsa = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa)
	}

	if _, ok := t.Lsa[key]; ok {
		return fmt.Errorf("duplicate key for list Lsa %v", key)
	}

	t.Lsa[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAsExternalLsa retrieves the value of the AsExternalLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateAsExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa {
	if t.AsExternalLsa != nil {
		return t.AsExternalLsa
	}
	t.AsExternalLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa{}
	return t.AsExternalLsa
}

// GetOrCreateNetworkLsa retrieves the value of the NetworkLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateNetworkLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa {
	if t.NetworkLsa != nil {
		return t.NetworkLsa
	}
	t.NetworkLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa{}
	return t.NetworkLsa
}

// GetOrCreateNssaExternalLsa retrieves the value of the NssaExternalLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateNssaExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa {
	if t.NssaExternalLsa != nil {
		return t.NssaExternalLsa
	}
	t.NssaExternalLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa{}
	return t.NssaExternalLsa
}

// GetOrCreateOpaqueLsa retrieves the value of the OpaqueLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateOpaqueLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa {
	if t.OpaqueLsa != nil {
		return t.OpaqueLsa
	}
	t.OpaqueLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa{}
	return t.OpaqueLsa
}

// GetOrCreateRouterLsa retrieves the value of the RouterLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateRouterLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa {
	if t.RouterLsa != nil {
		return t.RouterLsa
	}
	t.RouterLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa{}
	return t.RouterLsa
}

// GetOrCreateSummaryLsa retrieves the value of the SummaryLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateSummaryLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa {
	if t.SummaryLsa != nil {
		return t.SummaryLsa
	}
	t.SummaryLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa{}
	return t.SummaryLsa
}

// GetAsExternalLsa returns the value of the AsExternalLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field AsExternalLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetAsExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa {
	if t != nil && t.AsExternalLsa != nil {
		return t.AsExternalLsa
	}
	return nil
}

// GetNetworkLsa returns the value of the NetworkLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field NetworkLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetNetworkLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa {
	if t != nil && t.NetworkLsa != nil {
		return t.NetworkLsa
	}
	return nil
}

// GetNssaExternalLsa returns the value of the NssaExternalLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field NssaExternalLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetNssaExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa {
	if t != nil && t.NssaExternalLsa != nil {
		return t.NssaExternalLsa
	}
	return nil
}

// GetOpaqueLsa returns the value of the OpaqueLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field OpaqueLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOpaqueLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa {
	if t != nil && t.OpaqueLsa != nil {
		return t.OpaqueLsa
	}
	return nil
}

// GetRouterLsa returns the value of the RouterLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field RouterLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetRouterLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa {
	if t != nil && t.RouterLsa != nil {
		return t.RouterLsa
	}
	return nil
}

// GetSummaryLsa returns the value of the SummaryLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field SummaryLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetSummaryLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa {
	if t != nil && t.SummaryLsa != nil {
		return t.SummaryLsa
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LinkStateId == nil {
		return nil, fmt.Errorf("nil value for key LinkStateId")
	}

	return map[string]interface{}{
		"link-state-id": *t.LinkStateId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// DeleteTypeOfService deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) DeleteTypeOfService(Tos uint8) {
	key := Tos

	delete(t.TypeOfService, key)
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// DeleteTypeOfService deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) DeleteTypeOfService(Tos uint8) {
	key := Tos

	delete(t.TypeOfService, key)
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateExtendedLink retrieves the value of the ExtendedLink field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateExtendedLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink {
	if t.ExtendedLink != nil {
		return t.ExtendedLink
	}
	t.ExtendedLink = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink{}
	return t.ExtendedLink
}

// GetOrCreateExtendedPrefix retrieves the value of the ExtendedPrefix field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateExtendedPrefix() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix {
	if t.ExtendedPrefix != nil {
		return t.ExtendedPrefix
	}
	t.ExtendedPrefix = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix{}
	return t.ExtendedPrefix
}

// GetOrCreateGraceLsa retrieves the value of the GraceLsa field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateGraceLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa {
	if t.GraceLsa != nil {
		return t.GraceLsa
	}
	t.GraceLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa{}
	return t.GraceLsa
}

// GetOrCreateRouterInformation retrieves the value of the RouterInformation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateRouterInformation() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation {
	if t.RouterInformation != nil {
		return t.RouterInformation
	}
	t.RouterInformation = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation{}
	return t.RouterInformation
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateTrafficEngineering() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering {
	if t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	t.TrafficEngineering = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering{}
	return t.TrafficEngineering
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv{}
	return t.UnknownTlv
}

// GetExtendedLink returns the value of the ExtendedLink struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field ExtendedLink is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetExtendedLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink {
	if t != nil && t.ExtendedLink != nil {
		return t.ExtendedLink
	}
	return nil
}

// GetExtendedPrefix returns the value of the ExtendedPrefix struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field ExtendedPrefix is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetExtendedPrefix() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix {
	if t != nil && t.ExtendedPrefix != nil {
		return t.ExtendedPrefix
	}
	return nil
}

// GetGraceLsa returns the value of the GraceLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field GraceLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetGraceLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa {
	if t != nil && t.GraceLsa != nil {
		return t.GraceLsa
	}
	return nil
}

// GetRouterInformation returns the value of the RouterInformation struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field RouterInformation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetRouterInformation() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation {
	if t != nil && t.RouterInformation != nil {
		return t.RouterInformation
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetTrafficEngineering() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering {
	if t != nil && t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAdjacencySid retrieves the value of the AdjacencySid field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetOrCreateAdjacencySid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid {
	if t.AdjacencySid != nil {
		return t.AdjacencySid
	}
	t.AdjacencySid = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid{}
	return t.AdjacencySid
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetAdjacencySid returns the value of the AdjacencySid struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv. If the receiver or the field AdjacencySid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetAdjacencySid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid {
	if t != nil && t.AdjacencySid != nil {
		return t.AdjacencySid
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateExtendedPrefixRange retrieves the value of the ExtendedPrefixRange field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateExtendedPrefixRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange {
	if t.ExtendedPrefixRange != nil {
		return t.ExtendedPrefixRange
	}
	t.ExtendedPrefixRange = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange{}
	return t.ExtendedPrefixRange
}

// GetOrCreatePrefixSid retrieves the value of the PrefixSid field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreatePrefixSid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid {
	if t.PrefixSid != nil {
		return t.PrefixSid
	}
	t.PrefixSid = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid{}
	return t.PrefixSid
}

// GetOrCreateSidLabelBinding retrieves the value of the SidLabelBinding field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding {
	if t.SidLabelBinding != nil {
		return t.SidLabelBinding
	}
	t.SidLabelBinding = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding{}
	return t.SidLabelBinding
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetExtendedPrefixRange returns the value of the ExtendedPrefixRange struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field ExtendedPrefixRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetExtendedPrefixRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange {
	if t != nil && t.ExtendedPrefixRange != nil {
		return t.ExtendedPrefixRange
	}
	return nil
}

// GetPrefixSid returns the value of the PrefixSid struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field PrefixSid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetPrefixSid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid {
	if t != nil && t.PrefixSid != nil {
		return t.PrefixSid
	}
	return nil
}

// GetSidLabelBinding returns the value of the SidLabelBinding struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field SidLabelBinding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding {
	if t != nil && t.SidLabelBinding != nil {
		return t.SidLabelBinding
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEroMetric retrieves the value of the EroMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateEroMetric() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric {
	if t.EroMetric != nil {
		return t.EroMetric
	}
	t.EroMetric = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric{}
	return t.EroMetric
}

// GetOrCreateEroPath retrieves the value of the EroPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateEroPath() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath {
	if t.EroPath != nil {
		return t.EroPath
	}
	t.EroPath = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath{}
	return t.EroPath
}

// GetOrCreateSidLabelBinding retrieves the value of the SidLabelBinding field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding {
	if t.SidLabelBinding != nil {
		return t.SidLabelBinding
	}
	t.SidLabelBinding = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding{}
	return t.SidLabelBinding
}

// GetEroMetric returns the value of the EroMetric struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field EroMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetEroMetric() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric {
	if t != nil && t.EroMetric != nil {
		return t.EroMetric
	}
	return nil
}

// GetEroPath returns the value of the EroPath struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field EroPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetEroPath() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath {
	if t != nil && t.EroPath != nil {
		return t.EroPath
	}
	return nil
}

// GetSidLabelBinding returns the value of the SidLabelBinding struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field SidLabelBinding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding {
	if t != nil && t.SidLabelBinding != nil {
		return t.SidLabelBinding
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIpv4Segment retrieves the value of the Ipv4Segment field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetOrCreateIpv4Segment() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment {
	if t.Ipv4Segment != nil {
		return t.Ipv4Segment
	}
	t.Ipv4Segment = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment{}
	return t.Ipv4Segment
}

// GetOrCreateUnnumberedHop retrieves the value of the UnnumberedHop field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetOrCreateUnnumberedHop() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop {
	if t.UnnumberedHop != nil {
		return t.UnnumberedHop
	}
	t.UnnumberedHop = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop{}
	return t.UnnumberedHop
}

// GetIpv4Segment returns the value of the Ipv4Segment struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment. If the receiver or the field Ipv4Segment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetIpv4Segment() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment {
	if t != nil && t.Ipv4Segment != nil {
		return t.Ipv4Segment
	}
	return nil
}

// GetUnnumberedHop returns the value of the UnnumberedHop struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment. If the receiver or the field UnnumberedHop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetUnnumberedHop() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop {
	if t != nil && t.UnnumberedHop != nil {
		return t.UnnumberedHop
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInformationalCapabilities retrieves the value of the InformationalCapabilities field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateInformationalCapabilities() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities {
	if t.InformationalCapabilities != nil {
		return t.InformationalCapabilities
	}
	t.InformationalCapabilities = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities{}
	return t.InformationalCapabilities
}

// GetOrCreateNodeAdministrativeTags retrieves the value of the NodeAdministrativeTags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateNodeAdministrativeTags() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags {
	if t.NodeAdministrativeTags != nil {
		return t.NodeAdministrativeTags
	}
	t.NodeAdministrativeTags = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags{}
	return t.NodeAdministrativeTags
}

// GetOrCreateSegmentRoutingAlgorithm retrieves the value of the SegmentRoutingAlgorithm field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateSegmentRoutingAlgorithm() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm {
	if t.SegmentRoutingAlgorithm != nil {
		return t.SegmentRoutingAlgorithm
	}
	t.SegmentRoutingAlgorithm = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm{}
	return t.SegmentRoutingAlgorithm
}

// GetOrCreateSegmentRoutingSidLabelRange retrieves the value of the SegmentRoutingSidLabelRange field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateSegmentRoutingSidLabelRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange {
	if t.SegmentRoutingSidLabelRange != nil {
		return t.SegmentRoutingSidLabelRange
	}
	t.SegmentRoutingSidLabelRange = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange{}
	return t.SegmentRoutingSidLabelRange
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetInformationalCapabilities returns the value of the InformationalCapabilities struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field InformationalCapabilities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetInformationalCapabilities() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities {
	if t != nil && t.InformationalCapabilities != nil {
		return t.InformationalCapabilities
	}
	return nil
}

// GetNodeAdministrativeTags returns the value of the NodeAdministrativeTags struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field NodeAdministrativeTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetNodeAdministrativeTags() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags {
	if t != nil && t.NodeAdministrativeTags != nil {
		return t.NodeAdministrativeTags
	}
	return nil
}

// GetSegmentRoutingAlgorithm returns the value of the SegmentRoutingAlgorithm struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field SegmentRoutingAlgorithm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetSegmentRoutingAlgorithm() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm {
	if t != nil && t.SegmentRoutingAlgorithm != nil {
		return t.SegmentRoutingAlgorithm
	}
	return nil
}

// GetSegmentRoutingSidLabelRange returns the value of the SegmentRoutingSidLabelRange struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field SegmentRoutingSidLabelRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetSegmentRoutingSidLabelRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange {
	if t != nil && t.SegmentRoutingSidLabelRange != nil {
		return t.SegmentRoutingSidLabelRange
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSidLabel retrieves the value of the SidLabel field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetOrCreateSidLabel() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel {
	if t.SidLabel != nil {
		return t.SidLabel
	}
	t.SidLabel = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel{}
	return t.SidLabel
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetSidLabel returns the value of the SidLabel struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv. If the receiver or the field SidLabel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetSidLabel() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel {
	if t != nil && t.SidLabel != nil {
		return t.SidLabel
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLink retrieves the value of the Link field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link {
	if t.Link != nil {
		return t.Link
	}
	t.Link = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link{}
	return t.Link
}

// GetOrCreateNodeAttribute retrieves the value of the NodeAttribute field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateNodeAttribute() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute {
	if t.NodeAttribute != nil {
		return t.NodeAttribute
	}
	t.NodeAttribute = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute{}
	return t.NodeAttribute
}

// GetOrCreateRouterAddress retrieves the value of the RouterAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateRouterAddress() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress {
	if t.RouterAddress != nil {
		return t.RouterAddress
	}
	t.RouterAddress = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress{}
	return t.RouterAddress
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv {
	if t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	t.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv{}
	return t.UnknownTlv
}

// GetLink returns the value of the Link struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field Link is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link {
	if t != nil && t.Link != nil {
		return t.Link
	}
	return nil
}

// GetNodeAttribute returns the value of the NodeAttribute struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field NodeAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetNodeAttribute() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute {
	if t != nil && t.NodeAttribute != nil {
		return t.NodeAttribute
	}
	return nil
}

// GetRouterAddress returns the value of the RouterAddress struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field RouterAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetRouterAddress() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress {
	if t != nil && t.RouterAddress != nil {
		return t.RouterAddress
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv {
	if t != nil && t.UnknownTlv != nil {
		return t.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) NewAdminGroup(BitIndex uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup)
	}

	key := BitIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup{
		BitIndex: &BitIndex,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) RenameAdminGroup(oldK, newK uint8) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.BitIndex = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateAdminGroup(BitIndex uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup {

	key := BitIndex

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(BitIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetAdminGroup(BitIndex uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup {

	if t == nil {
		return nil
	}

	key := BitIndex

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdminGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) DeleteAdminGroup(BitIndex uint8) {
	key := BitIndex

	delete(t.AdminGroup, key)
}

// AppendAdminGroup appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup struct to the
// list AdminGroup of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) AppendAdminGroup(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) error {
	key := *v.BitIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewUnreservedBandwidth creates a new entry in the UnreservedBandwidth list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) NewUnreservedBandwidth(Priority uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnreservedBandwidth == nil {
		t.UnreservedBandwidth = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnreservedBandwidth[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnreservedBandwidth", key)
	}

	t.UnreservedBandwidth[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth{
		Priority: &Priority,
	}

	return t.UnreservedBandwidth[key], nil
}

// RenameUnreservedBandwidth renames an entry in the list UnreservedBandwidth within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) RenameUnreservedBandwidth(oldK, newK uint8) error {
	if _, ok := t.UnreservedBandwidth[newK]; ok {
		return fmt.Errorf("key %v already exists in UnreservedBandwidth", newK)
	}

	e, ok := t.UnreservedBandwidth[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UnreservedBandwidth", oldK)
	}
	e.Priority = &newK

	t.UnreservedBandwidth[newK] = e
	delete(t.UnreservedBandwidth, oldK)
	return nil
}

// GetOrCreateUnreservedBandwidth retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateUnreservedBandwidth(Priority uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth {

	key := Priority

	if v, ok := t.UnreservedBandwidth[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnreservedBandwidth(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnreservedBandwidth got unexpected error: %v", err))
	}
	return v
}

// GetUnreservedBandwidth retrieves the value with the specified key from
// the UnreservedBandwidth map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetUnreservedBandwidth(Priority uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.UnreservedBandwidth[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnreservedBandwidth deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) DeleteUnreservedBandwidth(Priority uint8) {
	key := Priority

	delete(t.UnreservedBandwidth, key)
}

// AppendUnreservedBandwidth appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth struct to the
// list UnreservedBandwidth of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) AppendUnreservedBandwidth(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnreservedBandwidth == nil {
		t.UnreservedBandwidth = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth)
	}

	if _, ok := t.UnreservedBandwidth[key]; ok {
		return fmt.Errorf("duplicate key for list UnreservedBandwidth %v", key)
	}

	t.UnreservedBandwidth[key] = v
	return nil
}

// GetOrCreateUnknownSubtlv retrieves the value of the UnknownSubtlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv {
	if t.UnknownSubtlv != nil {
		return t.UnknownSubtlv
	}
	t.UnknownSubtlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv{}
	return t.UnknownSubtlv
}

// GetUnknownSubtlv returns the value of the UnknownSubtlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver or the field UnknownSubtlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv {
	if t != nil && t.UnknownSubtlv != nil {
		return t.UnknownSubtlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BitIndex == nil {
		return nil, fmt.Errorf("nil value for key BitIndex")
	}

	return map[string]interface{}{
		"bit-index": *t.BitIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateUnknownSubtlv retrieves the value of the UnknownSubtlv field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) GetOrCreateUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv {
	if t.UnknownSubtlv != nil {
		return t.UnknownSubtlv
	}
	t.UnknownSubtlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv{}
	return t.UnknownSubtlv
}

// GetUnknownSubtlv returns the value of the UnknownSubtlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv. If the receiver or the field UnknownSubtlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) GetUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv {
	if t != nil && t.UnknownSubtlv != nil {
		return t.UnknownSubtlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// DeleteTypeOfService deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) DeleteTypeOfService(Tos uint8) {
	key := Tos

	delete(t.TypeOfService, key)
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// DeleteTypeOfService deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) DeleteTypeOfService(Tos uint8) {
	key := Tos

	delete(t.TypeOfService, key)
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_VirtualLink struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RemoteRouterId == nil {
		return nil, fmt.Errorf("nil value for key RemoteRouterId")
	}

	return map[string]interface{}{
		"remote-router-id": *t.RemoteRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_VirtualLink"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterAreaPropagationPolicy creates a new entry in the InterAreaPropagationPolicy list of the
// NetworkInstance_Protocol_Ospfv2_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Global) NewInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) (*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterAreaPropagationPolicy == nil {
		t.InterAreaPropagationPolicy = make(map[NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key]*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy)
	}

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InterAreaPropagationPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InterAreaPropagationPolicy", key)
	}

	t.InterAreaPropagationPolicy[key] = &NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	return t.InterAreaPropagationPolicy[key], nil
}

// RenameInterAreaPropagationPolicy renames an entry in the list InterAreaPropagationPolicy within
// the NetworkInstance_Protocol_Ospfv2_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Global) RenameInterAreaPropagationPolicy(oldK, newK NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key) error {
	if _, ok := t.InterAreaPropagationPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in InterAreaPropagationPolicy", newK)
	}

	e, ok := t.InterAreaPropagationPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InterAreaPropagationPolicy", oldK)
	}
	e.SrcArea = newK.SrcArea
	e.DstArea = newK.DstArea

	t.InterAreaPropagationPolicy[newK] = e
	delete(t.InterAreaPropagationPolicy, oldK)
	return nil
}

// GetOrCreateInterAreaPropagationPolicy retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy {

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	if v, ok := t.InterAreaPropagationPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterAreaPropagationPolicy(SrcArea, DstArea)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterAreaPropagationPolicy got unexpected error: %v", err))
	}
	return v
}

// GetInterAreaPropagationPolicy retrieves the value with the specified key from
// the InterAreaPropagationPolicy map field of NetworkInstance_Protocol_Ospfv2_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	if lm, ok := t.InterAreaPropagationPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterAreaPropagationPolicy deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Ospfv2_Global) DeleteInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) {
	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	delete(t.InterAreaPropagationPolicy, key)
}

// AppendInterAreaPropagationPolicy appends the supplied NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy struct to the
// list InterAreaPropagationPolicy of NetworkInstance_Protocol_Ospfv2_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Global) AppendInterAreaPropagationPolicy(v *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) error {
	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{SrcArea: v.SrcArea, DstArea: v.DstArea}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterAreaPropagationPolicy == nil {
		t.InterAreaPropagationPolicy = make(map[NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key]*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy)
	}

	if _, ok := t.InterAreaPropagationPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list InterAreaPropagationPolicy %v", key)
	}

	t.InterAreaPropagationPolicy[key] = v
	return nil
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Global_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Ospfv2_Global_Mpls{}
	return t.Mpls
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateTimers() *NetworkInstance_Protocol_Ospfv2_Global_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Ospfv2_Global_Timers{}
	return t.Timers
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetGracefulRestart() *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetMpls() *NetworkInstance_Protocol_Ospfv2_Global_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetTimers() *NetworkInstance_Protocol_Ospfv2_Global_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"dst-area": t.DstArea,
		"src-area": t.SrcArea,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync {
	if t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	t.IgpLdpSync = &NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync{}
	return t.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync {
	if t != nil && t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLsaGeneration retrieves the value of the LsaGeneration field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateLsaGeneration() *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration {
	if t.LsaGeneration != nil {
		return t.LsaGeneration
	}
	t.LsaGeneration = &NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration{}
	return t.LsaGeneration
}

// GetOrCreateMaxMetric retrieves the value of the MaxMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateMaxMetric() *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric {
	if t.MaxMetric != nil {
		return t.MaxMetric
	}
	t.MaxMetric = &NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric{}
	return t.MaxMetric
}

// GetOrCreateSpf retrieves the value of the Spf field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateSpf() *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf {
	if t.Spf != nil {
		return t.Spf
	}
	t.Spf = &NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf{}
	return t.Spf
}

// GetLsaGeneration returns the value of the LsaGeneration struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field LsaGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetLsaGeneration() *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration {
	if t != nil && t.LsaGeneration != nil {
		return t.LsaGeneration
	}
	return nil
}

// GetMaxMetric returns the value of the MaxMetric struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field MaxMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetMaxMetric() *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric {
	if t != nil && t.MaxMetric != nil {
		return t.MaxMetric
	}
	return nil
}

// GetSpf returns the value of the Spf struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field Spf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetSpf() *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf {
	if t != nil && t.Spf != nil {
		return t.Spf
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Pim struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Pim) NewInterface(InterfaceId string) (*NetworkInstance_Protocol_Pim_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Pim_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Pim_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Pim struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Pim) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Pim) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Protocol_Pim_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Pim. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Pim) GetInterface(InterfaceId string) *NetworkInstance_Protocol_Pim_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Pim) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Pim_Interface struct to the
// list Interface of NetworkInstance_Protocol_Pim. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Pim_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Pim) AppendInterface(v *NetworkInstance_Protocol_Pim_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Pim_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Pim) GetOrCreateGlobal() *NetworkInstance_Protocol_Pim_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Pim_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Pim. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Pim) GetGlobal() *NetworkInstance_Protocol_Pim_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewRendezvousPoint creates a new entry in the RendezvousPoint list of the
// NetworkInstance_Protocol_Pim_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Pim_Global) NewRendezvousPoint(Address string) (*NetworkInstance_Protocol_Pim_Global_RendezvousPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RendezvousPoint == nil {
		t.RendezvousPoint = make(map[string]*NetworkInstance_Protocol_Pim_Global_RendezvousPoint)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RendezvousPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RendezvousPoint", key)
	}

	t.RendezvousPoint[key] = &NetworkInstance_Protocol_Pim_Global_RendezvousPoint{
		Address: &Address,
	}

	return t.RendezvousPoint[key], nil
}

// RenameRendezvousPoint renames an entry in the list RendezvousPoint within
// the NetworkInstance_Protocol_Pim_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Pim_Global) RenameRendezvousPoint(oldK, newK string) error {
	if _, ok := t.RendezvousPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in RendezvousPoint", newK)
	}

	e, ok := t.RendezvousPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RendezvousPoint", oldK)
	}
	e.Address = &newK

	t.RendezvousPoint[newK] = e
	delete(t.RendezvousPoint, oldK)
	return nil
}

// GetOrCreateRendezvousPoint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Pim_Global) GetOrCreateRendezvousPoint(Address string) *NetworkInstance_Protocol_Pim_Global_RendezvousPoint {

	key := Address

	if v, ok := t.RendezvousPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRendezvousPoint(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRendezvousPoint got unexpected error: %v", err))
	}
	return v
}

// GetRendezvousPoint retrieves the value with the specified key from
// the RendezvousPoint map field of NetworkInstance_Protocol_Pim_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Pim_Global) GetRendezvousPoint(Address string) *NetworkInstance_Protocol_Pim_Global_RendezvousPoint {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.RendezvousPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteRendezvousPoint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Pim_Global) DeleteRendezvousPoint(Address string) {
	key := Address

	delete(t.RendezvousPoint, key)
}

// AppendRendezvousPoint appends the supplied NetworkInstance_Protocol_Pim_Global_RendezvousPoint struct to the
// list RendezvousPoint of NetworkInstance_Protocol_Pim_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Pim_Global_RendezvousPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Pim_Global) AppendRendezvousPoint(v *NetworkInstance_Protocol_Pim_Global_RendezvousPoint) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RendezvousPoint == nil {
		t.RendezvousPoint = make(map[string]*NetworkInstance_Protocol_Pim_Global_RendezvousPoint)
	}

	if _, ok := t.RendezvousPoint[key]; ok {
		return fmt.Errorf("duplicate key for list RendezvousPoint %v", key)
	}

	t.RendezvousPoint[key] = v
	return nil
}

// NewSource creates a new entry in the Source list of the
// NetworkInstance_Protocol_Pim_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Pim_Global) NewSource(Address string) (*NetworkInstance_Protocol_Pim_Global_Source, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Source == nil {
		t.Source = make(map[string]*NetworkInstance_Protocol_Pim_Global_Source)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Source[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Source", key)
	}

	t.Source[key] = &NetworkInstance_Protocol_Pim_Global_Source{
		Address: &Address,
	}

	return t.Source[key], nil
}

// RenameSource renames an entry in the list Source within
// the NetworkInstance_Protocol_Pim_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Pim_Global) RenameSource(oldK, newK string) error {
	if _, ok := t.Source[newK]; ok {
		return fmt.Errorf("key %v already exists in Source", newK)
	}

	e, ok := t.Source[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Source", oldK)
	}
	e.Address = &newK

	t.Source[newK] = e
	delete(t.Source, oldK)
	return nil
}

// GetOrCreateSource retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Pim_Global) GetOrCreateSource(Address string) *NetworkInstance_Protocol_Pim_Global_Source {

	key := Address

	if v, ok := t.Source[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSource(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSource got unexpected error: %v", err))
	}
	return v
}

// GetSource retrieves the value with the specified key from
// the Source map field of NetworkInstance_Protocol_Pim_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Pim_Global) GetSource(Address string) *NetworkInstance_Protocol_Pim_Global_Source {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Source[key]; ok {
		return lm
	}
	return nil
}

// DeleteSource deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Pim_Global) DeleteSource(Address string) {
	key := Address

	delete(t.Source, key)
}

// AppendSource appends the supplied NetworkInstance_Protocol_Pim_Global_Source struct to the
// list Source of NetworkInstance_Protocol_Pim_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Pim_Global_Source already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Pim_Global) AppendSource(v *NetworkInstance_Protocol_Pim_Global_Source) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Source == nil {
		t.Source = make(map[string]*NetworkInstance_Protocol_Pim_Global_Source)
	}

	if _, ok := t.Source[key]; ok {
		return fmt.Errorf("duplicate key for list Source %v", key)
	}

	t.Source[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Pim_Global) GetOrCreateCounters() *NetworkInstance_Protocol_Pim_Global_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Protocol_Pim_Global_Counters{}
	return t.Counters
}

// GetOrCreateSsm retrieves the value of the Ssm field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Pim_Global) GetOrCreateSsm() *NetworkInstance_Protocol_Pim_Global_Ssm {
	if t.Ssm != nil {
		return t.Ssm
	}
	t.Ssm = &NetworkInstance_Protocol_Pim_Global_Ssm{}
	return t.Ssm
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Protocol_Pim_Global. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Pim_Global) GetCounters() *NetworkInstance_Protocol_Pim_Global_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSsm returns the value of the Ssm struct pointer
// from NetworkInstance_Protocol_Pim_Global. If the receiver or the field Ssm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Pim_Global) GetSsm() *NetworkInstance_Protocol_Pim_Global_Ssm {
	if t != nil && t.Ssm != nil {
		return t.Ssm
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Global_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Global_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Global_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Pim_Global_RendezvousPoint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Pim_Global_RendezvousPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Global_RendezvousPoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Global_RendezvousPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Global_RendezvousPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Pim_Global_Source struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Pim_Global_Source) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Global_Source) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Global_Source"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Global_Source) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Global_Ssm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Global_Ssm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Global_Ssm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Pim_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Pim_Interface) NewNeighbor(NeighborAddress string) (*NetworkInstance_Protocol_Pim_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Pim_Interface_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Pim_Interface_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Pim_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Pim_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Pim_Interface) GetOrCreateNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Pim_Interface_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Pim_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Pim_Interface) GetNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Pim_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Pim_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Pim_Interface) DeleteNeighbor(NeighborAddress string) {
	key := NeighborAddress

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Pim_Interface_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Pim_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Pim_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Pim_Interface) AppendNeighbor(v *NetworkInstance_Protocol_Pim_Interface_Neighbor) error {
	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Pim_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Pim_Interface) GetOrCreateCounters() *NetworkInstance_Protocol_Pim_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Protocol_Pim_Interface_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Pim_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Pim_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Pim_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Protocol_Pim_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Pim_Interface) GetCounters() *NetworkInstance_Protocol_Pim_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Pim_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Pim_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Pim_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Pim_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Pim_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Pim_Interface_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Pim_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NeighborAddress == nil {
		return nil, fmt.Errorf("nil value for key NeighborAddress")
	}

	return map[string]interface{}{
		"neighbor-address": *t.NeighborAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Pim_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Pim_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Pim_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Protocol_Static struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Static) NewNextHop(Index string) (*NetworkInstance_Protocol_Static_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*NetworkInstance_Protocol_Static_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Protocol_Static_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Protocol_Static struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Static) RenameNextHop(oldK, newK string) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Static. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Static) GetOrCreateNextHop(Index string) *NetworkInstance_Protocol_Static_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Protocol_Static. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Static) GetNextHop(Index string) *NetworkInstance_Protocol_Static_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Static. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Static) DeleteNextHop(Index string) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Protocol_Static_NextHop struct to the
// list NextHop of NetworkInstance_Protocol_Static. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Static_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Static) AppendNextHop(v *NetworkInstance_Protocol_Static_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*NetworkInstance_Protocol_Static_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Static struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Static) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Static) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Static_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Static_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Static_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Static_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Static_NextHop) GetInterfaceRef() *NetworkInstance_Protocol_Static_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Static_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Static_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Static_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Static_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_RouteLimit struct, which is a YANG list entry.
func (t *NetworkInstance_RouteLimit) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi": t.Afi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_RouteLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_RouteLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_RouteLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewSrgb creates a new entry in the Srgb list of the
// NetworkInstance_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_SegmentRouting) NewSrgb(LocalId string) (*NetworkInstance_SegmentRouting_Srgb, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srgb == nil {
		t.Srgb = make(map[string]*NetworkInstance_SegmentRouting_Srgb)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srgb[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srgb", key)
	}

	t.Srgb[key] = &NetworkInstance_SegmentRouting_Srgb{
		LocalId: &LocalId,
	}

	return t.Srgb[key], nil
}

// RenameSrgb renames an entry in the list Srgb within
// the NetworkInstance_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_SegmentRouting) RenameSrgb(oldK, newK string) error {
	if _, ok := t.Srgb[newK]; ok {
		return fmt.Errorf("key %v already exists in Srgb", newK)
	}

	e, ok := t.Srgb[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srgb", oldK)
	}
	e.LocalId = &newK

	t.Srgb[newK] = e
	delete(t.Srgb, oldK)
	return nil
}

// GetOrCreateSrgb retrieves the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_SegmentRouting) GetOrCreateSrgb(LocalId string) *NetworkInstance_SegmentRouting_Srgb {

	key := LocalId

	if v, ok := t.Srgb[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrgb(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrgb got unexpected error: %v", err))
	}
	return v
}

// GetSrgb retrieves the value with the specified key from
// the Srgb map field of NetworkInstance_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_SegmentRouting) GetSrgb(LocalId string) *NetworkInstance_SegmentRouting_Srgb {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.Srgb[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrgb deletes the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_SegmentRouting) DeleteSrgb(LocalId string) {
	key := LocalId

	delete(t.Srgb, key)
}

// AppendSrgb appends the supplied NetworkInstance_SegmentRouting_Srgb struct to the
// list Srgb of NetworkInstance_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_SegmentRouting_Srgb already exist in the list, an error is
// returned.
func (t *NetworkInstance_SegmentRouting) AppendSrgb(v *NetworkInstance_SegmentRouting_Srgb) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srgb == nil {
		t.Srgb = make(map[string]*NetworkInstance_SegmentRouting_Srgb)
	}

	if _, ok := t.Srgb[key]; ok {
		return fmt.Errorf("duplicate key for list Srgb %v", key)
	}

	t.Srgb[key] = v
	return nil
}

// NewSrlb creates a new entry in the Srlb list of the
// NetworkInstance_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_SegmentRouting) NewSrlb(LocalId string) (*NetworkInstance_SegmentRouting_Srlb, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlb == nil {
		t.Srlb = make(map[string]*NetworkInstance_SegmentRouting_Srlb)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlb[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlb", key)
	}

	t.Srlb[key] = &NetworkInstance_SegmentRouting_Srlb{
		LocalId: &LocalId,
	}

	return t.Srlb[key], nil
}

// RenameSrlb renames an entry in the list Srlb within
// the NetworkInstance_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_SegmentRouting) RenameSrlb(oldK, newK string) error {
	if _, ok := t.Srlb[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlb", newK)
	}

	e, ok := t.Srlb[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlb", oldK)
	}
	e.LocalId = &newK

	t.Srlb[newK] = e
	delete(t.Srlb, oldK)
	return nil
}

// GetOrCreateSrlb retrieves the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_SegmentRouting) GetOrCreateSrlb(LocalId string) *NetworkInstance_SegmentRouting_Srlb {

	key := LocalId

	if v, ok := t.Srlb[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlb(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlb got unexpected error: %v", err))
	}
	return v
}

// GetSrlb retrieves the value with the specified key from
// the Srlb map field of NetworkInstance_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_SegmentRouting) GetSrlb(LocalId string) *NetworkInstance_SegmentRouting_Srlb {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.Srlb[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrlb deletes the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_SegmentRouting) DeleteSrlb(LocalId string) {
	key := LocalId

	delete(t.Srlb, key)
}

// AppendSrlb appends the supplied NetworkInstance_SegmentRouting_Srlb struct to the
// list Srlb of NetworkInstance_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_SegmentRouting_Srlb already exist in the list, an error is
// returned.
func (t *NetworkInstance_SegmentRouting) AppendSrlb(v *NetworkInstance_SegmentRouting_Srlb) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlb == nil {
		t.Srlb = make(map[string]*NetworkInstance_SegmentRouting_Srlb)
	}

	if _, ok := t.Srlb[key]; ok {
		return fmt.Errorf("duplicate key for list Srlb %v", key)
	}

	t.Srlb[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_SegmentRouting_Srgb struct, which is a YANG list entry.
func (t *NetworkInstance_SegmentRouting_Srgb) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_SegmentRouting_Srgb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting_Srgb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting_Srgb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_SegmentRouting_Srlb struct, which is a YANG list entry.
func (t *NetworkInstance_SegmentRouting_Srlb) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_SegmentRouting_Srlb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting_Srlb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting_Srlb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Table struct, which is a YANG list entry.
func (t *NetworkInstance_Table) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"address-family": t.AddressFamily,
		"protocol":       t.Protocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Table) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Table"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Table) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_TableConnection struct, which is a YANG list entry.
func (t *NetworkInstance_TableConnection) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"address-family": t.AddressFamily,
		"dst-protocol":   t.DstProtocol,
		"src-protocol":   t.SrcProtocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_TableConnection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_TableConnection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_TableConnection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Vlan struct, which is a YANG list entry.
func (t *NetworkInstance_Vlan) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VlanId == nil {
		return nil, fmt.Errorf("nil value for key VlanId")
	}

	return map[string]interface{}{
		"vlan-id": *t.VlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Vlan_Member) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Vlan_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Vlan_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAmplifier creates a new entry in the Amplifier list of the
// OpticalAmplifier struct. The keys of the list are populated from the input
// arguments.
func (t *OpticalAmplifier) NewAmplifier(Name string) (*OpticalAmplifier_Amplifier, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Amplifier == nil {
		t.Amplifier = make(map[string]*OpticalAmplifier_Amplifier)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Amplifier[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Amplifier", key)
	}

	t.Amplifier[key] = &OpticalAmplifier_Amplifier{
		Name: &Name,
	}

	return t.Amplifier[key], nil
}

// RenameAmplifier renames an entry in the list Amplifier within
// the OpticalAmplifier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *OpticalAmplifier) RenameAmplifier(oldK, newK string) error {
	if _, ok := t.Amplifier[newK]; ok {
		return fmt.Errorf("key %v already exists in Amplifier", newK)
	}

	e, ok := t.Amplifier[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Amplifier", oldK)
	}
	e.Name = &newK

	t.Amplifier[newK] = e
	delete(t.Amplifier, oldK)
	return nil
}

// GetOrCreateAmplifier retrieves the value with the specified keys from
// the receiver OpticalAmplifier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpticalAmplifier) GetOrCreateAmplifier(Name string) *OpticalAmplifier_Amplifier {

	key := Name

	if v, ok := t.Amplifier[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAmplifier(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAmplifier got unexpected error: %v", err))
	}
	return v
}

// GetAmplifier retrieves the value with the specified key from
// the Amplifier map field of OpticalAmplifier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpticalAmplifier) GetAmplifier(Name string) *OpticalAmplifier_Amplifier {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Amplifier[key]; ok {
		return lm
	}
	return nil
}

// DeleteAmplifier deletes the value with the specified keys from
// the receiver OpticalAmplifier. If there is no such element, the function
// is a no-op.
func (t *OpticalAmplifier) DeleteAmplifier(Name string) {
	key := Name

	delete(t.Amplifier, key)
}

// AppendAmplifier appends the supplied OpticalAmplifier_Amplifier struct to the
// list Amplifier of OpticalAmplifier. If the key value(s) specified in
// the supplied OpticalAmplifier_Amplifier already exist in the list, an error is
// returned.
func (t *OpticalAmplifier) AppendAmplifier(v *OpticalAmplifier_Amplifier) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Amplifier == nil {
		t.Amplifier = make(map[string]*OpticalAmplifier_Amplifier)
	}

	if _, ok := t.Amplifier[key]; ok {
		return fmt.Errorf("duplicate key for list Amplifier %v", key)
	}

	t.Amplifier[key] = v
	return nil
}

// NewSupervisoryChannel creates a new entry in the SupervisoryChannel list of the
// OpticalAmplifier struct. The keys of the list are populated from the input
// arguments.
func (t *OpticalAmplifier) NewSupervisoryChannel(Interface string) (*OpticalAmplifier_SupervisoryChannel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SupervisoryChannel == nil {
		t.SupervisoryChannel = make(map[string]*OpticalAmplifier_SupervisoryChannel)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SupervisoryChannel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SupervisoryChannel", key)
	}

	t.SupervisoryChannel[key] = &OpticalAmplifier_SupervisoryChannel{
		Interface: &Interface,
	}

	return t.SupervisoryChannel[key], nil
}

// RenameSupervisoryChannel renames an entry in the list SupervisoryChannel within
// the OpticalAmplifier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *OpticalAmplifier) RenameSupervisoryChannel(oldK, newK string) error {
	if _, ok := t.SupervisoryChannel[newK]; ok {
		return fmt.Errorf("key %v already exists in SupervisoryChannel", newK)
	}

	e, ok := t.SupervisoryChannel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SupervisoryChannel", oldK)
	}
	e.Interface = &newK

	t.SupervisoryChannel[newK] = e
	delete(t.SupervisoryChannel, oldK)
	return nil
}

// GetOrCreateSupervisoryChannel retrieves the value with the specified keys from
// the receiver OpticalAmplifier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpticalAmplifier) GetOrCreateSupervisoryChannel(Interface string) *OpticalAmplifier_SupervisoryChannel {

	key := Interface

	if v, ok := t.SupervisoryChannel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSupervisoryChannel(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSupervisoryChannel got unexpected error: %v", err))
	}
	return v
}

// GetSupervisoryChannel retrieves the value with the specified key from
// the SupervisoryChannel map field of OpticalAmplifier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpticalAmplifier) GetSupervisoryChannel(Interface string) *OpticalAmplifier_SupervisoryChannel {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.SupervisoryChannel[key]; ok {
		return lm
	}
	return nil
}

// DeleteSupervisoryChannel deletes the value with the specified keys from
// the receiver OpticalAmplifier. If there is no such element, the function
// is a no-op.
func (t *OpticalAmplifier) DeleteSupervisoryChannel(Interface string) {
	key := Interface

	delete(t.SupervisoryChannel, key)
}

// AppendSupervisoryChannel appends the supplied OpticalAmplifier_SupervisoryChannel struct to the
// list SupervisoryChannel of OpticalAmplifier. If the key value(s) specified in
// the supplied OpticalAmplifier_SupervisoryChannel already exist in the list, an error is
// returned.
func (t *OpticalAmplifier) AppendSupervisoryChannel(v *OpticalAmplifier_SupervisoryChannel) error {
	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SupervisoryChannel == nil {
		t.SupervisoryChannel = make(map[string]*OpticalAmplifier_SupervisoryChannel)
	}

	if _, ok := t.SupervisoryChannel[key]; ok {
		return fmt.Errorf("duplicate key for list SupervisoryChannel %v", key)
	}

	t.SupervisoryChannel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateActualGain retrieves the value of the ActualGain field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateActualGain() *OpticalAmplifier_Amplifier_ActualGain {
	if t.ActualGain != nil {
		return t.ActualGain
	}
	t.ActualGain = &OpticalAmplifier_Amplifier_ActualGain{}
	return t.ActualGain
}

// GetOrCreateActualGainTilt retrieves the value of the ActualGainTilt field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateActualGainTilt() *OpticalAmplifier_Amplifier_ActualGainTilt {
	if t.ActualGainTilt != nil {
		return t.ActualGainTilt
	}
	t.ActualGainTilt = &OpticalAmplifier_Amplifier_ActualGainTilt{}
	return t.ActualGainTilt
}

// GetOrCreateInputPowerCBand retrieves the value of the InputPowerCBand field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateInputPowerCBand() *OpticalAmplifier_Amplifier_InputPowerCBand {
	if t.InputPowerCBand != nil {
		return t.InputPowerCBand
	}
	t.InputPowerCBand = &OpticalAmplifier_Amplifier_InputPowerCBand{}
	return t.InputPowerCBand
}

// GetOrCreateInputPowerLBand retrieves the value of the InputPowerLBand field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateInputPowerLBand() *OpticalAmplifier_Amplifier_InputPowerLBand {
	if t.InputPowerLBand != nil {
		return t.InputPowerLBand
	}
	t.InputPowerLBand = &OpticalAmplifier_Amplifier_InputPowerLBand{}
	return t.InputPowerLBand
}

// GetOrCreateInputPowerTotal retrieves the value of the InputPowerTotal field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateInputPowerTotal() *OpticalAmplifier_Amplifier_InputPowerTotal {
	if t.InputPowerTotal != nil {
		return t.InputPowerTotal
	}
	t.InputPowerTotal = &OpticalAmplifier_Amplifier_InputPowerTotal{}
	return t.InputPowerTotal
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateLaserBiasCurrent() *OpticalAmplifier_Amplifier_LaserBiasCurrent {
	if t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	t.LaserBiasCurrent = &OpticalAmplifier_Amplifier_LaserBiasCurrent{}
	return t.LaserBiasCurrent
}

// GetOrCreateOpticalReturnLoss retrieves the value of the OpticalReturnLoss field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateOpticalReturnLoss() *OpticalAmplifier_Amplifier_OpticalReturnLoss {
	if t.OpticalReturnLoss != nil {
		return t.OpticalReturnLoss
	}
	t.OpticalReturnLoss = &OpticalAmplifier_Amplifier_OpticalReturnLoss{}
	return t.OpticalReturnLoss
}

// GetOrCreateOutputPowerCBand retrieves the value of the OutputPowerCBand field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerCBand() *OpticalAmplifier_Amplifier_OutputPowerCBand {
	if t.OutputPowerCBand != nil {
		return t.OutputPowerCBand
	}
	t.OutputPowerCBand = &OpticalAmplifier_Amplifier_OutputPowerCBand{}
	return t.OutputPowerCBand
}

// GetOrCreateOutputPowerLBand retrieves the value of the OutputPowerLBand field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerLBand() *OpticalAmplifier_Amplifier_OutputPowerLBand {
	if t.OutputPowerLBand != nil {
		return t.OutputPowerLBand
	}
	t.OutputPowerLBand = &OpticalAmplifier_Amplifier_OutputPowerLBand{}
	return t.OutputPowerLBand
}

// GetOrCreateOutputPowerTotal retrieves the value of the OutputPowerTotal field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerTotal() *OpticalAmplifier_Amplifier_OutputPowerTotal {
	if t.OutputPowerTotal != nil {
		return t.OutputPowerTotal
	}
	t.OutputPowerTotal = &OpticalAmplifier_Amplifier_OutputPowerTotal{}
	return t.OutputPowerTotal
}

// GetActualGain returns the value of the ActualGain struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field ActualGain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetActualGain() *OpticalAmplifier_Amplifier_ActualGain {
	if t != nil && t.ActualGain != nil {
		return t.ActualGain
	}
	return nil
}

// GetActualGainTilt returns the value of the ActualGainTilt struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field ActualGainTilt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetActualGainTilt() *OpticalAmplifier_Amplifier_ActualGainTilt {
	if t != nil && t.ActualGainTilt != nil {
		return t.ActualGainTilt
	}
	return nil
}

// GetInputPowerCBand returns the value of the InputPowerCBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerCBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetInputPowerCBand() *OpticalAmplifier_Amplifier_InputPowerCBand {
	if t != nil && t.InputPowerCBand != nil {
		return t.InputPowerCBand
	}
	return nil
}

// GetInputPowerLBand returns the value of the InputPowerLBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerLBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetInputPowerLBand() *OpticalAmplifier_Amplifier_InputPowerLBand {
	if t != nil && t.InputPowerLBand != nil {
		return t.InputPowerLBand
	}
	return nil
}

// GetInputPowerTotal returns the value of the InputPowerTotal struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerTotal is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetInputPowerTotal() *OpticalAmplifier_Amplifier_InputPowerTotal {
	if t != nil && t.InputPowerTotal != nil {
		return t.InputPowerTotal
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetLaserBiasCurrent() *OpticalAmplifier_Amplifier_LaserBiasCurrent {
	if t != nil && t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	return nil
}

// GetOpticalReturnLoss returns the value of the OpticalReturnLoss struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OpticalReturnLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetOpticalReturnLoss() *OpticalAmplifier_Amplifier_OpticalReturnLoss {
	if t != nil && t.OpticalReturnLoss != nil {
		return t.OpticalReturnLoss
	}
	return nil
}

// GetOutputPowerCBand returns the value of the OutputPowerCBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerCBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetOutputPowerCBand() *OpticalAmplifier_Amplifier_OutputPowerCBand {
	if t != nil && t.OutputPowerCBand != nil {
		return t.OutputPowerCBand
	}
	return nil
}

// GetOutputPowerLBand returns the value of the OutputPowerLBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerLBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetOutputPowerLBand() *OpticalAmplifier_Amplifier_OutputPowerLBand {
	if t != nil && t.OutputPowerLBand != nil {
		return t.OutputPowerLBand
	}
	return nil
}

// GetOutputPowerTotal returns the value of the OutputPowerTotal struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerTotal is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_Amplifier) GetOutputPowerTotal() *OpticalAmplifier_Amplifier_OutputPowerTotal {
	if t != nil && t.OutputPowerTotal != nil {
		return t.OutputPowerTotal
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpticalAmplifier_Amplifier struct, which is a YANG list entry.
func (t *OpticalAmplifier_Amplifier) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_ActualGain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_ActualGain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_ActualGain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_ActualGainTilt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_ActualGainTilt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_ActualGainTilt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_InputPowerCBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerCBand"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerCBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_InputPowerLBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerLBand"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerLBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_InputPowerTotal) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerTotal"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerTotal) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_OpticalReturnLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OpticalReturnLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OpticalReturnLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_OutputPowerCBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerCBand"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerCBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_OutputPowerLBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerLBand"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerLBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_Amplifier_OutputPowerTotal) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerTotal"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerTotal) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_SupervisoryChannel) GetOrCreateInputPower() *OpticalAmplifier_SupervisoryChannel_InputPower {
	if t.InputPower != nil {
		return t.InputPower
	}
	t.InputPower = &OpticalAmplifier_SupervisoryChannel_InputPower{}
	return t.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_SupervisoryChannel) GetOrCreateLaserBiasCurrent() *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent {
	if t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	t.LaserBiasCurrent = &OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent{}
	return t.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (t *OpticalAmplifier_SupervisoryChannel) GetOrCreateOutputPower() *OpticalAmplifier_SupervisoryChannel_OutputPower {
	if t.OutputPower != nil {
		return t.OutputPower
	}
	t.OutputPower = &OpticalAmplifier_SupervisoryChannel_OutputPower{}
	return t.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_SupervisoryChannel) GetInputPower() *OpticalAmplifier_SupervisoryChannel_InputPower {
	if t != nil && t.InputPower != nil {
		return t.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_SupervisoryChannel) GetLaserBiasCurrent() *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent {
	if t != nil && t.LaserBiasCurrent != nil {
		return t.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpticalAmplifier_SupervisoryChannel) GetOutputPower() *OpticalAmplifier_SupervisoryChannel_OutputPower {
	if t != nil && t.OutputPower != nil {
		return t.OutputPower
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpticalAmplifier_SupervisoryChannel struct, which is a YANG list entry.
func (t *OpticalAmplifier_SupervisoryChannel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_SupervisoryChannel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_SupervisoryChannel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpticalAmplifier_SupervisoryChannel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPolicyDefinition creates a new entry in the PolicyDefinition list of the
// RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy) NewPolicyDefinition(Name string) (*RoutingPolicy_PolicyDefinition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyDefinition == nil {
		t.PolicyDefinition = make(map[string]*RoutingPolicy_PolicyDefinition)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyDefinition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyDefinition", key)
	}

	t.PolicyDefinition[key] = &RoutingPolicy_PolicyDefinition{
		Name: &Name,
	}

	return t.PolicyDefinition[key], nil
}

// RenamePolicyDefinition renames an entry in the list PolicyDefinition within
// the RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy) RenamePolicyDefinition(oldK, newK string) error {
	if _, ok := t.PolicyDefinition[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyDefinition", newK)
	}

	e, ok := t.PolicyDefinition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyDefinition", oldK)
	}
	e.Name = &newK

	t.PolicyDefinition[newK] = e
	delete(t.PolicyDefinition, oldK)
	return nil
}

// GetOrCreatePolicyDefinition retrieves the value with the specified keys from
// the receiver RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy) GetOrCreatePolicyDefinition(Name string) *RoutingPolicy_PolicyDefinition {

	key := Name

	if v, ok := t.PolicyDefinition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyDefinition(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyDefinition got unexpected error: %v", err))
	}
	return v
}

// GetPolicyDefinition retrieves the value with the specified key from
// the PolicyDefinition map field of RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy) GetPolicyDefinition(Name string) *RoutingPolicy_PolicyDefinition {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PolicyDefinition[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyDefinition deletes the value with the specified keys from
// the receiver RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy) DeletePolicyDefinition(Name string) {
	key := Name

	delete(t.PolicyDefinition, key)
}

// AppendPolicyDefinition appends the supplied RoutingPolicy_PolicyDefinition struct to the
// list PolicyDefinition of RoutingPolicy. If the key value(s) specified in
// the supplied RoutingPolicy_PolicyDefinition already exist in the list, an error is
// returned.
func (t *RoutingPolicy) AppendPolicyDefinition(v *RoutingPolicy_PolicyDefinition) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyDefinition == nil {
		t.PolicyDefinition = make(map[string]*RoutingPolicy_PolicyDefinition)
	}

	if _, ok := t.PolicyDefinition[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyDefinition %v", key)
	}

	t.PolicyDefinition[key] = v
	return nil
}

// GetOrCreateDefinedSets retrieves the value of the DefinedSets field
// or returns the existing field if it already exists.
func (t *RoutingPolicy) GetOrCreateDefinedSets() *RoutingPolicy_DefinedSets {
	if t.DefinedSets != nil {
		return t.DefinedSets
	}
	t.DefinedSets = &RoutingPolicy_DefinedSets{}
	return t.DefinedSets
}

// GetDefinedSets returns the value of the DefinedSets struct pointer
// from RoutingPolicy. If the receiver or the field DefinedSets is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy) GetDefinedSets() *RoutingPolicy_DefinedSets {
	if t != nil && t.DefinedSets != nil {
		return t.DefinedSets
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNeighborSet creates a new entry in the NeighborSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewNeighborSet(Name string) (*RoutingPolicy_DefinedSets_NeighborSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborSet == nil {
		t.NeighborSet = make(map[string]*RoutingPolicy_DefinedSets_NeighborSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NeighborSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NeighborSet", key)
	}

	t.NeighborSet[key] = &RoutingPolicy_DefinedSets_NeighborSet{
		Name: &Name,
	}

	return t.NeighborSet[key], nil
}

// RenameNeighborSet renames an entry in the list NeighborSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenameNeighborSet(oldK, newK string) error {
	if _, ok := t.NeighborSet[newK]; ok {
		return fmt.Errorf("key %v already exists in NeighborSet", newK)
	}

	e, ok := t.NeighborSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NeighborSet", oldK)
	}
	e.Name = &newK

	t.NeighborSet[newK] = e
	delete(t.NeighborSet, oldK)
	return nil
}

// GetOrCreateNeighborSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreateNeighborSet(Name string) *RoutingPolicy_DefinedSets_NeighborSet {

	key := Name

	if v, ok := t.NeighborSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighborSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighborSet got unexpected error: %v", err))
	}
	return v
}

// GetNeighborSet retrieves the value with the specified key from
// the NeighborSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetNeighborSet(Name string) *RoutingPolicy_DefinedSets_NeighborSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NeighborSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighborSet deletes the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy_DefinedSets) DeleteNeighborSet(Name string) {
	key := Name

	delete(t.NeighborSet, key)
}

// AppendNeighborSet appends the supplied RoutingPolicy_DefinedSets_NeighborSet struct to the
// list NeighborSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_NeighborSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendNeighborSet(v *RoutingPolicy_DefinedSets_NeighborSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborSet == nil {
		t.NeighborSet = make(map[string]*RoutingPolicy_DefinedSets_NeighborSet)
	}

	if _, ok := t.NeighborSet[key]; ok {
		return fmt.Errorf("duplicate key for list NeighborSet %v", key)
	}

	t.NeighborSet[key] = v
	return nil
}

// NewPrefixSet creates a new entry in the PrefixSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewPrefixSet(Name string) (*RoutingPolicy_DefinedSets_PrefixSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*RoutingPolicy_DefinedSets_PrefixSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSet", key)
	}

	t.PrefixSet[key] = &RoutingPolicy_DefinedSets_PrefixSet{
		Name: &Name,
	}

	return t.PrefixSet[key], nil
}

// RenamePrefixSet renames an entry in the list PrefixSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenamePrefixSet(oldK, newK string) error {
	if _, ok := t.PrefixSet[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSet", newK)
	}

	e, ok := t.PrefixSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSet", oldK)
	}
	e.Name = &newK

	t.PrefixSet[newK] = e
	delete(t.PrefixSet, oldK)
	return nil
}

// GetOrCreatePrefixSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreatePrefixSet(Name string) *RoutingPolicy_DefinedSets_PrefixSet {

	key := Name

	if v, ok := t.PrefixSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSet got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSet retrieves the value with the specified key from
// the PrefixSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetPrefixSet(Name string) *RoutingPolicy_DefinedSets_PrefixSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PrefixSet[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSet deletes the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy_DefinedSets) DeletePrefixSet(Name string) {
	key := Name

	delete(t.PrefixSet, key)
}

// AppendPrefixSet appends the supplied RoutingPolicy_DefinedSets_PrefixSet struct to the
// list PrefixSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_PrefixSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendPrefixSet(v *RoutingPolicy_DefinedSets_PrefixSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*RoutingPolicy_DefinedSets_PrefixSet)
	}

	if _, ok := t.PrefixSet[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSet %v", key)
	}

	t.PrefixSet[key] = v
	return nil
}

// NewTagSet creates a new entry in the TagSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewTagSet(Name string) (*RoutingPolicy_DefinedSets_TagSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*RoutingPolicy_DefinedSets_TagSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TagSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TagSet", key)
	}

	t.TagSet[key] = &RoutingPolicy_DefinedSets_TagSet{
		Name: &Name,
	}

	return t.TagSet[key], nil
}

// RenameTagSet renames an entry in the list TagSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenameTagSet(oldK, newK string) error {
	if _, ok := t.TagSet[newK]; ok {
		return fmt.Errorf("key %v already exists in TagSet", newK)
	}

	e, ok := t.TagSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TagSet", oldK)
	}
	e.Name = &newK

	t.TagSet[newK] = e
	delete(t.TagSet, oldK)
	return nil
}

// GetOrCreateTagSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreateTagSet(Name string) *RoutingPolicy_DefinedSets_TagSet {

	key := Name

	if v, ok := t.TagSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTagSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTagSet got unexpected error: %v", err))
	}
	return v
}

// GetTagSet retrieves the value with the specified key from
// the TagSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetTagSet(Name string) *RoutingPolicy_DefinedSets_TagSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TagSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteTagSet deletes the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy_DefinedSets) DeleteTagSet(Name string) {
	key := Name

	delete(t.TagSet, key)
}

// AppendTagSet appends the supplied RoutingPolicy_DefinedSets_TagSet struct to the
// list TagSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_TagSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendTagSet(v *RoutingPolicy_DefinedSets_TagSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*RoutingPolicy_DefinedSets_TagSet)
	}

	if _, ok := t.TagSet[key]; ok {
		return fmt.Errorf("duplicate key for list TagSet %v", key)
	}

	t.TagSet[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_DefinedSets) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_NeighborSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_NeighborSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_DefinedSets_NeighborSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_NeighborSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_NeighborSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// RoutingPolicy_DefinedSets_PrefixSet struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets_PrefixSet) NewPrefix(IpPrefix string, MasklengthRange string) (*RoutingPolicy_DefinedSets_PrefixSet_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key]*RoutingPolicy_DefinedSets_PrefixSet_Prefix)
	}

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &RoutingPolicy_DefinedSets_PrefixSet_Prefix{
		IpPrefix:        &IpPrefix,
		MasklengthRange: &MasklengthRange,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the RoutingPolicy_DefinedSets_PrefixSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets_PrefixSet) RenamePrefix(oldK, newK RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.IpPrefix = &newK.IpPrefix
	e.MasklengthRange = &newK.MasklengthRange

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets_PrefixSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets_PrefixSet) GetOrCreatePrefix(IpPrefix string, MasklengthRange string) *RoutingPolicy_DefinedSets_PrefixSet_Prefix {

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(IpPrefix, MasklengthRange)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of RoutingPolicy_DefinedSets_PrefixSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets_PrefixSet) GetPrefix(IpPrefix string, MasklengthRange string) *RoutingPolicy_DefinedSets_PrefixSet_Prefix {

	if t == nil {
		return nil
	}

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets_PrefixSet. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy_DefinedSets_PrefixSet) DeletePrefix(IpPrefix string, MasklengthRange string) {
	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied RoutingPolicy_DefinedSets_PrefixSet_Prefix struct to the
// list Prefix of RoutingPolicy_DefinedSets_PrefixSet. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_PrefixSet_Prefix already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets_PrefixSet) AppendPrefix(v *RoutingPolicy_DefinedSets_PrefixSet_Prefix) error {
	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{IpPrefix: *v.IpPrefix, MasklengthRange: *v.MasklengthRange}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key]*RoutingPolicy_DefinedSets_PrefixSet_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_PrefixSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_PrefixSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_DefinedSets_PrefixSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_PrefixSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_PrefixSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_PrefixSet_Prefix struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_PrefixSet_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.MasklengthRange == nil {
		return nil, fmt.Errorf("nil value for key MasklengthRange")
	}

	return map[string]interface{}{
		"ip-prefix":        *t.IpPrefix,
		"masklength-range": *t.MasklengthRange,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_DefinedSets_PrefixSet_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_PrefixSet_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_PrefixSet_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_TagSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_TagSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_DefinedSets_TagSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_TagSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_TagSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewStatement creates a new entry in the Statement list of the
// RoutingPolicy_PolicyDefinition struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_PolicyDefinition) NewStatement(Name string) (*RoutingPolicy_PolicyDefinition_Statement, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[string]*RoutingPolicy_PolicyDefinition_Statement)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Statement[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Statement", key)
	}

	t.Statement[key] = &RoutingPolicy_PolicyDefinition_Statement{
		Name: &Name,
	}

	return t.Statement[key], nil
}

// RenameStatement renames an entry in the list Statement within
// the RoutingPolicy_PolicyDefinition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_PolicyDefinition) RenameStatement(oldK, newK string) error {
	if _, ok := t.Statement[newK]; ok {
		return fmt.Errorf("key %v already exists in Statement", newK)
	}

	e, ok := t.Statement[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Statement", oldK)
	}
	e.Name = &newK

	t.Statement[newK] = e
	delete(t.Statement, oldK)
	return nil
}

// GetOrCreateStatement retrieves the value with the specified keys from
// the receiver RoutingPolicy_PolicyDefinition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_PolicyDefinition) GetOrCreateStatement(Name string) *RoutingPolicy_PolicyDefinition_Statement {

	key := Name

	if v, ok := t.Statement[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatement(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatement got unexpected error: %v", err))
	}
	return v
}

// GetStatement retrieves the value with the specified key from
// the Statement map field of RoutingPolicy_PolicyDefinition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_PolicyDefinition) GetStatement(Name string) *RoutingPolicy_PolicyDefinition_Statement {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Statement[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatement deletes the value with the specified keys from
// the receiver RoutingPolicy_PolicyDefinition. If there is no such element, the function
// is a no-op.
func (t *RoutingPolicy_PolicyDefinition) DeleteStatement(Name string) {
	key := Name

	delete(t.Statement, key)
}

// AppendStatement appends the supplied RoutingPolicy_PolicyDefinition_Statement struct to the
// list Statement of RoutingPolicy_PolicyDefinition. If the key value(s) specified in
// the supplied RoutingPolicy_PolicyDefinition_Statement already exist in the list, an error is
// returned.
func (t *RoutingPolicy_PolicyDefinition) AppendStatement(v *RoutingPolicy_PolicyDefinition_Statement) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[string]*RoutingPolicy_PolicyDefinition_Statement)
	}

	if _, ok := t.Statement[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}

	t.Statement[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_PolicyDefinition struct, which is a YANG list entry.
func (t *RoutingPolicy_PolicyDefinition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateActions retrieves the value of the Actions field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement) GetOrCreateActions() *RoutingPolicy_PolicyDefinition_Statement_Actions {
	if t.Actions != nil {
		return t.Actions
	}
	t.Actions = &RoutingPolicy_PolicyDefinition_Statement_Actions{}
	return t.Actions
}

// GetOrCreateConditions retrieves the value of the Conditions field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement) GetOrCreateConditions() *RoutingPolicy_PolicyDefinition_Statement_Conditions {
	if t.Conditions != nil {
		return t.Conditions
	}
	t.Conditions = &RoutingPolicy_PolicyDefinition_Statement_Conditions{}
	return t.Conditions
}

// GetActions returns the value of the Actions struct pointer
// from RoutingPolicy_PolicyDefinition_Statement. If the receiver or the field Actions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement) GetActions() *RoutingPolicy_PolicyDefinition_Statement_Actions {
	if t != nil && t.Actions != nil {
		return t.Actions
	}
	return nil
}

// GetConditions returns the value of the Conditions struct pointer
// from RoutingPolicy_PolicyDefinition_Statement. If the receiver or the field Conditions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement) GetConditions() *RoutingPolicy_PolicyDefinition_Statement_Conditions {
	if t != nil && t.Conditions != nil {
		return t.Conditions
	}
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_PolicyDefinition_Statement struct, which is a YANG list entry.
func (t *RoutingPolicy_PolicyDefinition_Statement) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Actions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateMatchInterface retrieves the value of the MatchInterface field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchInterface() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface {
	if t.MatchInterface != nil {
		return t.MatchInterface
	}
	t.MatchInterface = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface{}
	return t.MatchInterface
}

// GetOrCreateMatchNeighborSet retrieves the value of the MatchNeighborSet field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchNeighborSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet {
	if t.MatchNeighborSet != nil {
		return t.MatchNeighborSet
	}
	t.MatchNeighborSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet{}
	return t.MatchNeighborSet
}

// GetOrCreateMatchPrefixSet retrieves the value of the MatchPrefixSet field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchPrefixSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet {
	if t.MatchPrefixSet != nil {
		return t.MatchPrefixSet
	}
	t.MatchPrefixSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet{}
	return t.MatchPrefixSet
}

// GetOrCreateMatchTagSet retrieves the value of the MatchTagSet field
// or returns the existing field if it already exists.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchTagSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet {
	if t.MatchTagSet != nil {
		return t.MatchTagSet
	}
	t.MatchTagSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet{}
	return t.MatchTagSet
}

// GetMatchInterface returns the value of the MatchInterface struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchInterface() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface {
	if t != nil && t.MatchInterface != nil {
		return t.MatchInterface
	}
	return nil
}

// GetMatchNeighborSet returns the value of the MatchNeighborSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchNeighborSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchNeighborSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet {
	if t != nil && t.MatchNeighborSet != nil {
		return t.MatchNeighborSet
	}
	return nil
}

// GetMatchPrefixSet returns the value of the MatchPrefixSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchPrefixSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchPrefixSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet {
	if t != nil && t.MatchPrefixSet != nil {
		return t.MatchPrefixSet
	}
	return nil
}

// GetMatchTagSet returns the value of the MatchTagSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchTagSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchTagSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet {
	if t != nil && t.MatchTagSet != nil {
		return t.MatchTagSet
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// Stp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp) NewInterface(Name string) (*Stp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp) GetOrCreateInterface(Name string) *Stp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp) GetInterface(Name string) *Stp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Stp. If there is no such element, the function
// is a no-op.
func (t *Stp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Stp_Interface struct to the
// list Interface of Stp. If the key value(s) specified in
// the supplied Stp_Interface already exist in the list, an error is
// returned.
func (t *Stp) AppendInterface(v *Stp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// Stp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp) NewVlan(VlanId uint16) (*Stp_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*Stp_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &Stp_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the Stp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver Stp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp) GetOrCreateVlan(VlanId uint16) *Stp_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of Stp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp) GetVlan(VlanId uint16) *Stp_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver Stp. If there is no such element, the function
// is a no-op.
func (t *Stp) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied Stp_Vlan struct to the
// list Vlan of Stp. If the key value(s) specified in
// the supplied Stp_Vlan already exist in the list, an error is
// returned.
func (t *Stp) AppendVlan(v *Stp_Vlan) error {
	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*Stp_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *Stp) GetOrCreateGlobal() *Stp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &Stp_Global{}
	return t.Global
}

// GetOrCreateMstp retrieves the value of the Mstp field
// or returns the existing field if it already exists.
func (t *Stp) GetOrCreateMstp() *Stp_Mstp {
	if t.Mstp != nil {
		return t.Mstp
	}
	t.Mstp = &Stp_Mstp{}
	return t.Mstp
}

// GetOrCreateRstp retrieves the value of the Rstp field
// or returns the existing field if it already exists.
func (t *Stp) GetOrCreateRstp() *Stp_Rstp {
	if t.Rstp != nil {
		return t.Rstp
	}
	t.Rstp = &Stp_Rstp{}
	return t.Rstp
}

// GetGlobal returns the value of the Global struct pointer
// from Stp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp) GetGlobal() *Stp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetMstp returns the value of the Mstp struct pointer
// from Stp. If the receiver or the field Mstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp) GetMstp() *Stp_Mstp {
	if t != nil && t.Mstp != nil {
		return t.Mstp
	}
	return nil
}

// GetRstp returns the value of the Rstp struct pointer
// from Stp. If the receiver or the field Rstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp) GetRstp() *Stp_Rstp {
	if t != nil && t.Rstp != nil {
		return t.Rstp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Stp_Interface struct, which is a YANG list entry.
func (t *Stp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewMstInstance creates a new entry in the MstInstance list of the
// Stp_Mstp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Mstp) NewMstInstance(MstId uint16) (*Stp_Mstp_MstInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MstInstance == nil {
		t.MstInstance = make(map[uint16]*Stp_Mstp_MstInstance)
	}

	key := MstId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MstInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MstInstance", key)
	}

	t.MstInstance[key] = &Stp_Mstp_MstInstance{
		MstId: &MstId,
	}

	return t.MstInstance[key], nil
}

// RenameMstInstance renames an entry in the list MstInstance within
// the Stp_Mstp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Mstp) RenameMstInstance(oldK, newK uint16) error {
	if _, ok := t.MstInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in MstInstance", newK)
	}

	e, ok := t.MstInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MstInstance", oldK)
	}
	e.MstId = &newK

	t.MstInstance[newK] = e
	delete(t.MstInstance, oldK)
	return nil
}

// GetOrCreateMstInstance retrieves the value with the specified keys from
// the receiver Stp_Mstp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Mstp) GetOrCreateMstInstance(MstId uint16) *Stp_Mstp_MstInstance {

	key := MstId

	if v, ok := t.MstInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMstInstance(MstId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMstInstance got unexpected error: %v", err))
	}
	return v
}

// GetMstInstance retrieves the value with the specified key from
// the MstInstance map field of Stp_Mstp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Mstp) GetMstInstance(MstId uint16) *Stp_Mstp_MstInstance {

	if t == nil {
		return nil
	}

	key := MstId

	if lm, ok := t.MstInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteMstInstance deletes the value with the specified keys from
// the receiver Stp_Mstp. If there is no such element, the function
// is a no-op.
func (t *Stp_Mstp) DeleteMstInstance(MstId uint16) {
	key := MstId

	delete(t.MstInstance, key)
}

// AppendMstInstance appends the supplied Stp_Mstp_MstInstance struct to the
// list MstInstance of Stp_Mstp. If the key value(s) specified in
// the supplied Stp_Mstp_MstInstance already exist in the list, an error is
// returned.
func (t *Stp_Mstp) AppendMstInstance(v *Stp_Mstp_MstInstance) error {
	key := *v.MstId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MstInstance == nil {
		t.MstInstance = make(map[uint16]*Stp_Mstp_MstInstance)
	}

	if _, ok := t.MstInstance[key]; ok {
		return fmt.Errorf("duplicate key for list MstInstance %v", key)
	}

	t.MstInstance[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Mstp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Stp_Mstp_MstInstance struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Mstp_MstInstance) NewInterface(Name string) (*Stp_Mstp_MstInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Mstp_MstInstance_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Mstp_MstInstance_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Mstp_MstInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Mstp_MstInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Mstp_MstInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Mstp_MstInstance) GetOrCreateInterface(Name string) *Stp_Mstp_MstInstance_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Mstp_MstInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Mstp_MstInstance) GetInterface(Name string) *Stp_Mstp_MstInstance_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Stp_Mstp_MstInstance. If there is no such element, the function
// is a no-op.
func (t *Stp_Mstp_MstInstance) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Stp_Mstp_MstInstance_Interface struct to the
// list Interface of Stp_Mstp_MstInstance. If the key value(s) specified in
// the supplied Stp_Mstp_MstInstance_Interface already exist in the list, an error is
// returned.
func (t *Stp_Mstp_MstInstance) AppendInterface(v *Stp_Mstp_MstInstance_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Mstp_MstInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Mstp_MstInstance struct, which is a YANG list entry.
func (t *Stp_Mstp_MstInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MstId == nil {
		return nil, fmt.Errorf("nil value for key MstId")
	}

	return map[string]interface{}{
		"mst-id": *t.MstId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Mstp_MstInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Stp_Mstp_MstInstance_Interface) GetOrCreateCounters() *Stp_Mstp_MstInstance_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Stp_Mstp_MstInstance_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Mstp_MstInstance_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp_Mstp_MstInstance_Interface) GetCounters() *Stp_Mstp_MstInstance_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Mstp_MstInstance_Interface struct, which is a YANG list entry.
func (t *Stp_Mstp_MstInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Mstp_MstInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Mstp_MstInstance_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// Stp_Rstp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Rstp) NewInterface(Name string) (*Stp_Rstp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Rstp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Rstp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Rstp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Rstp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Rstp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Rstp) GetOrCreateInterface(Name string) *Stp_Rstp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Rstp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Rstp) GetInterface(Name string) *Stp_Rstp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Stp_Rstp. If there is no such element, the function
// is a no-op.
func (t *Stp_Rstp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Stp_Rstp_Interface struct to the
// list Interface of Stp_Rstp. If the key value(s) specified in
// the supplied Stp_Rstp_Interface already exist in the list, an error is
// returned.
func (t *Stp_Rstp) AppendInterface(v *Stp_Rstp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Rstp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Rstp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Stp_Rstp_Interface) GetOrCreateCounters() *Stp_Rstp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Stp_Rstp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Rstp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp_Rstp_Interface) GetCounters() *Stp_Rstp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Rstp_Interface struct, which is a YANG list entry.
func (t *Stp_Rstp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Rstp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Rstp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Stp_Vlan struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Vlan) NewInterface(Name string) (*Stp_Vlan_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Vlan_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Vlan_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Vlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Vlan) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Vlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Vlan) GetOrCreateInterface(Name string) *Stp_Vlan_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Vlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Vlan) GetInterface(Name string) *Stp_Vlan_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Stp_Vlan. If there is no such element, the function
// is a no-op.
func (t *Stp_Vlan) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Stp_Vlan_Interface struct to the
// list Interface of Stp_Vlan. If the key value(s) specified in
// the supplied Stp_Vlan_Interface already exist in the list, an error is
// returned.
func (t *Stp_Vlan) AppendInterface(v *Stp_Vlan_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Vlan_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Vlan struct, which is a YANG list entry.
func (t *Stp_Vlan) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VlanId == nil {
		return nil, fmt.Errorf("nil value for key VlanId")
	}

	return map[string]interface{}{
		"vlan-id": *t.VlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Stp_Vlan_Interface) GetOrCreateCounters() *Stp_Vlan_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Stp_Vlan_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Vlan_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Stp_Vlan_Interface) GetCounters() *Stp_Vlan_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Vlan_Interface struct, which is a YANG list entry.
func (t *Stp_Vlan_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Vlan_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *Stp_Vlan_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAlarm creates a new entry in the Alarm list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewAlarm(Id string) (*System_Alarm, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Alarm == nil {
		t.Alarm = make(map[string]*System_Alarm)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Alarm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Alarm", key)
	}

	t.Alarm[key] = &System_Alarm{
		Id: &Id,
	}

	return t.Alarm[key], nil
}

// RenameAlarm renames an entry in the list Alarm within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameAlarm(oldK, newK string) error {
	if _, ok := t.Alarm[newK]; ok {
		return fmt.Errorf("key %v already exists in Alarm", newK)
	}

	e, ok := t.Alarm[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Alarm", oldK)
	}
	e.Id = &newK

	t.Alarm[newK] = e
	delete(t.Alarm, oldK)
	return nil
}

// GetOrCreateAlarm retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateAlarm(Id string) *System_Alarm {

	key := Id

	if v, ok := t.Alarm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAlarm(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAlarm got unexpected error: %v", err))
	}
	return v
}

// GetAlarm retrieves the value with the specified key from
// the Alarm map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetAlarm(Id string) *System_Alarm {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Alarm[key]; ok {
		return lm
	}
	return nil
}

// DeleteAlarm deletes the value with the specified keys from
// the receiver System. If there is no such element, the function
// is a no-op.
func (t *System) DeleteAlarm(Id string) {
	key := Id

	delete(t.Alarm, key)
}

// AppendAlarm appends the supplied System_Alarm struct to the
// list Alarm of System. If the key value(s) specified in
// the supplied System_Alarm already exist in the list, an error is
// returned.
func (t *System) AppendAlarm(v *System_Alarm) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Alarm == nil {
		t.Alarm = make(map[string]*System_Alarm)
	}

	if _, ok := t.Alarm[key]; ok {
		return fmt.Errorf("duplicate key for list Alarm %v", key)
	}

	t.Alarm[key] = v
	return nil
}

// NewCpu creates a new entry in the Cpu list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewCpu(Index System_Cpu_Index_Union) (*System_Cpu, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cpu == nil {
		t.Cpu = make(map[System_Cpu_Index_Union]*System_Cpu)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Cpu[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Cpu", key)
	}

	t.Cpu[key] = &System_Cpu{
		Index: Index,
	}

	return t.Cpu[key], nil
}

// RenameCpu renames an entry in the list Cpu within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameCpu(oldK, newK System_Cpu_Index_Union) error {
	if _, ok := t.Cpu[newK]; ok {
		return fmt.Errorf("key %v already exists in Cpu", newK)
	}

	e, ok := t.Cpu[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Cpu", oldK)
	}
	e.Index = newK

	t.Cpu[newK] = e
	delete(t.Cpu, oldK)
	return nil
}

// GetOrCreateCpu retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateCpu(Index System_Cpu_Index_Union) *System_Cpu {

	key := Index

	if v, ok := t.Cpu[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCpu(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCpu got unexpected error: %v", err))
	}
	return v
}

// GetCpu retrieves the value with the specified key from
// the Cpu map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetCpu(Index System_Cpu_Index_Union) *System_Cpu {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Cpu[key]; ok {
		return lm
	}
	return nil
}

// DeleteCpu deletes the value with the specified keys from
// the receiver System. If there is no such element, the function
// is a no-op.
func (t *System) DeleteCpu(Index System_Cpu_Index_Union) {
	key := Index

	delete(t.Cpu, key)
}

// AppendCpu appends the supplied System_Cpu struct to the
// list Cpu of System. If the key value(s) specified in
// the supplied System_Cpu already exist in the list, an error is
// returned.
func (t *System) AppendCpu(v *System_Cpu) error {
	key := v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cpu == nil {
		t.Cpu = make(map[System_Cpu_Index_Union]*System_Cpu)
	}

	if _, ok := t.Cpu[key]; ok {
		return fmt.Errorf("duplicate key for list Cpu %v", key)
	}

	t.Cpu[key] = v
	return nil
}

// NewProcess creates a new entry in the Process list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewProcess(Pid uint64) (*System_Process, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Process == nil {
		t.Process = make(map[uint64]*System_Process)
	}

	key := Pid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Process[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Process", key)
	}

	t.Process[key] = &System_Process{
		Pid: &Pid,
	}

	return t.Process[key], nil
}

// RenameProcess renames an entry in the list Process within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameProcess(oldK, newK uint64) error {
	if _, ok := t.Process[newK]; ok {
		return fmt.Errorf("key %v already exists in Process", newK)
	}

	e, ok := t.Process[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Process", oldK)
	}
	e.Pid = &newK

	t.Process[newK] = e
	delete(t.Process, oldK)
	return nil
}

// GetOrCreateProcess retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateProcess(Pid uint64) *System_Process {

	key := Pid

	if v, ok := t.Process[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProcess(Pid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProcess got unexpected error: %v", err))
	}
	return v
}

// GetProcess retrieves the value with the specified key from
// the Process map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetProcess(Pid uint64) *System_Process {

	if t == nil {
		return nil
	}

	key := Pid

	if lm, ok := t.Process[key]; ok {
		return lm
	}
	return nil
}

// DeleteProcess deletes the value with the specified keys from
// the receiver System. If there is no such element, the function
// is a no-op.
func (t *System) DeleteProcess(Pid uint64) {
	key := Pid

	delete(t.Process, key)
}

// AppendProcess appends the supplied System_Process struct to the
// list Process of System. If the key value(s) specified in
// the supplied System_Process already exist in the list, an error is
// returned.
func (t *System) AppendProcess(v *System_Process) error {
	key := *v.Pid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Process == nil {
		t.Process = make(map[uint64]*System_Process)
	}

	if _, ok := t.Process[key]; ok {
		return fmt.Errorf("duplicate key for list Process %v", key)
	}

	t.Process[key] = v
	return nil
}

// GetOrCreateAaa retrieves the value of the Aaa field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateAaa() *System_Aaa {
	if t.Aaa != nil {
		return t.Aaa
	}
	t.Aaa = &System_Aaa{}
	return t.Aaa
}

// GetOrCreateClock retrieves the value of the Clock field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateClock() *System_Clock {
	if t.Clock != nil {
		return t.Clock
	}
	t.Clock = &System_Clock{}
	return t.Clock
}

// GetOrCreateDns retrieves the value of the Dns field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateDns() *System_Dns {
	if t.Dns != nil {
		return t.Dns
	}
	t.Dns = &System_Dns{}
	return t.Dns
}

// GetOrCreateGrpcServer retrieves the value of the GrpcServer field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateGrpcServer() *System_GrpcServer {
	if t.GrpcServer != nil {
		return t.GrpcServer
	}
	t.GrpcServer = &System_GrpcServer{}
	return t.GrpcServer
}

// GetOrCreateLogging retrieves the value of the Logging field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateLogging() *System_Logging {
	if t.Logging != nil {
		return t.Logging
	}
	t.Logging = &System_Logging{}
	return t.Logging
}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateMemory() *System_Memory {
	if t.Memory != nil {
		return t.Memory
	}
	t.Memory = &System_Memory{}
	return t.Memory
}

// GetOrCreateNtp retrieves the value of the Ntp field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateNtp() *System_Ntp {
	if t.Ntp != nil {
		return t.Ntp
	}
	t.Ntp = &System_Ntp{}
	return t.Ntp
}

// GetOrCreateSshServer retrieves the value of the SshServer field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateSshServer() *System_SshServer {
	if t.SshServer != nil {
		return t.SshServer
	}
	t.SshServer = &System_SshServer{}
	return t.SshServer
}

// GetOrCreateTelnetServer retrieves the value of the TelnetServer field
// or returns the existing field if it already exists.
func (t *System) GetOrCreateTelnetServer() *System_TelnetServer {
	if t.TelnetServer != nil {
		return t.TelnetServer
	}
	t.TelnetServer = &System_TelnetServer{}
	return t.TelnetServer
}

// GetAaa returns the value of the Aaa struct pointer
// from System. If the receiver or the field Aaa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetAaa() *System_Aaa {
	if t != nil && t.Aaa != nil {
		return t.Aaa
	}
	return nil
}

// GetClock returns the value of the Clock struct pointer
// from System. If the receiver or the field Clock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetClock() *System_Clock {
	if t != nil && t.Clock != nil {
		return t.Clock
	}
	return nil
}

// GetDns returns the value of the Dns struct pointer
// from System. If the receiver or the field Dns is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetDns() *System_Dns {
	if t != nil && t.Dns != nil {
		return t.Dns
	}
	return nil
}

// GetGrpcServer returns the value of the GrpcServer struct pointer
// from System. If the receiver or the field GrpcServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetGrpcServer() *System_GrpcServer {
	if t != nil && t.GrpcServer != nil {
		return t.GrpcServer
	}
	return nil
}

// GetLogging returns the value of the Logging struct pointer
// from System. If the receiver or the field Logging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetLogging() *System_Logging {
	if t != nil && t.Logging != nil {
		return t.Logging
	}
	return nil
}

// GetMemory returns the value of the Memory struct pointer
// from System. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetMemory() *System_Memory {
	if t != nil && t.Memory != nil {
		return t.Memory
	}
	return nil
}

// GetNtp returns the value of the Ntp struct pointer
// from System. If the receiver or the field Ntp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetNtp() *System_Ntp {
	if t != nil && t.Ntp != nil {
		return t.Ntp
	}
	return nil
}

// GetSshServer returns the value of the SshServer struct pointer
// from System. If the receiver or the field SshServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetSshServer() *System_SshServer {
	if t != nil && t.SshServer != nil {
		return t.SshServer
	}
	return nil
}

// GetTelnetServer returns the value of the TelnetServer struct pointer
// from System. If the receiver or the field TelnetServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System) GetTelnetServer() *System_TelnetServer {
	if t != nil && t.TelnetServer != nil {
		return t.TelnetServer
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewServerGroup creates a new entry in the ServerGroup list of the
// System_Aaa struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa) NewServerGroup(Name string) (*System_Aaa_ServerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*System_Aaa_ServerGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerGroup", key)
	}

	t.ServerGroup[key] = &System_Aaa_ServerGroup{
		Name: &Name,
	}

	return t.ServerGroup[key], nil
}

// RenameServerGroup renames an entry in the list ServerGroup within
// the System_Aaa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa) RenameServerGroup(oldK, newK string) error {
	if _, ok := t.ServerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in ServerGroup", newK)
	}

	e, ok := t.ServerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ServerGroup", oldK)
	}
	e.Name = &newK

	t.ServerGroup[newK] = e
	delete(t.ServerGroup, oldK)
	return nil
}

// GetOrCreateServerGroup retrieves the value with the specified keys from
// the receiver System_Aaa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa) GetOrCreateServerGroup(Name string) *System_Aaa_ServerGroup {

	key := Name

	if v, ok := t.ServerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServerGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServerGroup got unexpected error: %v", err))
	}
	return v
}

// GetServerGroup retrieves the value with the specified key from
// the ServerGroup map field of System_Aaa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa) GetServerGroup(Name string) *System_Aaa_ServerGroup {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ServerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteServerGroup deletes the value with the specified keys from
// the receiver System_Aaa. If there is no such element, the function
// is a no-op.
func (t *System_Aaa) DeleteServerGroup(Name string) {
	key := Name

	delete(t.ServerGroup, key)
}

// AppendServerGroup appends the supplied System_Aaa_ServerGroup struct to the
// list ServerGroup of System_Aaa. If the key value(s) specified in
// the supplied System_Aaa_ServerGroup already exist in the list, an error is
// returned.
func (t *System_Aaa) AppendServerGroup(v *System_Aaa_ServerGroup) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*System_Aaa_ServerGroup)
	}

	if _, ok := t.ServerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list ServerGroup %v", key)
	}

	t.ServerGroup[key] = v
	return nil
}

// GetOrCreateAccounting retrieves the value of the Accounting field
// or returns the existing field if it already exists.
func (t *System_Aaa) GetOrCreateAccounting() *System_Aaa_Accounting {
	if t.Accounting != nil {
		return t.Accounting
	}
	t.Accounting = &System_Aaa_Accounting{}
	return t.Accounting
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *System_Aaa) GetOrCreateAuthentication() *System_Aaa_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &System_Aaa_Authentication{}
	return t.Authentication
}

// GetOrCreateAuthorization retrieves the value of the Authorization field
// or returns the existing field if it already exists.
func (t *System_Aaa) GetOrCreateAuthorization() *System_Aaa_Authorization {
	if t.Authorization != nil {
		return t.Authorization
	}
	t.Authorization = &System_Aaa_Authorization{}
	return t.Authorization
}

// GetAccounting returns the value of the Accounting struct pointer
// from System_Aaa. If the receiver or the field Accounting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa) GetAccounting() *System_Aaa_Accounting {
	if t != nil && t.Accounting != nil {
		return t.Accounting
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from System_Aaa. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa) GetAuthentication() *System_Aaa_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetAuthorization returns the value of the Authorization struct pointer
// from System_Aaa. If the receiver or the field Authorization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa) GetAuthorization() *System_Aaa_Authorization {
	if t != nil && t.Authorization != nil {
		return t.Authorization
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEvent creates a new entry in the Event list of the
// System_Aaa_Accounting struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Accounting) NewEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) (*System_Aaa_Accounting_Event, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE]*System_Aaa_Accounting_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &System_Aaa_Accounting_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// RenameEvent renames an entry in the list Event within
// the System_Aaa_Accounting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Accounting) RenameEvent(oldK, newK E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) error {
	if _, ok := t.Event[newK]; ok {
		return fmt.Errorf("key %v already exists in Event", newK)
	}

	e, ok := t.Event[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Event", oldK)
	}
	e.EventType = newK

	t.Event[newK] = e
	delete(t.Event, oldK)
	return nil
}

// GetOrCreateEvent retrieves the value with the specified keys from
// the receiver System_Aaa_Accounting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Accounting) GetOrCreateEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) *System_Aaa_Accounting_Event {

	key := EventType

	if v, ok := t.Event[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvent(EventType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvent got unexpected error: %v", err))
	}
	return v
}

// GetEvent retrieves the value with the specified key from
// the Event map field of System_Aaa_Accounting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Accounting) GetEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) *System_Aaa_Accounting_Event {

	if t == nil {
		return nil
	}

	key := EventType

	if lm, ok := t.Event[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvent deletes the value with the specified keys from
// the receiver System_Aaa_Accounting. If there is no such element, the function
// is a no-op.
func (t *System_Aaa_Accounting) DeleteEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) {
	key := EventType

	delete(t.Event, key)
}

// AppendEvent appends the supplied System_Aaa_Accounting_Event struct to the
// list Event of System_Aaa_Accounting. If the key value(s) specified in
// the supplied System_Aaa_Accounting_Event already exist in the list, an error is
// returned.
func (t *System_Aaa_Accounting) AppendEvent(v *System_Aaa_Accounting_Event) error {
	key := v.EventType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE]*System_Aaa_Accounting_Event)
	}

	if _, ok := t.Event[key]; ok {
		return fmt.Errorf("duplicate key for list Event %v", key)
	}

	t.Event[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Accounting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Accounting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Accounting) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Aaa_Accounting_Event struct, which is a YANG list entry.
func (t *System_Aaa_Accounting_Event) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Accounting_Event) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Accounting_Event"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Accounting_Event) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewUser creates a new entry in the User list of the
// System_Aaa_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Authentication) NewUser(Username string) (*System_Aaa_Authentication_User, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*System_Aaa_Authentication_User)
	}

	key := Username

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &System_Aaa_Authentication_User{
		Username: &Username,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the System_Aaa_Authentication struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Authentication) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Username = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver System_Aaa_Authentication. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Authentication) GetOrCreateUser(Username string) *System_Aaa_Authentication_User {

	key := Username

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Username)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of System_Aaa_Authentication. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Authentication) GetUser(Username string) *System_Aaa_Authentication_User {

	if t == nil {
		return nil
	}

	key := Username

	if lm, ok := t.User[key]; ok {
		return lm
	}
	return nil
}

// DeleteUser deletes the value with the specified keys from
// the receiver System_Aaa_Authentication. If there is no such element, the function
// is a no-op.
func (t *System_Aaa_Authentication) DeleteUser(Username string) {
	key := Username

	delete(t.User, key)
}

// AppendUser appends the supplied System_Aaa_Authentication_User struct to the
// list User of System_Aaa_Authentication. If the key value(s) specified in
// the supplied System_Aaa_Authentication_User already exist in the list, an error is
// returned.
func (t *System_Aaa_Authentication) AppendUser(v *System_Aaa_Authentication_User) error {
	key := *v.Username

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*System_Aaa_Authentication_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// GetOrCreateAdminUser retrieves the value of the AdminUser field
// or returns the existing field if it already exists.
func (t *System_Aaa_Authentication) GetOrCreateAdminUser() *System_Aaa_Authentication_AdminUser {
	if t.AdminUser != nil {
		return t.AdminUser
	}
	t.AdminUser = &System_Aaa_Authentication_AdminUser{}
	return t.AdminUser
}

// GetAdminUser returns the value of the AdminUser struct pointer
// from System_Aaa_Authentication. If the receiver or the field AdminUser is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa_Authentication) GetAdminUser() *System_Aaa_Authentication_AdminUser {
	if t != nil && t.AdminUser != nil {
		return t.AdminUser
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Authentication_AdminUser) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication_AdminUser"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication_AdminUser) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the System_Aaa_Authentication_User struct, which is a YANG list entry.
func (t *System_Aaa_Authentication_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Username == nil {
		return nil, fmt.Errorf("nil value for key Username")
	}

	return map[string]interface{}{
		"username": *t.Username,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Authentication_User) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEvent creates a new entry in the Event list of the
// System_Aaa_Authorization struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Authorization) NewEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) (*System_Aaa_Authorization_Event, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE]*System_Aaa_Authorization_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &System_Aaa_Authorization_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// RenameEvent renames an entry in the list Event within
// the System_Aaa_Authorization struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Authorization) RenameEvent(oldK, newK E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) error {
	if _, ok := t.Event[newK]; ok {
		return fmt.Errorf("key %v already exists in Event", newK)
	}

	e, ok := t.Event[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Event", oldK)
	}
	e.EventType = newK

	t.Event[newK] = e
	delete(t.Event, oldK)
	return nil
}

// GetOrCreateEvent retrieves the value with the specified keys from
// the receiver System_Aaa_Authorization. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Authorization) GetOrCreateEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) *System_Aaa_Authorization_Event {

	key := EventType

	if v, ok := t.Event[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvent(EventType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvent got unexpected error: %v", err))
	}
	return v
}

// GetEvent retrieves the value with the specified key from
// the Event map field of System_Aaa_Authorization. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Authorization) GetEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) *System_Aaa_Authorization_Event {

	if t == nil {
		return nil
	}

	key := EventType

	if lm, ok := t.Event[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvent deletes the value with the specified keys from
// the receiver System_Aaa_Authorization. If there is no such element, the function
// is a no-op.
func (t *System_Aaa_Authorization) DeleteEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) {
	key := EventType

	delete(t.Event, key)
}

// AppendEvent appends the supplied System_Aaa_Authorization_Event struct to the
// list Event of System_Aaa_Authorization. If the key value(s) specified in
// the supplied System_Aaa_Authorization_Event already exist in the list, an error is
// returned.
func (t *System_Aaa_Authorization) AppendEvent(v *System_Aaa_Authorization_Event) error {
	key := v.EventType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE]*System_Aaa_Authorization_Event)
	}

	if _, ok := t.Event[key]; ok {
		return fmt.Errorf("duplicate key for list Event %v", key)
	}

	t.Event[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Authorization) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authorization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authorization) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Aaa_Authorization_Event struct, which is a YANG list entry.
func (t *System_Aaa_Authorization_Event) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_Authorization_Event) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authorization_Event"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authorization_Event) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewServer creates a new entry in the Server list of the
// System_Aaa_ServerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_ServerGroup) NewServer(Address string) (*System_Aaa_ServerGroup_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Aaa_ServerGroup_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Aaa_ServerGroup_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Aaa_ServerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_ServerGroup) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Aaa_ServerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_ServerGroup) GetOrCreateServer(Address string) *System_Aaa_ServerGroup_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Aaa_ServerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_ServerGroup) GetServer(Address string) *System_Aaa_ServerGroup_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver System_Aaa_ServerGroup. If there is no such element, the function
// is a no-op.
func (t *System_Aaa_ServerGroup) DeleteServer(Address string) {
	key := Address

	delete(t.Server, key)
}

// AppendServer appends the supplied System_Aaa_ServerGroup_Server struct to the
// list Server of System_Aaa_ServerGroup. If the key value(s) specified in
// the supplied System_Aaa_ServerGroup_Server already exist in the list, an error is
// returned.
func (t *System_Aaa_ServerGroup) AppendServer(v *System_Aaa_ServerGroup_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Aaa_ServerGroup_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the System_Aaa_ServerGroup struct, which is a YANG list entry.
func (t *System_Aaa_ServerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_ServerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateRadius retrieves the value of the Radius field
// or returns the existing field if it already exists.
func (t *System_Aaa_ServerGroup_Server) GetOrCreateRadius() *System_Aaa_ServerGroup_Server_Radius {
	if t.Radius != nil {
		return t.Radius
	}
	t.Radius = &System_Aaa_ServerGroup_Server_Radius{}
	return t.Radius
}

// GetOrCreateTacacs retrieves the value of the Tacacs field
// or returns the existing field if it already exists.
func (t *System_Aaa_ServerGroup_Server) GetOrCreateTacacs() *System_Aaa_ServerGroup_Server_Tacacs {
	if t.Tacacs != nil {
		return t.Tacacs
	}
	t.Tacacs = &System_Aaa_ServerGroup_Server_Tacacs{}
	return t.Tacacs
}

// GetRadius returns the value of the Radius struct pointer
// from System_Aaa_ServerGroup_Server. If the receiver or the field Radius is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa_ServerGroup_Server) GetRadius() *System_Aaa_ServerGroup_Server_Radius {
	if t != nil && t.Radius != nil {
		return t.Radius
	}
	return nil
}

// GetTacacs returns the value of the Tacacs struct pointer
// from System_Aaa_ServerGroup_Server. If the receiver or the field Tacacs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa_ServerGroup_Server) GetTacacs() *System_Aaa_ServerGroup_Server_Tacacs {
	if t != nil && t.Tacacs != nil {
		return t.Tacacs
	}
	return nil
}

// ΛListKeyMap returns the keys of the System_Aaa_ServerGroup_Server struct, which is a YANG list entry.
func (t *System_Aaa_ServerGroup_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_ServerGroup_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *System_Aaa_ServerGroup_Server_Radius) GetOrCreateCounters() *System_Aaa_ServerGroup_Server_Radius_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &System_Aaa_ServerGroup_Server_Radius_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from System_Aaa_ServerGroup_Server_Radius. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Aaa_ServerGroup_Server_Radius) GetCounters() *System_Aaa_ServerGroup_Server_Radius_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_ServerGroup_Server_Radius) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Radius"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Radius) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_ServerGroup_Server_Radius_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Radius_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Radius_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Aaa_ServerGroup_Server_Tacacs) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Tacacs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Tacacs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the System_Alarm struct, which is a YANG list entry.
func (t *System_Alarm) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Alarm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Alarm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Alarm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Clock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Clock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateHardwareInterrupt retrieves the value of the HardwareInterrupt field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateHardwareInterrupt() *System_Cpu_HardwareInterrupt {
	if t.HardwareInterrupt != nil {
		return t.HardwareInterrupt
	}
	t.HardwareInterrupt = &System_Cpu_HardwareInterrupt{}
	return t.HardwareInterrupt
}

// GetOrCreateIdle retrieves the value of the Idle field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateIdle() *System_Cpu_Idle {
	if t.Idle != nil {
		return t.Idle
	}
	t.Idle = &System_Cpu_Idle{}
	return t.Idle
}

// GetOrCreateKernel retrieves the value of the Kernel field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateKernel() *System_Cpu_Kernel {
	if t.Kernel != nil {
		return t.Kernel
	}
	t.Kernel = &System_Cpu_Kernel{}
	return t.Kernel
}

// GetOrCreateNice retrieves the value of the Nice field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateNice() *System_Cpu_Nice {
	if t.Nice != nil {
		return t.Nice
	}
	t.Nice = &System_Cpu_Nice{}
	return t.Nice
}

// GetOrCreateSoftwareInterrupt retrieves the value of the SoftwareInterrupt field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateSoftwareInterrupt() *System_Cpu_SoftwareInterrupt {
	if t.SoftwareInterrupt != nil {
		return t.SoftwareInterrupt
	}
	t.SoftwareInterrupt = &System_Cpu_SoftwareInterrupt{}
	return t.SoftwareInterrupt
}

// GetOrCreateTotal retrieves the value of the Total field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateTotal() *System_Cpu_Total {
	if t.Total != nil {
		return t.Total
	}
	t.Total = &System_Cpu_Total{}
	return t.Total
}

// GetOrCreateUser retrieves the value of the User field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateUser() *System_Cpu_User {
	if t.User != nil {
		return t.User
	}
	t.User = &System_Cpu_User{}
	return t.User
}

// GetOrCreateWait retrieves the value of the Wait field
// or returns the existing field if it already exists.
func (t *System_Cpu) GetOrCreateWait() *System_Cpu_Wait {
	if t.Wait != nil {
		return t.Wait
	}
	t.Wait = &System_Cpu_Wait{}
	return t.Wait
}

// GetHardwareInterrupt returns the value of the HardwareInterrupt struct pointer
// from System_Cpu. If the receiver or the field HardwareInterrupt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetHardwareInterrupt() *System_Cpu_HardwareInterrupt {
	if t != nil && t.HardwareInterrupt != nil {
		return t.HardwareInterrupt
	}
	return nil
}

// GetIdle returns the value of the Idle struct pointer
// from System_Cpu. If the receiver or the field Idle is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetIdle() *System_Cpu_Idle {
	if t != nil && t.Idle != nil {
		return t.Idle
	}
	return nil
}

// GetKernel returns the value of the Kernel struct pointer
// from System_Cpu. If the receiver or the field Kernel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetKernel() *System_Cpu_Kernel {
	if t != nil && t.Kernel != nil {
		return t.Kernel
	}
	return nil
}

// GetNice returns the value of the Nice struct pointer
// from System_Cpu. If the receiver or the field Nice is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetNice() *System_Cpu_Nice {
	if t != nil && t.Nice != nil {
		return t.Nice
	}
	return nil
}

// GetSoftwareInterrupt returns the value of the SoftwareInterrupt struct pointer
// from System_Cpu. If the receiver or the field SoftwareInterrupt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetSoftwareInterrupt() *System_Cpu_SoftwareInterrupt {
	if t != nil && t.SoftwareInterrupt != nil {
		return t.SoftwareInterrupt
	}
	return nil
}

// GetTotal returns the value of the Total struct pointer
// from System_Cpu. If the receiver or the field Total is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetTotal() *System_Cpu_Total {
	if t != nil && t.Total != nil {
		return t.Total
	}
	return nil
}

// GetUser returns the value of the User struct pointer
// from System_Cpu. If the receiver or the field User is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetUser() *System_Cpu_User {
	if t != nil && t.User != nil {
		return t.User
	}
	return nil
}

// GetWait returns the value of the Wait struct pointer
// from System_Cpu. If the receiver or the field Wait is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Cpu) GetWait() *System_Cpu_Wait {
	if t != nil && t.Wait != nil {
		return t.Wait
	}
	return nil
}

// ΛListKeyMap returns the keys of the System_Cpu struct, which is a YANG list entry.
func (t *System_Cpu) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"index": t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_HardwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_HardwareInterrupt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_HardwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_Idle) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Idle"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Idle) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_Kernel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Kernel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Kernel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_Nice) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Nice"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Nice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_SoftwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_SoftwareInterrupt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_SoftwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Total"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_User) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Cpu_Wait) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Wait"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Wait) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewHostEntry creates a new entry in the HostEntry list of the
// System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *System_Dns) NewHostEntry(Hostname string) (*System_Dns_HostEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*System_Dns_HostEntry)
	}

	key := Hostname

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostEntry", key)
	}

	t.HostEntry[key] = &System_Dns_HostEntry{
		Hostname: &Hostname,
	}

	return t.HostEntry[key], nil
}

// RenameHostEntry renames an entry in the list HostEntry within
// the System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Dns) RenameHostEntry(oldK, newK string) error {
	if _, ok := t.HostEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in HostEntry", newK)
	}

	e, ok := t.HostEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HostEntry", oldK)
	}
	e.Hostname = &newK

	t.HostEntry[newK] = e
	delete(t.HostEntry, oldK)
	return nil
}

// GetOrCreateHostEntry retrieves the value with the specified keys from
// the receiver System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Dns) GetOrCreateHostEntry(Hostname string) *System_Dns_HostEntry {

	key := Hostname

	if v, ok := t.HostEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHostEntry(Hostname)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHostEntry got unexpected error: %v", err))
	}
	return v
}

// GetHostEntry retrieves the value with the specified key from
// the HostEntry map field of System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Dns) GetHostEntry(Hostname string) *System_Dns_HostEntry {

	if t == nil {
		return nil
	}

	key := Hostname

	if lm, ok := t.HostEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteHostEntry deletes the value with the specified keys from
// the receiver System_Dns. If there is no such element, the function
// is a no-op.
func (t *System_Dns) DeleteHostEntry(Hostname string) {
	key := Hostname

	delete(t.HostEntry, key)
}

// AppendHostEntry appends the supplied System_Dns_HostEntry struct to the
// list HostEntry of System_Dns. If the key value(s) specified in
// the supplied System_Dns_HostEntry already exist in the list, an error is
// returned.
func (t *System_Dns) AppendHostEntry(v *System_Dns_HostEntry) error {
	key := *v.Hostname

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*System_Dns_HostEntry)
	}

	if _, ok := t.HostEntry[key]; ok {
		return fmt.Errorf("duplicate key for list HostEntry %v", key)
	}

	t.HostEntry[key] = v
	return nil
}

// NewServer creates a new entry in the Server list of the
// System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *System_Dns) NewServer(Address string) (*System_Dns_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Dns_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Dns_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Dns) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Dns) GetOrCreateServer(Address string) *System_Dns_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Dns) GetServer(Address string) *System_Dns_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver System_Dns. If there is no such element, the function
// is a no-op.
func (t *System_Dns) DeleteServer(Address string) {
	key := Address

	delete(t.Server, key)
}

// AppendServer appends the supplied System_Dns_Server struct to the
// list Server of System_Dns. If the key value(s) specified in
// the supplied System_Dns_Server already exist in the list, an error is
// returned.
func (t *System_Dns) AppendServer(v *System_Dns_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Dns_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Dns) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Dns_HostEntry struct, which is a YANG list entry.
func (t *System_Dns_HostEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Hostname == nil {
		return nil, fmt.Errorf("nil value for key Hostname")
	}

	return map[string]interface{}{
		"hostname": *t.Hostname,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Dns_HostEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns_HostEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns_HostEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Dns_Server struct, which is a YANG list entry.
func (t *System_Dns_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Dns_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_GrpcServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_GrpcServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_GrpcServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewRemoteServer creates a new entry in the RemoteServer list of the
// System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging) NewRemoteServer(Host string) (*System_Logging_RemoteServer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*System_Logging_RemoteServer)
	}

	key := Host

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RemoteServer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RemoteServer", key)
	}

	t.RemoteServer[key] = &System_Logging_RemoteServer{
		Host: &Host,
	}

	return t.RemoteServer[key], nil
}

// RenameRemoteServer renames an entry in the list RemoteServer within
// the System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging) RenameRemoteServer(oldK, newK string) error {
	if _, ok := t.RemoteServer[newK]; ok {
		return fmt.Errorf("key %v already exists in RemoteServer", newK)
	}

	e, ok := t.RemoteServer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RemoteServer", oldK)
	}
	e.Host = &newK

	t.RemoteServer[newK] = e
	delete(t.RemoteServer, oldK)
	return nil
}

// GetOrCreateRemoteServer retrieves the value with the specified keys from
// the receiver System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging) GetOrCreateRemoteServer(Host string) *System_Logging_RemoteServer {

	key := Host

	if v, ok := t.RemoteServer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRemoteServer(Host)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRemoteServer got unexpected error: %v", err))
	}
	return v
}

// GetRemoteServer retrieves the value with the specified key from
// the RemoteServer map field of System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging) GetRemoteServer(Host string) *System_Logging_RemoteServer {

	if t == nil {
		return nil
	}

	key := Host

	if lm, ok := t.RemoteServer[key]; ok {
		return lm
	}
	return nil
}

// DeleteRemoteServer deletes the value with the specified keys from
// the receiver System_Logging. If there is no such element, the function
// is a no-op.
func (t *System_Logging) DeleteRemoteServer(Host string) {
	key := Host

	delete(t.RemoteServer, key)
}

// AppendRemoteServer appends the supplied System_Logging_RemoteServer struct to the
// list RemoteServer of System_Logging. If the key value(s) specified in
// the supplied System_Logging_RemoteServer already exist in the list, an error is
// returned.
func (t *System_Logging) AppendRemoteServer(v *System_Logging_RemoteServer) error {
	key := *v.Host

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*System_Logging_RemoteServer)
	}

	if _, ok := t.RemoteServer[key]; ok {
		return fmt.Errorf("duplicate key for list RemoteServer %v", key)
	}

	t.RemoteServer[key] = v
	return nil
}

// GetOrCreateConsole retrieves the value of the Console field
// or returns the existing field if it already exists.
func (t *System_Logging) GetOrCreateConsole() *System_Logging_Console {
	if t.Console != nil {
		return t.Console
	}
	t.Console = &System_Logging_Console{}
	return t.Console
}

// GetConsole returns the value of the Console struct pointer
// from System_Logging. If the receiver or the field Console is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *System_Logging) GetConsole() *System_Logging_Console {
	if t != nil && t.Console != nil {
		return t.Console
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Logging) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewSelector creates a new entry in the Selector list of the
// System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging_Console) NewSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) (*System_Logging_Console_Selector, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_Console_Selector_Key]*System_Logging_Console_Selector)
	}

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Selector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Selector", key)
	}

	t.Selector[key] = &System_Logging_Console_Selector{
		Facility: Facility,
		Severity: Severity,
	}

	return t.Selector[key], nil
}

// RenameSelector renames an entry in the list Selector within
// the System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging_Console) RenameSelector(oldK, newK System_Logging_Console_Selector_Key) error {
	if _, ok := t.Selector[newK]; ok {
		return fmt.Errorf("key %v already exists in Selector", newK)
	}

	e, ok := t.Selector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Selector", oldK)
	}
	e.Facility = newK.Facility
	e.Severity = newK.Severity

	t.Selector[newK] = e
	delete(t.Selector, oldK)
	return nil
}

// GetOrCreateSelector retrieves the value with the specified keys from
// the receiver System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging_Console) GetOrCreateSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_Console_Selector {

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if v, ok := t.Selector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSelector(Facility, Severity)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSelector got unexpected error: %v", err))
	}
	return v
}

// GetSelector retrieves the value with the specified key from
// the Selector map field of System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging_Console) GetSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_Console_Selector {

	if t == nil {
		return nil
	}

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if lm, ok := t.Selector[key]; ok {
		return lm
	}
	return nil
}

// DeleteSelector deletes the value with the specified keys from
// the receiver System_Logging_Console. If there is no such element, the function
// is a no-op.
func (t *System_Logging_Console) DeleteSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) {
	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	delete(t.Selector, key)
}

// AppendSelector appends the supplied System_Logging_Console_Selector struct to the
// list Selector of System_Logging_Console. If the key value(s) specified in
// the supplied System_Logging_Console_Selector already exist in the list, an error is
// returned.
func (t *System_Logging_Console) AppendSelector(v *System_Logging_Console_Selector) error {
	key := System_Logging_Console_Selector_Key{Facility: v.Facility, Severity: v.Severity}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_Console_Selector_Key]*System_Logging_Console_Selector)
	}

	if _, ok := t.Selector[key]; ok {
		return fmt.Errorf("duplicate key for list Selector %v", key)
	}

	t.Selector[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Logging_Console) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_Console"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_Console) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Logging_Console_Selector struct, which is a YANG list entry.
func (t *System_Logging_Console_Selector) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility": t.Facility,
		"severity": t.Severity,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Logging_Console_Selector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_Console_Selector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_Console_Selector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSelector creates a new entry in the Selector list of the
// System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging_RemoteServer) NewSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) (*System_Logging_RemoteServer_Selector, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_RemoteServer_Selector_Key]*System_Logging_RemoteServer_Selector)
	}

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Selector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Selector", key)
	}

	t.Selector[key] = &System_Logging_RemoteServer_Selector{
		Facility: Facility,
		Severity: Severity,
	}

	return t.Selector[key], nil
}

// RenameSelector renames an entry in the list Selector within
// the System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging_RemoteServer) RenameSelector(oldK, newK System_Logging_RemoteServer_Selector_Key) error {
	if _, ok := t.Selector[newK]; ok {
		return fmt.Errorf("key %v already exists in Selector", newK)
	}

	e, ok := t.Selector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Selector", oldK)
	}
	e.Facility = newK.Facility
	e.Severity = newK.Severity

	t.Selector[newK] = e
	delete(t.Selector, oldK)
	return nil
}

// GetOrCreateSelector retrieves the value with the specified keys from
// the receiver System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging_RemoteServer) GetOrCreateSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_RemoteServer_Selector {

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if v, ok := t.Selector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSelector(Facility, Severity)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSelector got unexpected error: %v", err))
	}
	return v
}

// GetSelector retrieves the value with the specified key from
// the Selector map field of System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging_RemoteServer) GetSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_RemoteServer_Selector {

	if t == nil {
		return nil
	}

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if lm, ok := t.Selector[key]; ok {
		return lm
	}
	return nil
}

// DeleteSelector deletes the value with the specified keys from
// the receiver System_Logging_RemoteServer. If there is no such element, the function
// is a no-op.
func (t *System_Logging_RemoteServer) DeleteSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) {
	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	delete(t.Selector, key)
}

// AppendSelector appends the supplied System_Logging_RemoteServer_Selector struct to the
// list Selector of System_Logging_RemoteServer. If the key value(s) specified in
// the supplied System_Logging_RemoteServer_Selector already exist in the list, an error is
// returned.
func (t *System_Logging_RemoteServer) AppendSelector(v *System_Logging_RemoteServer_Selector) error {
	key := System_Logging_RemoteServer_Selector_Key{Facility: v.Facility, Severity: v.Severity}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_RemoteServer_Selector_Key]*System_Logging_RemoteServer_Selector)
	}

	if _, ok := t.Selector[key]; ok {
		return fmt.Errorf("duplicate key for list Selector %v", key)
	}

	t.Selector[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the System_Logging_RemoteServer struct, which is a YANG list entry.
func (t *System_Logging_RemoteServer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Host == nil {
		return nil, fmt.Errorf("nil value for key Host")
	}

	return map[string]interface{}{
		"host": *t.Host,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Logging_RemoteServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_RemoteServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_RemoteServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Logging_RemoteServer_Selector struct, which is a YANG list entry.
func (t *System_Logging_RemoteServer_Selector) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility": t.Facility,
		"severity": t.Severity,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Logging_RemoteServer_Selector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_RemoteServer_Selector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_RemoteServer_Selector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Memory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Memory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNtpKey creates a new entry in the NtpKey list of the
// System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *System_Ntp) NewNtpKey(KeyId uint16) (*System_Ntp_NtpKey, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NtpKey == nil {
		t.NtpKey = make(map[uint16]*System_Ntp_NtpKey)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NtpKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NtpKey", key)
	}

	t.NtpKey[key] = &System_Ntp_NtpKey{
		KeyId: &KeyId,
	}

	return t.NtpKey[key], nil
}

// RenameNtpKey renames an entry in the list NtpKey within
// the System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Ntp) RenameNtpKey(oldK, newK uint16) error {
	if _, ok := t.NtpKey[newK]; ok {
		return fmt.Errorf("key %v already exists in NtpKey", newK)
	}

	e, ok := t.NtpKey[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NtpKey", oldK)
	}
	e.KeyId = &newK

	t.NtpKey[newK] = e
	delete(t.NtpKey, oldK)
	return nil
}

// GetOrCreateNtpKey retrieves the value with the specified keys from
// the receiver System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Ntp) GetOrCreateNtpKey(KeyId uint16) *System_Ntp_NtpKey {

	key := KeyId

	if v, ok := t.NtpKey[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNtpKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNtpKey got unexpected error: %v", err))
	}
	return v
}

// GetNtpKey retrieves the value with the specified key from
// the NtpKey map field of System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Ntp) GetNtpKey(KeyId uint16) *System_Ntp_NtpKey {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.NtpKey[key]; ok {
		return lm
	}
	return nil
}

// DeleteNtpKey deletes the value with the specified keys from
// the receiver System_Ntp. If there is no such element, the function
// is a no-op.
func (t *System_Ntp) DeleteNtpKey(KeyId uint16) {
	key := KeyId

	delete(t.NtpKey, key)
}

// AppendNtpKey appends the supplied System_Ntp_NtpKey struct to the
// list NtpKey of System_Ntp. If the key value(s) specified in
// the supplied System_Ntp_NtpKey already exist in the list, an error is
// returned.
func (t *System_Ntp) AppendNtpKey(v *System_Ntp_NtpKey) error {
	key := *v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NtpKey == nil {
		t.NtpKey = make(map[uint16]*System_Ntp_NtpKey)
	}

	if _, ok := t.NtpKey[key]; ok {
		return fmt.Errorf("duplicate key for list NtpKey %v", key)
	}

	t.NtpKey[key] = v
	return nil
}

// NewServer creates a new entry in the Server list of the
// System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *System_Ntp) NewServer(Address string) (*System_Ntp_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Ntp_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Ntp_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Ntp) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Ntp) GetOrCreateServer(Address string) *System_Ntp_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Ntp) GetServer(Address string) *System_Ntp_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver System_Ntp. If there is no such element, the function
// is a no-op.
func (t *System_Ntp) DeleteServer(Address string) {
	key := Address

	delete(t.Server, key)
}

// AppendServer appends the supplied System_Ntp_Server struct to the
// list Server of System_Ntp. If the key value(s) specified in
// the supplied System_Ntp_Server already exist in the list, an error is
// returned.
func (t *System_Ntp) AppendServer(v *System_Ntp_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Ntp_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Ntp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Ntp_NtpKey struct, which is a YANG list entry.
func (t *System_Ntp_NtpKey) ΛListKeyMap() (map[string]interface{}, error) {
	if t.KeyId == nil {
		return nil, fmt.Errorf("nil value for key KeyId")
	}

	return map[string]interface{}{
		"key-id": *t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Ntp_NtpKey) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp_NtpKey"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp_NtpKey) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Ntp_Server struct, which is a YANG list entry.
func (t *System_Ntp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Ntp_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Process struct, which is a YANG list entry.
func (t *System_Process) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Pid == nil {
		return nil, fmt.Errorf("nil value for key Pid")
	}

	return map[string]interface{}{
		"pid": *t.Pid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_Process) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Process"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Process) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_SshServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_SshServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_SshServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *System_TelnetServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_TelnetServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_TelnetServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewChannel creates a new entry in the Channel list of the
// TerminalDevice struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice) NewChannel(Index uint32) (*TerminalDevice_Channel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint32]*TerminalDevice_Channel)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Channel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Channel", key)
	}

	t.Channel[key] = &TerminalDevice_Channel{
		Index: &Index,
	}

	return t.Channel[key], nil
}

// RenameChannel renames an entry in the list Channel within
// the TerminalDevice struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice) RenameChannel(oldK, newK uint32) error {
	if _, ok := t.Channel[newK]; ok {
		return fmt.Errorf("key %v already exists in Channel", newK)
	}

	e, ok := t.Channel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Channel", oldK)
	}
	e.Index = &newK

	t.Channel[newK] = e
	delete(t.Channel, oldK)
	return nil
}

// GetOrCreateChannel retrieves the value with the specified keys from
// the receiver TerminalDevice. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice) GetOrCreateChannel(Index uint32) *TerminalDevice_Channel {

	key := Index

	if v, ok := t.Channel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChannel(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChannel got unexpected error: %v", err))
	}
	return v
}

// GetChannel retrieves the value with the specified key from
// the Channel map field of TerminalDevice. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice) GetChannel(Index uint32) *TerminalDevice_Channel {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Channel[key]; ok {
		return lm
	}
	return nil
}

// DeleteChannel deletes the value with the specified keys from
// the receiver TerminalDevice. If there is no such element, the function
// is a no-op.
func (t *TerminalDevice) DeleteChannel(Index uint32) {
	key := Index

	delete(t.Channel, key)
}

// AppendChannel appends the supplied TerminalDevice_Channel struct to the
// list Channel of TerminalDevice. If the key value(s) specified in
// the supplied TerminalDevice_Channel already exist in the list, an error is
// returned.
func (t *TerminalDevice) AppendChannel(v *TerminalDevice_Channel) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint32]*TerminalDevice_Channel)
	}

	if _, ok := t.Channel[key]; ok {
		return fmt.Errorf("duplicate key for list Channel %v", key)
	}

	t.Channel[key] = v
	return nil
}

// NewMode creates a new entry in the Mode list of the
// TerminalDevice struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice) NewMode(ModeId uint16) (*TerminalDevice_Mode, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mode == nil {
		t.Mode = make(map[uint16]*TerminalDevice_Mode)
	}

	key := ModeId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mode[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mode", key)
	}

	t.Mode[key] = &TerminalDevice_Mode{
		ModeId: &ModeId,
	}

	return t.Mode[key], nil
}

// RenameMode renames an entry in the list Mode within
// the TerminalDevice struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice) RenameMode(oldK, newK uint16) error {
	if _, ok := t.Mode[newK]; ok {
		return fmt.Errorf("key %v already exists in Mode", newK)
	}

	e, ok := t.Mode[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mode", oldK)
	}
	e.ModeId = &newK

	t.Mode[newK] = e
	delete(t.Mode, oldK)
	return nil
}

// GetOrCreateMode retrieves the value with the specified keys from
// the receiver TerminalDevice. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice) GetOrCreateMode(ModeId uint16) *TerminalDevice_Mode {

	key := ModeId

	if v, ok := t.Mode[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMode(ModeId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMode got unexpected error: %v", err))
	}
	return v
}

// GetMode retrieves the value with the specified key from
// the Mode map field of TerminalDevice. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice) GetMode(ModeId uint16) *TerminalDevice_Mode {

	if t == nil {
		return nil
	}

	key := ModeId

	if lm, ok := t.Mode[key]; ok {
		return lm
	}
	return nil
}

// DeleteMode deletes the value with the specified keys from
// the receiver TerminalDevice. If there is no such element, the function
// is a no-op.
func (t *TerminalDevice) DeleteMode(ModeId uint16) {
	key := ModeId

	delete(t.Mode, key)
}

// AppendMode appends the supplied TerminalDevice_Mode struct to the
// list Mode of TerminalDevice. If the key value(s) specified in
// the supplied TerminalDevice_Mode already exist in the list, an error is
// returned.
func (t *TerminalDevice) AppendMode(v *TerminalDevice_Mode) error {
	key := *v.ModeId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mode == nil {
		t.Mode = make(map[uint16]*TerminalDevice_Mode)
	}

	if _, ok := t.Mode[key]; ok {
		return fmt.Errorf("duplicate key for list Mode %v", key)
	}

	t.Mode[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAssignment creates a new entry in the Assignment list of the
// TerminalDevice_Channel struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice_Channel) NewAssignment(Index uint32) (*TerminalDevice_Channel_Assignment, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Assignment == nil {
		t.Assignment = make(map[uint32]*TerminalDevice_Channel_Assignment)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Assignment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Assignment", key)
	}

	t.Assignment[key] = &TerminalDevice_Channel_Assignment{
		Index: &Index,
	}

	return t.Assignment[key], nil
}

// RenameAssignment renames an entry in the list Assignment within
// the TerminalDevice_Channel struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice_Channel) RenameAssignment(oldK, newK uint32) error {
	if _, ok := t.Assignment[newK]; ok {
		return fmt.Errorf("key %v already exists in Assignment", newK)
	}

	e, ok := t.Assignment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Assignment", oldK)
	}
	e.Index = &newK

	t.Assignment[newK] = e
	delete(t.Assignment, oldK)
	return nil
}

// GetOrCreateAssignment retrieves the value with the specified keys from
// the receiver TerminalDevice_Channel. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice_Channel) GetOrCreateAssignment(Index uint32) *TerminalDevice_Channel_Assignment {

	key := Index

	if v, ok := t.Assignment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAssignment(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAssignment got unexpected error: %v", err))
	}
	return v
}

// GetAssignment retrieves the value with the specified key from
// the Assignment map field of TerminalDevice_Channel. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice_Channel) GetAssignment(Index uint32) *TerminalDevice_Channel_Assignment {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Assignment[key]; ok {
		return lm
	}
	return nil
}

// DeleteAssignment deletes the value with the specified keys from
// the receiver TerminalDevice_Channel. If there is no such element, the function
// is a no-op.
func (t *TerminalDevice_Channel) DeleteAssignment(Index uint32) {
	key := Index

	delete(t.Assignment, key)
}

// AppendAssignment appends the supplied TerminalDevice_Channel_Assignment struct to the
// list Assignment of TerminalDevice_Channel. If the key value(s) specified in
// the supplied TerminalDevice_Channel_Assignment already exist in the list, an error is
// returned.
func (t *TerminalDevice_Channel) AppendAssignment(v *TerminalDevice_Channel_Assignment) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Assignment == nil {
		t.Assignment = make(map[uint32]*TerminalDevice_Channel_Assignment)
	}

	if _, ok := t.Assignment[key]; ok {
		return fmt.Errorf("duplicate key for list Assignment %v", key)
	}

	t.Assignment[key] = v
	return nil
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel) GetOrCreateEthernet() *TerminalDevice_Channel_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &TerminalDevice_Channel_Ethernet{}
	return t.Ethernet
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel) GetOrCreateIngress() *TerminalDevice_Channel_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &TerminalDevice_Channel_Ingress{}
	return t.Ingress
}

// GetOrCreateOtn retrieves the value of the Otn field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel) GetOrCreateOtn() *TerminalDevice_Channel_Otn {
	if t.Otn != nil {
		return t.Otn
	}
	t.Otn = &TerminalDevice_Channel_Otn{}
	return t.Otn
}

// GetEthernet returns the value of the Ethernet struct pointer
// from TerminalDevice_Channel. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel) GetEthernet() *TerminalDevice_Channel_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from TerminalDevice_Channel. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel) GetIngress() *TerminalDevice_Channel_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetOtn returns the value of the Otn struct pointer
// from TerminalDevice_Channel. If the receiver or the field Otn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel) GetOtn() *TerminalDevice_Channel_Otn {
	if t != nil && t.Otn != nil {
		return t.Otn
	}
	return nil
}

// ΛListKeyMap returns the keys of the TerminalDevice_Channel struct, which is a YANG list entry.
func (t *TerminalDevice_Channel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the TerminalDevice_Channel_Assignment struct, which is a YANG list entry.
func (t *TerminalDevice_Channel_Assignment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Assignment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Assignment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Assignment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Ingress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEsnr retrieves the value of the Esnr field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel_Otn) GetOrCreateEsnr() *TerminalDevice_Channel_Otn_Esnr {
	if t.Esnr != nil {
		return t.Esnr
	}
	t.Esnr = &TerminalDevice_Channel_Otn_Esnr{}
	return t.Esnr
}

// GetOrCreatePostFecBer retrieves the value of the PostFecBer field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel_Otn) GetOrCreatePostFecBer() *TerminalDevice_Channel_Otn_PostFecBer {
	if t.PostFecBer != nil {
		return t.PostFecBer
	}
	t.PostFecBer = &TerminalDevice_Channel_Otn_PostFecBer{}
	return t.PostFecBer
}

// GetOrCreatePreFecBer retrieves the value of the PreFecBer field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel_Otn) GetOrCreatePreFecBer() *TerminalDevice_Channel_Otn_PreFecBer {
	if t.PreFecBer != nil {
		return t.PreFecBer
	}
	t.PreFecBer = &TerminalDevice_Channel_Otn_PreFecBer{}
	return t.PreFecBer
}

// GetOrCreateQValue retrieves the value of the QValue field
// or returns the existing field if it already exists.
func (t *TerminalDevice_Channel_Otn) GetOrCreateQValue() *TerminalDevice_Channel_Otn_QValue {
	if t.QValue != nil {
		return t.QValue
	}
	t.QValue = &TerminalDevice_Channel_Otn_QValue{}
	return t.QValue
}

// GetEsnr returns the value of the Esnr struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field Esnr is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel_Otn) GetEsnr() *TerminalDevice_Channel_Otn_Esnr {
	if t != nil && t.Esnr != nil {
		return t.Esnr
	}
	return nil
}

// GetPostFecBer returns the value of the PostFecBer struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field PostFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel_Otn) GetPostFecBer() *TerminalDevice_Channel_Otn_PostFecBer {
	if t != nil && t.PostFecBer != nil {
		return t.PostFecBer
	}
	return nil
}

// GetPreFecBer returns the value of the PreFecBer struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field PreFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel_Otn) GetPreFecBer() *TerminalDevice_Channel_Otn_PreFecBer {
	if t != nil && t.PreFecBer != nil {
		return t.PreFecBer
	}
	return nil
}

// GetQValue returns the value of the QValue struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field QValue is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *TerminalDevice_Channel_Otn) GetQValue() *TerminalDevice_Channel_Otn_QValue {
	if t != nil && t.QValue != nil {
		return t.QValue
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Otn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Otn_Esnr) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_Esnr"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_Esnr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Otn_PostFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_PostFecBer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_PostFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Otn_PreFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_PreFecBer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_PreFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Channel_Otn_QValue) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_QValue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_QValue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the TerminalDevice_Mode struct, which is a YANG list entry.
func (t *TerminalDevice_Mode) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModeId == nil {
		return nil, fmt.Errorf("nil value for key ModeId")
	}

	return map[string]interface{}{
		"mode-id": *t.ModeId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *TerminalDevice_Mode) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Mode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Mode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }
